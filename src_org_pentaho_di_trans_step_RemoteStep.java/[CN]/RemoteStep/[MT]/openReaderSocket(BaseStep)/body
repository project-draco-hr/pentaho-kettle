{
  final RowSet rowSet=new RowSet(baseStep.getTransMeta().getSizeRowset());
  rowSet.setThreadNameFromToCopy(sourceStep,sourceStepCopyNr,targetStep,targetStepCopyNr);
  this.baseStep=baseStep;
  int portNumber=Integer.parseInt(baseStep.environmentSubstitute(port));
  String realHostname=baseStep.environmentSubstitute(hostname);
  long startTime=System.currentTimeMillis();
  boolean connected=false;
  KettleException lastException=null;
  while (!connected && (TIMEOUT_IN_SECONDS > (System.currentTimeMillis() - startTime) / 1000) && !baseStep.isStopped()) {
    try {
      socket=new Socket(realHostname,portNumber);
      connected=true;
      if (compressingStreams) {
        inputStream=new DataInputStream(new BufferedInputStream(new GZIPInputStream(socket.getInputStream()),bufferSize));
      }
 else {
        inputStream=new DataInputStream(new BufferedInputStream(socket.getInputStream(),bufferSize));
      }
      outputStream=new DataOutputStream(socket.getOutputStream());
      lastException=null;
    }
 catch (    Exception e) {
      lastException=new KettleException("Unable to open socket to server " + realHostname + " port "+ portNumber,e);
    }
    if (lastException != null) {
      try {
        Thread.sleep(250);
      }
 catch (      InterruptedException e) {
        throw new KettleException("Interrupted while trying to connect to server socket: " + e.toString());
      }
    }
  }
  if (lastException != null) {
    baseStep.logError("Error initialising step: " + lastException.toString());
    throw lastException;
  }
 else {
    if (inputStream == null)     throw new KettleException("Unable to connect to the SocketWriter in the " + TIMEOUT_IN_SECONDS + "s timeout period.");
  }
  Runnable runnable=new Runnable(){
    public void run(){
      try {
        RowMetaInterface rowMeta=new RowMeta(inputStream);
        Object[] rowData=rowMeta.readData(inputStream);
        while (rowData != null && !baseStep.isStopped()) {
          baseStep.linesInput++;
          rowSet.putRow(rowMeta,rowData);
          rowData=rowMeta.readData(inputStream);
        }
      }
 catch (      KettleEOFException e) {
      }
catch (      Exception e) {
        baseStep.logError("Error reading from client socket to remote step",e);
        baseStep.setErrors(1);
        baseStep.stopAll();
      }
 finally {
        try {
          sendRemoteConfirmation();
        }
 catch (        KettleException e) {
          baseStep.logError("Error handling remote confirmation server socket",e);
          baseStep.setErrors(1);
          baseStep.stopAll();
        }
        try {
          inputStream.close();
        }
 catch (        IOException e) {
          baseStep.logError("Error closing input stream, used for reading from remote step",e);
          baseStep.setErrors(1);
          baseStep.stopAll();
        }
        try {
          socket.close();
        }
 catch (        IOException e) {
          baseStep.logError("Error closing client socket connection to remote step",e);
          baseStep.setErrors(1);
          baseStep.stopAll();
        }
      }
      rowSet.setDone();
    }
  }
;
  new Thread(runnable).start();
  return rowSet;
}
