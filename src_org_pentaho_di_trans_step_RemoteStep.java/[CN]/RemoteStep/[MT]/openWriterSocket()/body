{
  final RowSet rowSet=new RowSet(baseStep.getTransMeta().getSizeRowset());
  rowSet.setThreadNameFromToCopy(sourceStep,sourceStepCopyNr,targetStep,targetStepCopyNr);
  rowSet.setRemoteSlaveServerName(targetSlaveServerName);
  Runnable runnable=new Runnable(){
    public void run(){
      try {
        socket=serverSocket.accept();
        if (compressingStreams) {
          gzipOutputStream=new GZIPOutputStream(socket.getOutputStream());
          outputStream=new DataOutputStream(new BufferedOutputStream(gzipOutputStream,bufferSize));
        }
 else {
          outputStream=new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(),bufferSize));
        }
        baseStep.logBasic("Server socket accepted for port [" + port + "], reading from server "+ targetSlaveServerName);
        Object[] rowData=baseStep.getRowFrom(rowSet);
        if (rowData != null) {
          rowSet.getRowMeta().writeMeta(outputStream);
        }
        while (rowData != null && !baseStep.isStopped()) {
          baseStep.linesRead--;
          baseStep.linesWritten--;
          rowSet.getRowMeta().writeData(outputStream,rowData);
          baseStep.linesOutput++;
          if (baseStep.log.isDebug())           baseStep.logDebug("Sent row to port " + port + " : "+ rowSet.getRowMeta().getString(rowData));
          rowData=baseStep.getRowFrom(rowSet);
        }
        if (compressingStreams) {
          outputStream.flush();
          gzipOutputStream.finish();
        }
 else {
          outputStream.flush();
        }
      }
 catch (      Exception e) {
        baseStep.logError("Error writing to remote step",e);
        baseStep.setErrors(1);
        baseStep.stopAll();
      }
 finally {
        try {
          if (socket != null)           socket.close();
        }
 catch (        IOException e) {
          baseStep.logError("Error closing output socket to remote step",e);
          baseStep.setErrors(1);
          baseStep.stopAll();
        }
      }
    }
  }
;
  new Thread(runnable).start();
  return rowSet;
}
