{
  TransLogTable transLogTable=transMeta.getTransLogTable();
  int intervalInSeconds=Const.toInt(environmentSubstitute(transLogTable.getLogInterval()),-1);
  try {
    String logTable=transLogTable.getActualTableName();
    SimpleDateFormat df=new SimpleDateFormat(REPLAY_DATE_FORMAT);
    log.logDetailed(BaseMessages.getString(PKG,"Trans.Log.TransformationCanBeReplayed") + df.format(currentDate));
    try {
      if (transLogTableDatabaseConnection != null && !Const.isEmpty(logTable) && !Const.isEmpty(transMeta.getName())) {
        transLogTableDatabaseConnection.writeLogRecord(transLogTable,LogStatus.START,this,null);
        if (!transLogTableDatabaseConnection.isAutoCommit()) {
          transLogTableDatabaseConnection.commitLog(true,transLogTable);
        }
        if (intervalInSeconds > 0) {
          final Timer timer=new Timer(getName() + " - interval logging timer");
          TimerTask timerTask=new TimerTask(){
            @Override public void run(){
              try {
                endProcessing();
              }
 catch (              Exception e) {
                log.logError(BaseMessages.getString(PKG,"Trans.Exception.UnableToPerformIntervalLogging"),e);
                errors.incrementAndGet();
                stopAll();
              }
            }
          }
;
          timer.schedule(timerTask,intervalInSeconds * 1000,intervalInSeconds * 1000);
          addTransListener(new TransAdapter(){
            @Override public void transFinished(            Trans trans){
              timer.cancel();
            }
          }
);
        }
        addTransListener(new TransAdapter(){
          @Override public void transFinished(          Trans trans) throws KettleException {
            try {
              endProcessing();
              lastWrittenStepPerformanceSequenceNr=writeStepPerformanceLogRecords(lastWrittenStepPerformanceSequenceNr,LogStatus.END);
            }
 catch (            KettleException e) {
              throw new KettleException(BaseMessages.getString(PKG,"Trans.Exception.UnableToPerformLoggingAtTransEnd"),e);
            }
          }
        }
);
      }
      StepLogTable stepLogTable=transMeta.getStepLogTable();
      if (stepLogTable.isDefined()) {
        addTransListener(new TransAdapter(){
          @Override public void transFinished(          Trans trans) throws KettleException {
            try {
              writeStepLogInformation();
            }
 catch (            KettleException e) {
              throw new KettleException(BaseMessages.getString(PKG,"Trans.Exception.UnableToPerformLoggingAtTransEnd"),e);
            }
          }
        }
);
      }
      ChannelLogTable channelLogTable=transMeta.getChannelLogTable();
      if (channelLogTable.isDefined()) {
        addTransListener(new TransAdapter(){
          @Override public void transFinished(          Trans trans) throws KettleException {
            try {
              writeLogChannelInformation();
            }
 catch (            KettleException e) {
              throw new KettleException(BaseMessages.getString(PKG,"Trans.Exception.UnableToPerformLoggingAtTransEnd"),e);
            }
          }
        }
);
      }
      PerformanceLogTable performanceLogTable=transMeta.getPerformanceLogTable();
      int perfLogInterval=Const.toInt(environmentSubstitute(performanceLogTable.getLogInterval()),-1);
      if (performanceLogTable.isDefined() && perfLogInterval > 0) {
        final Timer timer=new Timer(getName() + " - step performance log interval timer");
        TimerTask timerTask=new TimerTask(){
          @Override public void run(){
            try {
              lastWrittenStepPerformanceSequenceNr=writeStepPerformanceLogRecords(lastWrittenStepPerformanceSequenceNr,LogStatus.RUNNING);
            }
 catch (            Exception e) {
              log.logError(BaseMessages.getString(PKG,"Trans.Exception.UnableToPerformIntervalPerformanceLogging"),e);
              errors.incrementAndGet();
              stopAll();
            }
          }
        }
;
        timer.schedule(timerTask,perfLogInterval * 1000,perfLogInterval * 1000);
        addTransListener(new TransAdapter(){
          @Override public void transFinished(          Trans trans){
            timer.cancel();
          }
        }
);
      }
    }
 catch (    KettleException e) {
      throw new KettleTransException(BaseMessages.getString(PKG,"Trans.Exception.ErrorWritingLogRecordToTable",logTable),e);
    }
 finally {
      if (transLogTableDatabaseConnection != null && (intervalInSeconds <= 0)) {
        transLogTableDatabaseConnection.disconnect();
        transLogTableDatabaseConnection=null;
      }
    }
  }
 catch (  KettleException e) {
    throw new KettleTransException(BaseMessages.getString(PKG,"Trans.Exception.UnableToBeginProcessingTransformation"),e);
  }
}
