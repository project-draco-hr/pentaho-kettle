{
  MemoryGroupByMeta meta=new MemoryGroupByMeta();
  meta.allocate(groupFields.size(),aggFields.size());
  boolean returnRow=false;
  for (int i=0; i < groupFields.size(); i++) {
    SQLField field=groupFields.get(i);
    meta.getGroupField()[i]=field.getField();
  }
  for (int i=0; i < aggFields.size(); i++) {
    SQLField field=aggFields.get(i);
    ValueMetaInterface valueMeta=field.getValueMeta();
    meta.getAggregateField()[i]=Const.NVL(field.getAlias(),field.getField());
    String subjectField;
    if (field.getValueData() == null) {
      if (valueMeta == null) {
        if (inputFields.size() == 0) {
          throw new KettleException("No field fields found to aggregate on.");
        }
        subjectField=inputFields.getValueMeta(0).getName();
      }
 else {
        subjectField=valueMeta.getName();
      }
    }
 else {
      subjectField="Constant_" + field.getFieldIndex() + "_"+ field.getField();
    }
    meta.getSubjectField()[i]=subjectField;
    int agg=0;
switch (field.getAggregation()) {
case SUM:
      agg=MemoryGroupByMeta.TYPE_GROUP_SUM;
    break;
case MIN:
  agg=MemoryGroupByMeta.TYPE_GROUP_MIN;
break;
case MAX:
agg=MemoryGroupByMeta.TYPE_GROUP_MAX;
break;
case COUNT:
if (field.isCountStar()) {
agg=MemoryGroupByMeta.TYPE_GROUP_COUNT_ANY;
}
 else if (field.isCountDistinct()) {
agg=MemoryGroupByMeta.TYPE_GROUP_COUNT_DISTINCT;
}
 else {
agg=MemoryGroupByMeta.TYPE_GROUP_COUNT_ALL;
}
returnRow=true;
break;
case AVG:
agg=MemoryGroupByMeta.TYPE_GROUP_AVERAGE;
break;
default :
throw new KettleException("Unhandled aggregation method [" + field.getAggregation() + "]");
}
meta.getAggregateType()[i]=agg;
}
meta.setAlwaysGivingBackOneRow(returnRow);
StepMeta stepMeta=new StepMeta("Group by",meta);
stepMeta.setLocation(xLocation,50);
xLocation+=100;
stepMeta.setDraw(true);
return stepMeta;
}
