{
  getData().mappingTrans=new Trans(getData().mappingTransMeta,this);
  setMappingParameters();
  if (getData().mappingTransMeta.getTransformationType() != TransformationType.Normal) {
    getData().mappingTrans.getTransMeta().setUsingThreadPriorityManagment(false);
  }
  getData().mappingTrans.setParentTrans(getTrans());
  getData().mappingTrans.setSafeModeEnabled(getTrans().isSafeModeEnabled());
  getData().mappingTrans.setGatheringMetrics(getTrans().isGatheringMetrics());
  getData().mappingTrans.setMappingStepName(getStepname());
  initServletConfig();
  try {
    getData().mappingTrans.prepareExecution(getTrans().getArguments());
  }
 catch (  KettleException e) {
    throw new KettleException(BaseMessages.getString(PKG,"SimpleMapping.Exception.UnableToPrepareExecutionOfMapping"),e);
  }
  MappingInput[] mappingInputs=getData().mappingTrans.findMappingInput();
  if (mappingInputs.length == 0) {
    throw new KettleException("The simple mapping step needs one Mapping Input step to write to in the sub-transformation");
  }
  if (mappingInputs.length > 1) {
    throw new KettleException("The simple mapping step does not support multiple Mapping Input steps to write to in the sub-transformation");
  }
  getData().mappingInput=mappingInputs[0];
  getData().mappingInput.setConnectorSteps(new StepInterface[0],new ArrayList<MappingValueRename>(),null);
  MappingOutput[] mappingOutputs=getData().mappingTrans.findMappingOutput();
  if (mappingOutputs.length == 0) {
    throw new KettleException("The simple mapping step needs one Mapping Output step to read from in the sub-transformation");
  }
  if (mappingOutputs.length > 1) {
    throw new KettleException("The simple mapping step does not support " + "multiple Mapping Output steps to read from in the sub-transformation");
  }
  getData().mappingOutput=mappingOutputs[0];
  getTrans().getActiveSubtransformations().put(getStepname(),getData().mappingTrans);
}
