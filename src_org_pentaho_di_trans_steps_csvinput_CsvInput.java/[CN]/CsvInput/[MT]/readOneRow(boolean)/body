{
  try {
    Object[] outputRowData=RowDataUtil.allocateRowData(data.outputRowMeta.size());
    int outputIndex=0;
    boolean newLineFound=false;
    boolean endOfBuffer=false;
    int newLines=0;
    List<Exception> conversionExceptions=null;
    List<ValueMetaInterface> exceptionFields=null;
    while (!newLineFound && outputIndex < meta.getInputFields().length) {
      if (checkBufferSize()) {
        if (outputRowData != null) {
          if (outputIndex > 0) {
            return (outputRowData);
          }
        }
        return null;
      }
      boolean delimiterFound=false;
      boolean enclosureFound=false;
      int escapedEnclosureFound=0;
      while (!delimiterFound) {
        if (data.delimiterMatcher.matchesPattern(data.byteBuffer,data.endBuffer,data.delimiter)) {
          delimiterFound=true;
        }
 else         if (data.crLfMatcher.isReturn(data.byteBuffer,data.endBuffer) || data.crLfMatcher.isLineFeed(data.byteBuffer,data.endBuffer)) {
          if (data.encodingType.equals(EncodingType.DOUBLE_LITTLE_ENDIAN) || data.encodingType.equals(EncodingType.DOUBLE_BIG_ENDIAN)) {
            data.endBuffer+=2;
          }
 else {
            data.endBuffer++;
          }
          data.totalBytesRead++;
          newLines=1;
          if (data.endBuffer >= data.bufferSize) {
            data.resizeByteBufferArray();
            data.readBufferFromFile();
          }
          if (data.crLfMatcher.isReturn(data.byteBuffer,data.endBuffer) || data.crLfMatcher.isLineFeed(data.byteBuffer,data.endBuffer)) {
            data.endBuffer++;
            data.totalBytesRead++;
            newLines=2;
            if (data.endBuffer >= data.bufferSize) {
              data.resizeByteBufferArray();
              data.readBufferFromFile();
            }
          }
          newLineFound=true;
          delimiterFound=true;
        }
 else         if (data.enclosure != null && data.enclosureMatcher.matchesPattern(data.byteBuffer,data.endBuffer,data.enclosure)) {
          enclosureFound=true;
          boolean keepGoing;
          do {
            if (data.increaseEndBuffer()) {
              enclosureFound=false;
              break;
            }
            keepGoing=!data.enclosureMatcher.matchesPattern(data.byteBuffer,data.endBuffer,data.enclosure);
            if (!keepGoing) {
              if (data.increaseEndBuffer()) {
                enclosureFound=false;
                break;
              }
              keepGoing=data.enclosureMatcher.matchesPattern(data.byteBuffer,data.endBuffer,data.enclosure);
              if (keepGoing)               escapedEnclosureFound++;
            }
          }
 while (keepGoing);
          if (data.endBuffer >= data.bufferSize) {
            newLineFound=true;
            newLines+=2;
            endOfBuffer=true;
            break;
          }
        }
 else {
          data.endBuffer++;
          data.totalBytesRead++;
          if (checkBufferSize()) {
            if (data.endBuffer >= data.bufferSize) {
              newLineFound=true;
              break;
            }
          }
        }
      }
      int length=calculateFieldLength(newLineFound,newLines,enclosureFound,endOfBuffer);
      byte[] field=new byte[length];
      System.arraycopy(data.byteBuffer,data.startBuffer,field,0,length);
      if (escapedEnclosureFound > 0) {
        if (log.isRowLevel())         logRowlevel("Escaped enclosures found in " + new String(field));
        field=data.removeEscapedEnclosures(field,escapedEnclosureFound);
      }
      if (doConversions) {
        if (meta.isLazyConversionActive()) {
          outputRowData[outputIndex++]=field;
        }
 else {
          ValueMetaInterface sourceValueMeta=data.convertRowMeta.getValueMeta(outputIndex);
          try {
            outputRowData[outputIndex++]=sourceValueMeta.convertBinaryStringToNativeType(field);
          }
 catch (          KettleValueException e) {
            outputRowData[outputIndex++]=null;
            if (conversionExceptions == null) {
              conversionExceptions=new ArrayList<Exception>();
              exceptionFields=new ArrayList<ValueMetaInterface>();
            }
            conversionExceptions.add(e);
            exceptionFields.add(sourceValueMeta);
          }
        }
      }
 else {
        outputRowData[outputIndex++]=null;
      }
      if (!newLineFound) {
        data.endBuffer++;
        data.totalBytesRead++;
      }
      data.startBuffer=data.endBuffer;
    }
    if (!newLineFound && !checkBufferSize()) {
      do {
        data.endBuffer++;
        data.totalBytesRead++;
        if (checkBufferSize()) {
          break;
        }
      }
 while (!data.crLfMatcher.isReturn(data.byteBuffer,data.endBuffer) && !data.crLfMatcher.isLineFeed(data.byteBuffer,data.endBuffer));
      if (!checkBufferSize()) {
        while (data.crLfMatcher.isReturn(data.byteBuffer,data.endBuffer) || data.crLfMatcher.isLineFeed(data.byteBuffer,data.endBuffer)) {
          data.endBuffer++;
          data.totalBytesRead++;
          if (checkBufferSize()) {
            break;
          }
        }
      }
      data.startBuffer=data.endBuffer;
    }
    if (meta.isIncludingFilename() && !Const.isEmpty(meta.getFilenameField())) {
      if (meta.isLazyConversionActive()) {
        outputRowData[data.filenameFieldIndex]=data.binaryFilename;
      }
 else {
        outputRowData[data.filenameFieldIndex]=data.filenames[data.filenr - 1];
      }
    }
    if (data.isAddingRowNumber) {
      outputRowData[data.rownumFieldIndex]=new Long(data.rowNumber++);
    }
    incrementLinesInput();
    if (conversionExceptions != null && conversionExceptions.size() > 0) {
      throw new KettleConversionException("There were " + conversionExceptions.size() + " conversion errors on line "+ getLinesInput(),conversionExceptions,exceptionFields,outputRowData);
    }
    return outputRowData;
  }
 catch (  KettleConversionException e) {
    throw e;
  }
catch (  Exception e) {
    throw new KettleFileException("Exception reading line using NIO",e);
  }
}
