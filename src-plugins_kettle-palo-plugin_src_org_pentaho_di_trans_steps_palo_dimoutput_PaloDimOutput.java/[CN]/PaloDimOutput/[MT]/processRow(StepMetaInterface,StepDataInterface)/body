{
  meta=(PaloDimOutputMeta)smi;
  data=(PaloDimOutputData)sdi;
  Object[] r=getRow();
  if (first) {
    first=false;
    this.logBasic("First Row Analysis:");
    if (meta.getLevels().size() == 0)     throw new KettleException("Number of levels must be greater that 0 to process the rows");
    this.logBasic("Number of defined levels: " + meta.getLevels().size());
    data.indexes=new int[meta.getLevels().size() * 2];
    for (int i=0; i < meta.getLevels().size(); i++) {
      String dataFieldName=meta.getLevels().get(i).getFieldName();
      int numRow=getInputRowMeta().indexOfValue(dataFieldName);
      if (numRow < 0)       throw new KettleException("DimOutput: failed to find input row meta for ".concat(meta.getLevels().get(i).getLevelName()));
      data.indexes[i * 2]=numRow;
      this.logDebug(meta.getLevels().get(i).getLevelName() + " has index: " + numRow);
      String consolidationFieldName=meta.getLevels().get(i).getConsolidationFieldName();
      if (consolidationFieldName == null) {
        numRow=-1;
        this.logDebug("Consolidation factor was left to the default");
      }
 else {
        numRow=getInputRowMeta().indexOfValue(consolidationFieldName);
        if (numRow < 0)         throw new KettleException("DimOutput: failed to find input row meta for ".concat(meta.getLevels().get(i).getConsolidationFieldName()));
        this.logDebug(meta.getLevels().get(i).getConsolidationFieldName() + " has index: " + numRow);
      }
      data.indexes[(i * 2) + 1]=numRow;
    }
  }
  if (r == null) {
    try {
      this.logBasic("All rows have been read. Looking for consolidations");
      this.logDebug("Read rows:" + this.currentTransformationRows.size());
      DimensionGroupingCollection newDimension=data.helper.getConsolidations(meta.getDimension(),this.currentTransformationRows);
      this.logBasic("Consolidations got.");
      this.logBasic(newDimension == null ? "Null Consolidations" : " Consolidations Ok");
      this.logBasic("Add Dimension " + meta.getDimension());
      data.helper.addDimension(meta.getDimension(),newDimension,meta.getCreateNewDimension(),meta.getClearDimension(),meta.getClearConsolidations(),meta.getRecreateDimension(),meta.getEnableElementCache(),meta.getPreloadElementCache(),meta.getElementType());
      this.logBasic("Dimension Added.");
      setOutputDone();
      return false;
    }
 catch (    Exception e) {
      throw new KettleException("Failed to add dimension rows",e);
    }
  }
  try {
    String[] newRow=new String[data.indexes.length];
    for (int i=0; i < data.indexes.length; i++) {
      if (i % 2 == 1 && data.indexes[i] < 0)       newRow[i]="1";
 else       newRow[i]=r[data.indexes[i]].toString();
    }
    incrementLinesOutput();
    this.currentTransformationRows.add(newRow);
  }
 catch (  Exception e) {
    throw new KettleException("Failed to add row to the row buffer",e);
  }
  return true;
}
