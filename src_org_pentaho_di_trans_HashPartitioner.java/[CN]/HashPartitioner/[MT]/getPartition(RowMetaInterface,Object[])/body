{
  init(rowMeta);
  ValueMetaInterface vmeta=rowMeta.getValueMeta(partitionColumnIndex);
  int targetLocation=0;
  int hashOut=0;
  if (r == null) {
    return -1;
  }
  int length=1;
  Object value=r[partitionColumnIndex];
  int[] key=null;
  for (int i=0; i < length; i++) {
    int type=vmeta.getType();
    boolean caseInsensitive=true;
switch (type) {
case ValueMeta.TYPE_BIGNUMBER:
      BigDecimal bg=vmeta.getBigNumber(value);
    key=new int[1];
  key[0]=bg.intValue();
break;
case ValueMeta.TYPE_BINARY:
byte[] bArray=vmeta.getBinary(value);
key=byteArrayToIntArray(bArray);
break;
case ValueMeta.TYPE_BOOLEAN:
Boolean b=vmeta.getBoolean(value);
key=StringToInt(b.toString(),caseInsensitive);
break;
case ValueMeta.TYPE_DATE:
Date d=vmeta.getDate(value);
key=StringToInt(d.toString(),caseInsensitive);
break;
case ValueMeta.TYPE_INTEGER:
Long l=vmeta.getInteger(value);
key=new int[1];
key[0]=l.intValue();
break;
case ValueMeta.TYPE_NONE:
throw new IllegalArgumentException("Cannot hash this field " + vmeta.getName());
case ValueMeta.TYPE_NUMBER:
Double dd=vmeta.getNumber(value);
key=new int[1];
key[0]=dd.intValue();
break;
case ValueMeta.TYPE_SERIALIZABLE:
case ValueMeta.TYPE_STRING:
key=StringToInt(vmeta.getString(value),caseInsensitive);
break;
}
hashOut+=Math.abs(hashword(key,key.length,7));
}
targetLocation=hashOut % nrPartitions;
return targetLocation;
}
