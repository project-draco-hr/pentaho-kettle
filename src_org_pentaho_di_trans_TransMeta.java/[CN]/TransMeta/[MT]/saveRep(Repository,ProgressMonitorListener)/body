{
  try {
    if (monitor != null)     monitor.subTask(Messages.getString("TransMeta.Monitor.LockingRepository"));
    rep.lockRepository();
    rep.insertLogEntry("save transformation '" + getName() + "'");
    rep.clearNextIDCounters();
    if (directory.getID() < 0) {
      throw new KettleException(Messages.getString("TransMeta.Exception.PlsSelectAValidDirectoryBeforeSavingTheTransformation"));
    }
    int nrWorks=2 + nrDatabases() + nrNotes()+ nrSteps()+ nrTransHops();
    if (monitor != null)     monitor.beginTask(Messages.getString("TransMeta.Monitor.SavingTransformationTask.Title") + getPathAndName(),nrWorks);
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingOfTransformationStarted"));
    if (monitor != null && monitor.isCanceled())     throw new KettleDatabaseException();
    if (monitor != null)     monitor.subTask(Messages.getString("TransMeta.Monitor.HandlingOldVersionTransformationTask.Title"));
    setID(rep.getTransformationID(getName(),directory.getID()));
    if (getID() <= 0) {
      setID(rep.getNextTransformationID());
    }
 else {
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.DeletingOldVersionTransformationTask.Title"));
      if (log.isDebug())       log.logDebug(toString(),Messages.getString("TransMeta.Log.DeletingOldVersionTransformation"));
      rep.delAllFromTrans(getID());
      if (log.isDebug())       log.logDebug(toString(),Messages.getString("TransMeta.Log.OldVersionOfTransformationRemoved"));
    }
    if (monitor != null)     monitor.worked(1);
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingNotes"));
    for (int i=0; i < nrNotes(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.SavingNoteTask.Title") + (i + 1) + "/"+ nrNotes());
      NotePadMeta ni=getNote(i);
      ni.saveRep(rep,getID());
      if (ni.getID() > 0)       rep.insertTransNote(getID(),ni.getID());
      if (monitor != null)       monitor.worked(1);
    }
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingDatabaseConnections"));
    for (int i=0; i < nrDatabases(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.SavingDatabaseTask.Title") + (i + 1) + "/"+ nrDatabases());
      DatabaseMeta databaseMeta=getDatabase(i);
      if (databaseMeta.hasChanged() || databaseMeta.getID() <= 0) {
        RepositoryUtil.saveDatabaseMeta(databaseMeta,rep);
      }
      if (monitor != null)       monitor.worked(1);
    }
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.CheckingStepTypes"));
    rep.updateStepTypes();
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingSteps"));
    for (int i=0; i < nrSteps(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.SavingStepTask.Title") + (i + 1) + "/"+ nrSteps());
      StepMeta stepMeta=getStep(i);
      stepMeta.saveRep(rep,getID());
      if (monitor != null)       monitor.worked(1);
    }
    rep.closeStepAttributeInsertPreparedStatement();
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingHops"));
    for (int i=0; i < nrTransHops(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.SavingHopTask.Title") + (i + 1) + "/"+ nrTransHops());
      TransHopMeta hi=getTransHop(i);
      hi.saveRep(rep,getID());
      if (monitor != null)       monitor.worked(1);
    }
    if (monitor != null)     monitor.subTask(Messages.getString("TransMeta.Monitor.FinishingTask.Title"));
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingTransformationInfo"));
    rep.insertTransformation(this);
    saveRepParameters(rep);
    rep.closeTransAttributeInsertPreparedStatement();
    for (int i=0; i < partitionSchemas.size(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      PartitionSchema partitionSchema=partitionSchemas.get(i);
      boolean isUsedByTransformation=isUsingPartitionSchema(partitionSchema);
      partitionSchema.saveRep(rep,getID(),isUsedByTransformation);
    }
    for (int i=0; i < slaveServers.size(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      SlaveServer slaveServer=slaveServers.get(i);
      boolean isUsedByTransformation=isUsingSlaveServer(slaveServer);
      slaveServer.saveRep(rep,getID(),isUsedByTransformation);
    }
    for (int i=0; i < clusterSchemas.size(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      ClusterSchema clusterSchema=clusterSchemas.get(i);
      boolean isUsedByTransformation=isUsingClusterSchema(clusterSchema);
      clusterSchema.saveRep(rep,getID(),isUsedByTransformation);
    }
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingDependencies"));
    for (int i=0; i < nrDependencies(); i++) {
      if (monitor != null && monitor.isCanceled())       throw new KettleDatabaseException(Messages.getString("TransMeta.Log.UserCancelledTransSave"));
      TransDependency td=getDependency(i);
      td.saveRep(rep,getID());
    }
    for (int i=0; i < nrSteps(); i++) {
      StepMeta stepMeta=getStep(i);
      StepErrorMeta stepErrorMeta=stepMeta.getStepErrorMeta();
      if (stepErrorMeta != null) {
        stepErrorMeta.saveRep(rep,getId(),stepMeta.getID());
      }
    }
    rep.closeStepAttributeInsertPreparedStatement();
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("TransMeta.Log.SavingFinished"));
    if (monitor != null)     monitor.subTask(Messages.getString("TransMeta.Monitor.UnlockingRepository"));
    rep.unlockRepository();
    rep.commit();
    clearChanged();
    if (monitor != null)     monitor.worked(1);
    if (monitor != null)     monitor.done();
  }
 catch (  KettleDatabaseException dbe) {
    rep.rollback();
    log.logError(toString(),Messages.getString("TransMeta.Log.ErrorSavingTransformationToRepository") + Const.CR + dbe.getMessage());
    throw new KettleException(Messages.getString("TransMeta.Log.ErrorSavingTransformationToRepository"),dbe);
  }
 finally {
    rep.unlockRepository();
  }
}
