{
  Object[] outputRowData=getRow();
  if (outputRowData == null) {
    setOutputDone();
    return false;
  }
  if (first) {
    first=false;
    data.nrfields=meta.getUpdateLookup().length;
    if (data.nrfields == 0) {
      throw new KettleException(BaseMessages.getString(PKG,"LDAPOutputUpdateDialog.FieldsMissing.DialogMessage"));
    }
    data.fieldsAttribute=new String[data.nrfields];
    data.fieldStream=new int[data.nrfields];
    List<Integer> fieldsToUpdateInStreaml=new ArrayList<Integer>();
    List<String> fieldsToUpdateAttributel=new ArrayList<String>();
    for (int i=0; i < data.nrfields; i++) {
      data.fieldStream[i]=getInputRowMeta().indexOfValue(environmentSubstitute(meta.getUpdateStream()[i]));
      if (data.fieldStream[i] < 0) {
        throw new KettleException("Field [" + meta.getUpdateStream()[i] + "] couldn't be found in the input stream!");
      }
      data.fieldsAttribute[i]=environmentSubstitute(meta.getUpdateLookup()[i]);
      if (meta.getOperationType() == LDAPOutputMeta.OPERATION_TYPE_UPSERT) {
        if (meta.getUpdate()[i].booleanValue()) {
          fieldsToUpdateInStreaml.add(data.fieldStream[i]);
          fieldsToUpdateAttributel.add(data.fieldsAttribute[i]);
        }
      }
    }
    data.nrfieldsToUpdate=fieldsToUpdateInStreaml.size();
    if (data.nrfieldsToUpdate > 0) {
      data.fieldStreamToUpdate=new int[data.nrfieldsToUpdate];
      data.fieldsAttributeToUpdate=new String[data.nrfieldsToUpdate];
      for (int i=0; i < fieldsToUpdateInStreaml.size(); i++) {
        data.fieldStreamToUpdate[i]=(Integer)fieldsToUpdateInStreaml.get(i);
        data.fieldsAttributeToUpdate[i]=(String)fieldsToUpdateAttributel.get(i);
      }
    }
    fieldsToUpdateInStreaml=null;
    fieldsToUpdateAttributel=null;
    String dnField=environmentSubstitute(meta.getDnField());
    if (Const.isEmpty(dnField)) {
      throw new KettleException(BaseMessages.getString(PKG,"LDAPOutput.Error.DNFieldMissing"));
    }
    data.indexOfDNField=getInputRowMeta().indexOfValue(dnField);
    if (data.indexOfDNField < 0) {
      throw new KettleException(BaseMessages.getString(PKG,"LDAPOutput.Error.CanNotFindField",dnField));
    }
    if (meta.getOperationType() != LDAPOutputMeta.OPERATION_TYPE_DELETE) {
      data.attributes=new String[data.nrfields];
      if (meta.getOperationType() == LDAPOutputMeta.OPERATION_TYPE_UPSERT && data.nrfieldsToUpdate > 0) {
        data.attributesToUpdate=new String[data.nrfieldsToUpdate];
      }
    }
  }
  incrementLinesInput();
  try {
    String dn=getInputRowMeta().getString(outputRowData,data.indexOfDNField);
    if (isDebug())     logDebug(BaseMessages.getString(PKG,"LDAPOutput.ProcessDn",dn));
    if (meta.getOperationType() != LDAPOutputMeta.OPERATION_TYPE_DELETE) {
      for (int i=0; i < data.nrfields; i++) {
        data.attributes[i]=getInputRowMeta().getString(outputRowData,data.fieldStream[i]);
      }
    }
    if (meta.getOperationType() != LDAPOutputMeta.OPERATION_TYPE_UPSERT) {
      for (int i=0; i < data.nrfieldsToUpdate; i++) {
        data.attributesToUpdate[i]=getInputRowMeta().getString(outputRowData,data.fieldStreamToUpdate[i]);
      }
    }
switch (meta.getOperationType()) {
case LDAPOutputMeta.OPERATION_TYPE_UPSERT:
      int status=data.connection.upsert(dn,data.fieldsAttribute,data.attributes,data.fieldsAttributeToUpdate,data.attributesToUpdate,data.separator);
switch (status) {
case LDAPConnection.STATUS_INSERTED:
      incrementLinesOutput();
    break;
case LDAPConnection.STATUS_UPDATED:
  incrementLinesUpdated();
break;
default :
incrementLinesSkipped();
break;
}
break;
case LDAPOutputMeta.OPERATION_TYPE_UPDATE:
status=data.connection.update(dn,data.fieldsAttribute,data.attributes,meta.isFailIfNotExist());
switch (status) {
case LDAPConnection.STATUS_UPDATED:
incrementLinesUpdated();
break;
default :
incrementLinesSkipped();
break;
}
break;
case LDAPOutputMeta.OPERATION_TYPE_ADD:
status=data.connection.add(dn,data.fieldsAttribute,data.attributes,data.separator,meta.isFailIfNotExist());
switch (status) {
case LDAPConnection.STATUS_ADDED:
incrementLinesUpdated();
break;
default :
incrementLinesSkipped();
break;
}
break;
case LDAPOutputMeta.OPERATION_TYPE_DELETE:
status=data.connection.delete(dn,meta.isFailIfNotExist());
switch (status) {
case LDAPConnection.STATUS_DELETED:
incrementLinesUpdated();
break;
default :
incrementLinesSkipped();
break;
}
break;
default :
data.connection.insert(dn,data.fieldsAttribute,data.attributes,data.separator);
incrementLinesOutput();
break;
}
putRow(getInputRowMeta(),outputRowData);
if (log.isRowLevel()) logRowlevel(BaseMessages.getString(PKG,"LDAPOutput.log.ReadRow"),getInputRowMeta().getString(outputRowData));
if (checkFeedback(getLinesInput())) {
if (log.isDetailed()) logDetailed(BaseMessages.getString(PKG,"LDAPOutput.log.LineRow") + getLinesInput());
}
return true;
}
 catch (Exception e) {
boolean sendToErrorRow=false;
String errorMessage=null;
if (getStepMeta().isDoingErrorHandling()) {
sendToErrorRow=true;
errorMessage=e.toString();
}
 else {
logError(BaseMessages.getString(PKG,"LDAPOutput.log.Exception",e.getMessage()));
setErrors(1);
logError(Const.getStackTracker(e));
stopAll();
setOutputDone();
return false;
}
if (sendToErrorRow) {
putError(getInputRowMeta(),outputRowData,1,errorMessage,null,"LDAPOutput001");
}
}
return true;
}
