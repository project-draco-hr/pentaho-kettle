{
  try {
    remarks.clear();
    Hashtable values=new Hashtable();
    String stepnames[];
    StepMeta steps[];
    if (!only_selected || nrSelectedSteps() == 0) {
      stepnames=getStepNames();
      steps=getStepsArray();
    }
 else {
      stepnames=getSelectedStepNames();
      steps=getSelectedSteps();
    }
    boolean stop_checking=false;
    if (monitor != null)     monitor.beginTask(Messages.getString("TransMeta.Monitor.VerifyingThisTransformationTask.Title"),steps.length + 2);
    for (int i=0; i < steps.length && !stop_checking; i++) {
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.VerifyingStepTask.Title",stepnames[i]));
      StepMeta stepMeta=steps[i];
      int nrinfo=findNrInfoSteps(stepMeta);
      StepMeta[] infostep=null;
      if (nrinfo > 0) {
        infostep=getInfoStep(stepMeta);
      }
      RowMetaInterface info=null;
      if (infostep != null) {
        try {
          info=getStepFields(infostep);
        }
 catch (        KettleStepException kse) {
          info=null;
          CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,Messages.getString("TransMeta.CheckResult.TypeResultError.ErrorOccurredGettingStepInfoFields.Description","" + stepMeta,Const.CR + kse.getMessage()),stepMeta);
          remarks.add(cr);
        }
      }
      RowMetaInterface prev=null;
      try {
        prev=getPrevStepFields(stepMeta);
      }
 catch (      KettleStepException kse) {
        CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,Messages.getString("TransMeta.CheckResult.TypeResultError.ErrorOccurredGettingInputFields.Description","" + stepMeta,Const.CR + kse.getMessage()),stepMeta);
        remarks.add(cr);
        stop_checking=true;
      }
      if (isStepUsedInTransHops(stepMeta)) {
        String input[]=getPrevStepNames(stepMeta);
        String output[]=getPrevStepNames(stepMeta);
        stepMeta.check(remarks,prev,input,output,info);
        if (prev != null) {
          for (int x=0; x < prev.size(); x++) {
            ValueMetaInterface v=prev.getValueMeta(x);
            String name=v.getName();
            if (name == null)             values.put(v,Messages.getString("TransMeta.Value.CheckingFieldName.FieldNameIsEmpty.Description"));
 else             if (name.indexOf(' ') >= 0)             values.put(v,Messages.getString("TransMeta.Value.CheckingFieldName.FieldNameContainsSpaces.Description"));
 else {
              char list[]=new char[]{'.',',','-','/','+','*','\'','\t','"','|','@','(',')','{','}','!','^'};
              for (int c=0; c < list.length; c++) {
                if (name.indexOf(list[c]) >= 0)                 values.put(v,Messages.getString("TransMeta.Value.CheckingFieldName.FieldNameContainsUnfriendlyCodes.Description",String.valueOf(list[c])));
              }
            }
          }
          if (prev.size() > 1) {
            String fieldNames[]=prev.getFieldNames();
            String sortedNames[]=Const.sortStrings(fieldNames);
            String prevName=sortedNames[0];
            for (int x=1; x < sortedNames.length; x++) {
              if (prevName.equalsIgnoreCase(sortedNames[x])) {
                CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,Messages.getString("TransMeta.CheckResult.TypeResultWarning.HaveTheSameNameField.Description",prevName),stepMeta);
                remarks.add(cr);
              }
 else {
                prevName=sortedNames[x];
              }
            }
          }
        }
 else {
          CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,Messages.getString("TransMeta.CheckResult.TypeResultError.CannotFindPreviousFields.Description") + stepMeta.getName(),stepMeta);
          remarks.add(cr);
        }
      }
 else {
        CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_WARNING,Messages.getString("TransMeta.CheckResult.TypeResultWarning.StepIsNotUsed.Description"),stepMeta);
        remarks.add(cr);
      }
      try {
        checkRowMixingStatically(stepMeta,null);
      }
 catch (      KettleRowException e) {
        CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,e.getMessage(),stepMeta);
        remarks.add(cr);
      }
      if (monitor != null) {
        monitor.worked(1);
        if (monitor.isCanceled())         stop_checking=true;
      }
    }
    if (monitor == null || !monitor.isCanceled()) {
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.CheckingTheLoggingTableTask.Title"));
      if (getLogConnection() != null) {
        Database logdb=new Database(getLogConnection());
        try {
          logdb.connect();
          CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_OK,Messages.getString("TransMeta.CheckResult.TypeResultOK.ConnectingWorks.Description"),null);
          remarks.add(cr);
          if (getLogTable() != null) {
            if (logdb.checkTableExists(getLogTable())) {
              cr=new CheckResult(CheckResult.TYPE_RESULT_OK,Messages.getString("TransMeta.CheckResult.TypeResultOK.LoggingTableExists.Description",getLogTable()),null);
              remarks.add(cr);
              RowMetaInterface fields=Database.getTransLogrecordFields(isBatchIdUsed(),isLogfieldUsed());
              String sql=logdb.getDDL(getLogTable(),fields);
              if (sql == null || sql.length() == 0) {
                cr=new CheckResult(CheckResult.TYPE_RESULT_OK,Messages.getString("TransMeta.CheckResult.TypeResultOK.CorrectLayout.Description"),null);
                remarks.add(cr);
              }
 else {
                cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,Messages.getString("TransMeta.CheckResult.TypeResultError.LoggingTableNeedsAdjustments.Description") + Const.CR + sql,null);
                remarks.add(cr);
              }
            }
 else {
              cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,Messages.getString("TransMeta.CheckResult.TypeResultError.LoggingTableDoesNotExist.Description"),null);
              remarks.add(cr);
            }
          }
 else {
            cr=new CheckResult(CheckResult.TYPE_RESULT_ERROR,Messages.getString("TransMeta.CheckResult.TypeResultError.LogTableNotSpecified.Description"),null);
            remarks.add(cr);
          }
        }
 catch (        KettleDatabaseException dbe) {
        }
 finally {
          logdb.disconnect();
        }
      }
      if (monitor != null)       monitor.worked(1);
    }
    if (monitor != null)     monitor.subTask(Messages.getString("TransMeta.Monitor.CheckingForDatabaseUnfriendlyCharactersInFieldNamesTask.Title"));
    if (values.size() > 0) {
      Enumeration keys=values.keys();
      while (keys.hasMoreElements()) {
        ValueMetaInterface v=(ValueMetaInterface)keys.nextElement();
        String message=(String)values.get(v);
        CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_WARNING,Messages.getString("TransMeta.CheckResult.TypeResultWarning.Description",v.getName(),message,v.getOrigin()),findStep(v.getOrigin()));
        remarks.add(cr);
      }
    }
 else {
      CheckResult cr=new CheckResult(CheckResult.TYPE_RESULT_OK,Messages.getString("TransMeta.CheckResult.TypeResultOK.Description"),null);
      remarks.add(cr);
    }
    if (monitor != null)     monitor.worked(1);
  }
 catch (  Exception e) {
    LogWriter.getInstance().logError(toString(),Const.getStackTracker(e));
    throw new RuntimeException(e);
  }
}
