{
  clear();
  File file=new File(Const.getKettleLocalRepositoriesFile());
  if (!file.exists() || !file.isFile()) {
    log.logDetailed("No repositories file found in the local directory: " + file.getAbsolutePath());
    file=new File(Const.getKettleUserRepositoriesFile());
    if (!file.exists() || !file.isFile()) {
      return true;
    }
  }
  log.logBasic("Reading repositories XML file: " + file.getAbsoluteFile());
  DocumentBuilderFactory dbf;
  DocumentBuilder db;
  Document doc;
  try {
    dbf=DocumentBuilderFactory.newInstance();
    db=dbf.newDocumentBuilder();
    try {
      doc=db.parse(file);
    }
 catch (    FileNotFoundException ef) {
      InputStream is=getClass().getResourceAsStream("/org/pentaho/di/repository/repositories.xml");
      if (is != null) {
        doc=db.parse(is);
      }
 else {
        throw new KettleException("Error opening file: " + file.getAbsoluteFile(),ef);
      }
    }
    Node repsnode=XMLHandler.getSubNode(doc,"repositories");
    int nrconn=XMLHandler.countNodes(repsnode,"connection");
    log.logDebug("We have " + nrconn + " connections...");
    for (int i=0; i < nrconn; i++) {
      log.logDebug("Looking at connection #" + i);
      Node dbnode=XMLHandler.getSubNodeByNr(repsnode,"connection",i);
      DatabaseMeta dbcon=new DatabaseMeta(dbnode);
      addDatabase(dbcon);
      log.logDebug("Read connection : " + dbcon.getName());
    }
    int nrreps=XMLHandler.countNodes(repsnode,RepositoryMeta.XML_TAG);
    log.logDebug("We have " + nrreps + " repositories...");
    StringBuffer unableToReadIds=new StringBuffer();
    KettleException kettleException=null;
    for (int i=0; i < nrreps; i++) {
      Node repnode=XMLHandler.getSubNodeByNr(repsnode,RepositoryMeta.XML_TAG,i);
      log.logDebug("Looking at repository #" + i);
      String id=XMLHandler.getTagValue(repnode,"id");
      if (Const.isEmpty(id)) {
        id=KettleDatabaseRepositoryMeta.REPOSITORY_TYPE_ID;
      }
      try {
        RepositoryMeta repositoryMeta=PluginRegistry.getInstance().loadClass(RepositoryPluginType.class,id,RepositoryMeta.class);
        if (repositoryMeta != null) {
          repositoryMeta.loadXML(repnode,databases);
          if (repositoryMeta.getDescription() == null || repositoryMeta.getDescription().equals("")) {
            repositoryMeta.setDescription(repositoryMeta.getName());
          }
          addRepository(repositoryMeta);
          log.logDebug("Read repository : " + repositoryMeta.getName());
        }
 else {
          unableToReadIds.append(id);
          unableToReadIds.append(",");
          log.logDebug("Unable to read repository with id: " + id);
        }
      }
 catch (      KettleException ex) {
        Throwable cause=ex;
        kettleException=ex;
        while (cause.getCause() != null) {
          cause=cause.getCause();
        }
        if (cause instanceof KettleRepositoryNotSupportedException) {
          log.logDebug("Repository type [" + id + "] is unrecognized");
        }
      }
    }
    if (unableToReadIds != null && unableToReadIds.length() > 0) {
      errorMessage="Unable to read repository with id [" + unableToReadIds.substring(0,unableToReadIds.lastIndexOf(",") - 1) + "].  RepositoryMeta is not available";
    }
    if (kettleException != null) {
      throw kettleException;
    }
  }
 catch (  Exception e) {
    throw new KettleException("Error reading information from file : ",e);
  }
  return true;
}
