{
  this();
  type=getType(XMLHandler.getTagValue(node,"type"));
  storageType=getStorageType(XMLHandler.getTagValue(node,"storagetype"));
switch (storageType) {
case STORAGE_TYPE_INDEXED:
    Node indexNode=XMLHandler.getSubNode(node,"index");
  int nrIndexes=XMLHandler.countNodes(indexNode,"value");
index=new Object[nrIndexes];
for (int i=0; i < index.length; i++) {
Node valueNode=XMLHandler.getSubNodeByNr(indexNode,"value",i);
String valueString=XMLHandler.getNodeValue(valueNode);
if (Utils.isEmpty(valueString)) {
  index[i]=null;
}
 else {
switch (type) {
case TYPE_STRING:
    index[i]=valueString;
  break;
case TYPE_NUMBER:
index[i]=Double.parseDouble(valueString);
break;
case TYPE_INTEGER:
index[i]=Long.parseLong(valueString);
break;
case TYPE_DATE:
index[i]=XMLHandler.stringToDate(valueString);
break;
case TYPE_BIGNUMBER:
index[i]=new BigDecimal(valueString);
break;
case TYPE_BOOLEAN:
index[i]=Boolean.valueOf("Y".equalsIgnoreCase(valueString));
break;
case TYPE_BINARY:
index[i]=XMLHandler.stringToBinary(valueString);
break;
default :
throw new KettleException(toString() + " : Unable to de-serialize indexe storage type from XML for data type " + getType());
}
}
}
break;
case STORAGE_TYPE_BINARY_STRING:
Node storageMetaNode=XMLHandler.getSubNode(node,"storage-meta");
Node storageValueMetaNode=XMLHandler.getSubNode(storageMetaNode,XML_META_TAG);
if (storageValueMetaNode != null) {
storageMetadata=new ValueMetaBase(storageValueMetaNode);
}
break;
default :
break;
}
name=XMLHandler.getTagValue(node,"name");
length=Integer.parseInt(XMLHandler.getTagValue(node,"length"));
precision=Integer.parseInt(XMLHandler.getTagValue(node,"precision"));
origin=XMLHandler.getTagValue(node,"origin");
comments=XMLHandler.getTagValue(node,"comments");
conversionMask=XMLHandler.getTagValue(node,"conversion_Mask");
decimalSymbol=XMLHandler.getTagValue(node,"decimal_symbol");
groupingSymbol=XMLHandler.getTagValue(node,"grouping_symbol");
currencySymbol=XMLHandler.getTagValue(node,"currency_symbol");
trimType=getTrimTypeByCode(XMLHandler.getTagValue(node,"trim_type"));
caseInsensitive="Y".equalsIgnoreCase(XMLHandler.getTagValue(node,"case_insensitive"));
collatorDisabled="Y".equalsIgnoreCase(XMLHandler.getTagValue(node,"collator_disabled"));
if (XMLHandler.getTagValue(node,"collator_strength") != null) {
collatorStrength=Integer.parseInt(XMLHandler.getTagValue(node,"collator_strength"));
}
sortedDescending="Y".equalsIgnoreCase(XMLHandler.getTagValue(node,"sort_descending"));
outputPaddingEnabled="Y".equalsIgnoreCase(XMLHandler.getTagValue(node,"output_padding"));
dateFormatLenient="Y".equalsIgnoreCase(XMLHandler.getTagValue(node,"date_format_lenient"));
String dateFormatLocaleString=XMLHandler.getTagValue(node,"date_format_locale");
if (!Utils.isEmpty(dateFormatLocaleString)) {
dateFormatLocale=EnvUtil.createLocale(dateFormatLocaleString);
}
String dateTimeZoneString=XMLHandler.getTagValue(node,"date_format_timezone");
if (!Utils.isEmpty(dateTimeZoneString)) {
dateFormatTimeZone=EnvUtil.createTimeZone(dateTimeZoneString);
}
 else {
dateFormatTimeZone=TimeZone.getDefault();
}
lenientStringToNumber="Y".equalsIgnoreCase(XMLHandler.getTagValue(node,"lenient_string_to_number"));
}
