{
  ArrayList transHopSteps=originalTransformation.getTransHopSteps(false);
  StepMeta[] originalSteps=(StepMeta[])transHopSteps.toArray(new StepMeta[transHopSteps.size()]);
  for (int i=0; i < originalSteps.length; i++) {
    StepMeta stepMeta=originalSteps[i];
    StepPartitioningMeta source=stepMeta.getStepPartitioningMeta();
    StepPartitioningMeta target=new StepPartitioningMeta();
    if (source == null)     break;
    if (source.getMethod() == StepPartitioningMeta.PARTITIONING_METHOD_NONE)     break;
    ClusterSchema clusterSchema=stepMeta.getClusterSchema();
    if (clusterSchema == null)     break;
    PartitionSchema partitionSchema=source.getPartitionSchema();
    int nrPartitions=partitionSchema.getPartitionIDs().length;
    int nrSlaves=clusterSchema.getSlaveServers().size();
    if (nrPartitions < nrSlaves) {
      throw new KettleException("It doesn't make sense to have a database partitioned, clustered step with less partitions (" + nrPartitions + ") than that there are slave servers ("+ nrSlaves+ ")");
    }
    List partitions=new ArrayList();
    for (int s=0; s < clusterSchema.getSlaveServers().size(); s++) {
      SlaveServer server=(SlaveServer)clusterSchema.getSlaveServers().get(s);
      if (!server.isMaster()) {
      }
    }
    PartitionSchema targetSchema=new PartitionSchema(partitionSchema.getName(),(String[])partitions.toArray(new String[partitions.size()]));
  }
}
