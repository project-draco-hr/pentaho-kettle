{
  int mx, my;
  int x3;
  int y3;
  int x4;
  int y4;
  int a, b, dist;
  double angle;
  gc.drawLine(x1,y1,x2,y2);
  a=Math.abs(x2 - x1);
  b=Math.abs(y2 - y1);
  dist=(int)Math.sqrt(a * a + b * b);
  if (factor < 0) {
    if (dist >= 2 * iconsize)     factor=1.3;
 else     factor=1.2;
  }
  mx=(int)(x1 + factor * (x2 - x1) / 2);
  my=(int)(y1 + factor * (y2 - y1) / 2);
  angle=Math.atan2(y2 - y1,x2 - x1) + Math.PI;
  x3=(int)(mx + Math.cos(angle - theta) * size);
  y3=(int)(my + Math.sin(angle - theta) * size);
  x4=(int)(mx + Math.cos(angle + theta) * size);
  y4=(int)(my + Math.sin(angle + theta) * size);
  gc.switchForegroundBackgroundColors();
  gc.fillPolygon(new int[]{mx,my,x3,y3,x4,y4});
  gc.switchForegroundBackgroundColors();
  factor=0.8;
  mx=(int)(x1 + factor * (x2 - x1) / 2) - 8;
  my=(int)(y1 + factor * (y2 - y1) / 2) - 8;
  if (jobHop != null) {
    EImage hopsIcon;
    if (jobHop.isUnconditional()) {
      hopsIcon=EImage.UNCONDITIONAL;
    }
 else {
      if (jobHop.getEvaluation()) {
        hopsIcon=EImage.TRUE;
      }
 else {
        hopsIcon=EImage.FALSE;
      }
    }
    Point bounds=gc.getImageBounds(hopsIcon);
    gc.drawImage(hopsIcon,mx,my);
    if (!shadow) {
      areaOwners.add(new AreaOwner(AreaType.JOB_HOP_ICON,mx,my,bounds.x,bounds.y,offset,subject,jobHop));
    }
    if (jobHop.getFromEntry().isLaunchingInParallel()) {
      factor=1;
      mx=(int)(x1 + factor * (x2 - x1) / 2) - 8;
      my=(int)(y1 + factor * (y2 - y1) / 2) - 8;
      hopsIcon=EImage.PARALLEL;
      gc.drawImage(hopsIcon,mx,my);
      if (!shadow) {
        areaOwners.add(new AreaOwner(AreaType.JOB_HOP_PARALLEL_ICON,mx,my,bounds.x,bounds.y,offset,subject,jobHop));
      }
    }
  }
}
