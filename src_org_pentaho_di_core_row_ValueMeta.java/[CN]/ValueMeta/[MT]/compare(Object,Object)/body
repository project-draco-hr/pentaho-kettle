{
  boolean n1=isNull(data1);
  boolean n2=isNull(data2);
  if (n1 && !n2)   return -1;
  if (!n1 && n2)   return 1;
  if (n1 && n2)   return 0;
  int cmp=0;
switch (getType()) {
case TYPE_STRING:
{
      String one=Const.rtrim(getString(data1));
      String two=Const.rtrim(getString(data2));
      if (caseInsensitive) {
        cmp=one.compareToIgnoreCase(two);
      }
 else {
        cmp=one.compareTo(two);
      }
    }
  break;
case TYPE_INTEGER:
{
  long compare=getInteger(data1).longValue() - getInteger(data2).longValue();
  if (compare < 0)   cmp=-1;
 else   if (compare > 0)   cmp=1;
 else   cmp=0;
}
break;
case TYPE_NUMBER:
{
cmp=Double.compare(getNumber(data1).doubleValue(),getNumber(data2).doubleValue());
}
break;
case TYPE_DATE:
{
long compare=getDate(data1).getTime() - getDate(data2).getTime();
if (compare < 0) cmp=-1;
 else if (compare > 0) cmp=1;
 else cmp=0;
}
break;
case TYPE_BIGNUMBER:
{
cmp=getBigNumber(data1).compareTo(getBigNumber(data2));
}
break;
case TYPE_BOOLEAN:
{
if (getBoolean(data1).booleanValue() == getBoolean(data2).booleanValue()) cmp=0;
 else if (getBoolean(data1).booleanValue() && !getBoolean(data2).booleanValue()) cmp=1;
 else cmp=-1;
}
break;
case TYPE_BINARY:
{
byte[] b1=(byte[])data1;
byte[] b2=(byte[])data2;
int length=b1.length < b2.length ? b1.length : b2.length;
for (int i=0; i < length; i++) {
cmp=b1[i] - b2[i];
if (cmp != 0) {
cmp=Math.abs(cmp);
break;
}
}
}
break;
default :
throw new KettleValueException("Comparing values can not be done with data type : " + getType());
}
if (isSortedDescending()) {
return -cmp;
}
 else {
return cmp;
}
}
