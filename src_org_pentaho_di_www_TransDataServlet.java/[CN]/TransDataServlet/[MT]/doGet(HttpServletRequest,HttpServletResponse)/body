{
  if (isJettyMode() && !request.getContextPath().startsWith(CONTEXT_PATH)) {
    return;
  }
  if (log.isDebug())   logDebug(BaseMessages.getString(PKG,"GetStatusServlet.StatusRequested"));
  response.setStatus(HttpServletResponse.SC_OK);
  response.setContentType("binary/jdbc");
  response.setBufferSize(10000);
  final OutputStream outputStream=response.getOutputStream();
  final DataOutputStream dos=new DataOutputStream(outputStream);
  String sqlQuery=request.getHeader("SQL");
  final int maxRows=Const.toInt(request.getHeader("MaxRows"),-1);
  final String debugTransFile=request.getHeader(ThinConnection.ARG_DEBUGTRANS);
  Map<String,String> parameters=getParametersFromRequestHeader(request);
  try {
    final SqlTransExecutor executor=new SqlTransExecutor(sqlQuery,getTransformationMap().getSlaveServerConfig().getServices(),parameters);
    dos.writeUTF(executor.getServiceName());
    dos.writeUTF(SqlTransExecutor.calculateTransname(executor.getSql(),true));
    String serviceContainerObjectId=UUID.randomUUID().toString();
    dos.writeUTF(serviceContainerObjectId);
    dos.writeUTF(SqlTransExecutor.calculateTransname(executor.getSql(),false));
    String genContainerObjectId=UUID.randomUUID().toString();
    dos.writeUTF(genContainerObjectId);
    final AtomicBoolean firstRow=new AtomicBoolean(true);
    final AtomicInteger rowCounter=new AtomicInteger(0);
    executor.executeQuery(new RowAdapter(){
      @Override public void rowWrittenEvent(      RowMetaInterface rowMeta,      Object[] row) throws KettleStepException {
        try {
          if (firstRow.get()) {
            firstRow.set(false);
            rowMeta.writeMeta(dos);
          }
          rowMeta.writeData(dos,row);
          if (maxRows > 0 && rowCounter.incrementAndGet() > maxRows) {
            executor.getServiceTrans().stopAll();
          }
          dataSize.set(dos.size());
        }
 catch (        Exception e) {
          if (!executor.getServiceTrans().isStopped()) {
            throw new KettleStepException(e);
          }
        }
      }
    }
);
    TransMeta serviceTransMeta=executor.getGenTransMeta();
    Trans serviceTrans=executor.getServiceTrans();
    TransConfiguration serviceTransConfiguration=new TransConfiguration(serviceTransMeta,new TransExecutionConfiguration());
    transformationMap.addTransformation(serviceTransMeta.getName(),serviceContainerObjectId,serviceTrans,serviceTransConfiguration);
    TransMeta genTransMeta=executor.getGenTransMeta();
    Trans genTrans=executor.getGenTrans();
    TransConfiguration genTransConfiguration=new TransConfiguration(genTransMeta,new TransExecutionConfiguration());
    transformationMap.addTransformation(genTransMeta.getName(),genContainerObjectId,genTrans,genTransConfiguration);
    if (!Const.isEmpty(debugTransFile)) {
      try {
        FileOutputStream fos=new FileOutputStream(debugTransFile);
        fos.write(XMLHandler.getXMLHeader(Const.XML_ENCODING).getBytes(Const.XML_ENCODING));
        fos.write(genTransMeta.getXML().getBytes(Const.XML_ENCODING));
        fos.close();
      }
 catch (      Exception fnfe) {
        throw new KettleException(fnfe);
      }
    }
    executor.waitUntilFinished();
    Trans trans=executor.getGenTrans();
    Result result=executor.getGenTrans().getResult();
    if (result.getNrErrors() > 0) {
      String logText=CentralLogStore.getAppender().getBuffer(trans.getLogChannelId(),false).toString();
      throw new KettleException("Error executing transformation, log:" + Const.CR + logText);
    }
  }
 catch (  Exception e) {
    log.logError("Error executing SQL query: " + sqlQuery,e);
    response.sendError(500,Const.getStackTracker(e));
  }
 finally {
    System.out.println("bytes written: " + dataSize);
  }
}
