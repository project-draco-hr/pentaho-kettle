{
  String debug="Start of evaluate";
  boolean retval=false;
  LogWriter log=LogWriter.getInstance();
  try {
    if (isAtomic()) {
      debug="Atomic : get fieldnrs left value";
      if (left_valuename != null && left_valuename.length() > 0 && left_fieldnr < 0)       left_fieldnr=rowMeta.indexOfValue(left_valuename);
      debug="Atomic : get fieldnrs right value";
      if (right_valuename != null && right_valuename.length() > 0 && right_fieldnr < 0)       right_fieldnr=rowMeta.indexOfValue(right_valuename);
      debug="Atomic : get fieldnrs left field";
      ValueMetaInterface fieldMeta=null;
      Object field=null;
      if (left_fieldnr >= 0) {
        fieldMeta=rowMeta.getValueMeta(left_fieldnr);
        field=r[left_fieldnr];
        if (field == null) {
          throw new KettleException("Unable to find field [" + left_valuename + "] in the input row!");
        }
      }
      debug="Atomic : get fieldnrs right exact";
      ValueMetaInterface fieldMeta2=right_exact != null ? right_exact.getValueMeta() : null;
      Object field2=right_exact != null ? right_exact.getValueData() : null;
      if (field2 == null && right_fieldnr >= 0) {
        fieldMeta2=rowMeta.getValueMeta(right_fieldnr);
        field2=r[right_fieldnr];
        if (field2 == null) {
          throw new KettleException("Unable to find field [" + right_valuename + "] in the input row!");
        }
      }
      if (field == null) {
        throw new KettleException("Unable to find value for field [" + left_valuename + "] in the input row!");
      }
      if (field2 == null && function != FUNC_NULL && function != FUNC_NOT_NULL) {
        throw new KettleException("Unable to find value for field [" + right_valuename + "] in the input row!");
      }
      if (log.isDebug())       debug="Atomic : evaluate (function=" + Condition.functions[function] + ")";
switch (function) {
case FUNC_EQUAL:
        retval=(fieldMeta.compare(field,fieldMeta2,field2) == 0);
      break;
case FUNC_NOT_EQUAL:
    retval=(fieldMeta.compare(field,fieldMeta2,field2) != 0);
  break;
case FUNC_SMALLER:
retval=(fieldMeta.compare(field,fieldMeta2,field2) < 0);
break;
case FUNC_SMALLER_EQUAL:
retval=(fieldMeta.compare(field,fieldMeta2,field2) <= 0);
break;
case FUNC_LARGER:
retval=(fieldMeta.compare(field,fieldMeta2,field2) > 0);
break;
case FUNC_LARGER_EQUAL:
retval=(fieldMeta.compare(field,fieldMeta2,field2) >= 0);
break;
case FUNC_REGEXP:
if (fieldMeta.isNull(field) || field2 == null) {
retval=false;
}
 else {
retval=Pattern.matches(fieldMeta2.getString(field),fieldMeta.getString(field));
}
break;
case FUNC_NULL:
retval=(fieldMeta.isNull(field));
break;
case FUNC_NOT_NULL:
retval=(!fieldMeta.isNull(field));
break;
case FUNC_IN_LIST:
String list[]=Const.splitString(fieldMeta2.getString(field2),';');
retval=Const.indexOfString(fieldMeta.getString(field),list) >= 0;
break;
case FUNC_CONTAINS:
retval=fieldMeta.getString(field) != null ? fieldMeta.getString(field).indexOf(fieldMeta2.getString(field2)) >= 0 : false;
break;
case FUNC_STARTS_WITH:
retval=fieldMeta.getString(field) != null ? fieldMeta.getString(field).startsWith(fieldMeta2.getString(field2)) : false;
break;
case FUNC_ENDS_WITH:
retval=fieldMeta.getString(field) != null ? fieldMeta.getString(field).endsWith(fieldMeta2.getString(field2)) : false;
break;
default :
break;
}
debug="Atomic: optionally negate";
if (isNegated()) retval=!retval;
}
 else {
debug="Composite : get first";
Condition cb0=(Condition)list.get(0);
retval=cb0.evaluate(rowMeta,r);
for (int i=1; i < list.size(); i++) {
debug="Composite : evaluate #" + i;
Condition cb=(Condition)list.get(i);
boolean cmp=cb.evaluate(rowMeta,r);
switch (cb.getOperator()) {
case Condition.OPERATOR_OR:
retval=retval || cmp;
break;
case Condition.OPERATOR_AND:
retval=retval && cmp;
break;
case Condition.OPERATOR_OR_NOT:
retval=retval || (!cmp);
break;
case Condition.OPERATOR_AND_NOT:
retval=retval && (!cmp);
break;
case Condition.OPERATOR_XOR:
retval=retval ^ cmp;
break;
default :
break;
}
}
debug="Composite: optionally negate";
if (isNegated()) retval=!retval;
}
}
 catch (Exception e) {
throw new RuntimeException("Unexpected error evaluation condition [" + toString() + "] in part ["+ debug+ "]",e);
}
return retval;
}
