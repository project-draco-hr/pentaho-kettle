{
  setObjectId(null);
  steps=new ArrayList<StepMeta>();
  hops=new ArrayList<TransHopMeta>();
  dependencies=new ArrayList<TransDependency>();
  partitionSchemas=new ArrayList<PartitionSchema>();
  clusterSchemas=new ArrayList<ClusterSchema>();
  stepChangeListeners=new ArrayList<StepMetaChangeListenerInterface>();
  slaveStepCopyPartitionDistribution=new SlaveStepCopyPartitionDistribution();
  trans_status=-1;
  trans_version=null;
  transLogTable=TransLogTable.getDefault(this,this,steps);
  performanceLogTable=PerformanceLogTable.getDefault(this,this);
  stepLogTable=StepLogTable.getDefault(this,this);
  metricsLogTable=MetricsLogTable.getDefault(this,this);
  sizeRowset=Const.ROWS_IN_ROWSET;
  sleepTimeEmpty=Const.TIMEOUT_GET_MILLIS;
  sleepTimeFull=Const.TIMEOUT_PUT_MILLIS;
  maxDateConnection=null;
  maxDateTable=null;
  maxDateField=null;
  maxDateOffset=0.0;
  maxDateDifference=0.0;
  undo=new ArrayList<TransAction>();
  max_undo=Const.MAX_UNDO;
  undo_position=-1;
  counters=new Hashtable<String,Counter>();
  resultRows=null;
  super.clear();
  dbCache=DBCache.getInstance();
  resultRows=new ArrayList<RowMetaAndData>();
  resultFiles=new ArrayList<ResultFile>();
  feedbackShown=true;
  feedbackSize=Const.ROWS_UPDATE;
  usingThreadPriorityManagment=true;
  capturingStepPerformanceSnapShots=false;
  stepPerformanceCapturingDelay=1000;
  stepPerformanceCapturingSizeLimit="100";
  stepsFieldsCache=new HashMap<String,RowMetaInterface>();
  loopCache=new HashMap<String,Boolean>();
  transformationType=TransformationType.Normal;
  log=LogChannel.GENERAL;
}
