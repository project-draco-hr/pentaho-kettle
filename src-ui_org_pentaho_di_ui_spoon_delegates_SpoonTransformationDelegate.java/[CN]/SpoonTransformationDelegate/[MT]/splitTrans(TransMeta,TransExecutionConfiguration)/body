{
  try {
    final TransSplitter transSplitter=new TransSplitter(transMeta);
    transSplitter.splitOriginalTransformation();
    TransMeta master=transSplitter.getMaster();
    SlaveServer masterServer=null;
    List<StepMeta> masterSteps=master.getTransHopSteps(false);
    SlaveServer slaves[]=transSplitter.getSlaveTargets();
    if (executionConfiguration.isClusterShowingTransformation()) {
      if (masterSteps.size() > 0) {
        masterServer=transSplitter.getMasterServer();
        addTransGraph(master);
      }
      for (int i=0; i < slaves.length; i++) {
        TransMeta slaveTrans=(TransMeta)transSplitter.getSlaveTransMap().get(slaves[i]);
        addTransGraph(slaveTrans);
      }
    }
    Trans.executeClustered(transSplitter,executionConfiguration);
    if (executionConfiguration.isClusterPosting()) {
      if (masterServer != null) {
        spoon.addSpoonSlave(masterServer);
        for (int i=0; i < slaves.length; i++) {
          spoon.addSpoonSlave(slaves[i]);
        }
      }
    }
    new Thread(new Runnable(){
      public void run(){
        Trans.monitorClusteredTransformation(transMeta.toString(),transSplitter,null);
      }
    }
).start();
  }
 catch (  Exception e) {
    throw new KettleException(e);
  }
}
