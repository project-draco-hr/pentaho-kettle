{
  ByteArrayOutputStream line=new ByteArrayOutputStream(25000);
  try {
    for (int i=0; i < data.keynrs.length; i++) {
      if (i > 0) {
        line.write(data.separator);
      }
      int index=data.keynrs[i];
      ValueMetaInterface valueMeta=rowMeta.getValueMeta(index);
      Object valueData=r[index];
      String nullRep=new String(data.nullrepresentation);
      if (valueData != null) {
switch (valueMeta.getType()) {
case ValueMetaInterface.TYPE_STRING:
          String str=valueMeta.getString(valueData);
        if (str == null || str.equals(nullRep)) {
          line.write(str.getBytes());
          break;
        }
      line.write(data.quote);
    if (str == null) {
      line.write(data.nullrepresentation);
    }
 else {
      str=str.replace("\\","\\\\");
      str=str.replace("\"","\\\"");
      if (meta.isAutoStringWidths()) {
        int len=valueMeta.getLength();
        if (len < 1) {
          len=MonetDBDatabaseMeta.DEFAULT_VARCHAR_LENGTH;
        }
        if (str.length() > len) {
          str=str.substring(0,len);
        }
        line.write(str.getBytes(meta.getEncoding()));
      }
 else {
        line.write(str.getBytes(meta.getEncoding()));
      }
    }
  line.write(data.quote);
break;
case ValueMetaInterface.TYPE_INTEGER:
if (valueMeta.isStorageBinaryString() && meta.getFieldFormatOk()[i]) {
line.write((byte[])valueData);
}
 else {
Long value=valueMeta.getInteger(valueData);
if (value == null) {
  line.write(data.nullrepresentation);
}
 else {
  line.write(Long.toString(value).getBytes());
}
}
break;
case ValueMetaInterface.TYPE_DATE:
if (valueMeta.isStorageBinaryString() && meta.getFieldFormatOk()[i]) {
line.write((byte[])valueData);
}
 else {
ValueMetaInterface colMeta=null;
if (physicalTableRowMeta != null) {
colMeta=physicalTableRowMeta.getValueMeta(index);
}
Date value=valueMeta.getDate(valueData);
if (value == null) {
line.write(data.nullrepresentation);
}
 else {
if (colMeta != null && colMeta.getOriginalColumnTypeName().equalsIgnoreCase("date")) {
line.write(data.monetDateMeta.getString(value).getBytes());
}
 else if (colMeta != null && colMeta.getOriginalColumnTypeName().equalsIgnoreCase("time")) {
line.write(data.monetTimeMeta.getString(value).getBytes());
}
 else {
line.write(data.monetTimestampMeta.getString(value).getBytes());
}
}
}
break;
case ValueMetaInterface.TYPE_BOOLEAN:
{
Boolean value=valueMeta.getBoolean(valueData);
if (value == null) {
line.write(data.nullrepresentation);
}
 else {
if (value.booleanValue()) {
line.write("Y".getBytes());
}
 else {
line.write("N".getBytes());
}
}
}
break;
case ValueMetaInterface.TYPE_NUMBER:
if (valueMeta.isStorageBinaryString() && meta.getFieldFormatOk()[i]) {
line.write((byte[])valueData);
}
 else {
Double value=valueMeta.getNumber(valueData);
if (value == null) {
line.write(data.nullrepresentation);
}
 else {
line.write(Double.toString(value).getBytes());
}
}
break;
case ValueMetaInterface.TYPE_BIGNUMBER:
if (valueMeta.isStorageBinaryString() && meta.getFieldFormatOk()[i]) {
line.write((byte[])valueData);
}
 else {
String value=valueMeta.getString(valueData);
if (value == null) {
line.write(data.nullrepresentation);
}
 else {
line.write(value.getBytes());
}
}
break;
}
}
 else {
line.write(data.nullrepresentation);
}
}
line.write(data.newline);
data.rowBuffer[data.bufferIndex]=line.toString();
data.bufferIndex++;
}
 catch (Exception e) {
throw new KettleException("Error serializing rows of data to the MonetDB API (MAPI).",e);
}
}
