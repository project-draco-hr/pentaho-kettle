{
  try {
    super.loadRep(rep,id_jobentry,databases);
    long id_transformation=rep.getJobEntryAttributeInteger(id_jobentry,"id_transformation");
    Row r=rep.getTransformation(id_transformation);
    if (r != null) {
      transname=r.getString("NAME",null);
      long id_directory=r.getInteger("ID_DIRECTORY",0L);
      if (id_directory > 0) {
        directory=rep.getDirectoryTree().findDirectory(id_directory);
      }
 else {
        directory=rep.getDirectoryTree();
      }
    }
    filename=rep.getJobEntryAttributeString(id_jobentry,"filename");
    arg_from_previous=rep.getJobEntryAttributeBoolean(id_jobentry,"arg_from_previous");
    set_logfile=rep.getJobEntryAttributeBoolean(id_jobentry,"set_logfile");
    add_date=rep.getJobEntryAttributeBoolean(id_jobentry,"add_date");
    add_time=rep.getJobEntryAttributeBoolean(id_jobentry,"arg_time");
    logfile=rep.getJobEntryAttributeString(id_jobentry,"logfile");
    logext=rep.getJobEntryAttributeString(id_jobentry,"logext");
    loglevel=LogWriter.getLogLevel(rep.getJobEntryAttributeString(id_jobentry,"loglevel"));
    int argnr=rep.countNrJobEntryAttributes(id_jobentry,"argument");
    arguments=new String[argnr];
    for (int a=0; a < argnr; a++) {
      arguments[a]=rep.getJobEntryAttributeString(id_jobentry,a,"argument");
    }
  }
 catch (  KettleDatabaseException dbe) {
    throw new KettleException("Unable to load job entry of type transMeta from the repository for id_jobentry=" + id_jobentry,dbe);
  }
}
