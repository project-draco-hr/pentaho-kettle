{
  meta=(MetaInjectMeta)smi;
  data=(MetaInjectData)sdi;
  data.rowMap=new HashMap<String,List<RowMetaAndData>>();
  for (  String prevStepName : getTransMeta().getPrevStepNames(getStepMeta())) {
    List<RowMetaAndData> list=new ArrayList<RowMetaAndData>();
    RowSet rowSet=findInputRowSet(prevStepName);
    Object[] row=rowSet.getRow();
    while (row != null) {
      RowMetaAndData rd=new RowMetaAndData();
      rd.setRowMeta(rowSet.getRowMeta());
      rd.setData(row);
      list.add(rd);
      row=getRowFrom(rowSet);
    }
    if (!list.isEmpty()) {
      data.rowMap.put(prevStepName,list);
    }
  }
  for (  String targetStep : data.stepInjectionMap.keySet()) {
    System.out.println("Handing step " + targetStep + " injection!");
    StepMetaInjectionInterface injectionInterface=data.stepInjectionMap.get(targetStep);
    List<StepInjectionMetaEntry> metadataEntries=injectionInterface.getStepInjectionMetadataEntries();
    List<StepInjectionMetaEntry> inject=new ArrayList<StepInjectionMetaEntry>();
    Map<TargetStepAttribute,SourceStepField> targetMap=meta.getTargetSourceMapping();
    for (    TargetStepAttribute target : targetMap.keySet()) {
      SourceStepField source=targetMap.get(target);
      if (target.getStepname().equalsIgnoreCase(targetStep)) {
        List<RowMetaAndData> rows=data.rowMap.get(source.getStepname());
        if (rows != null && rows.size() > 0) {
          StepInjectionMetaEntry entry=findMetaEntry(metadataEntries,target.getAttributeKey());
          if (entry != null) {
            if (!target.isDetail()) {
              setEntryValue(entry,rows.get(0),source);
              inject.add(entry);
            }
 else {
              StepInjectionMetaEntry metaEntries=findMetaEntry(inject,entry.getKey());
              if (metaEntries == null) {
                StepInjectionMetaEntry rootEntry=findDetailRootEntry(metadataEntries,entry);
                metaEntries=rootEntry.clone();
                metaEntries.setDetails(new ArrayList<StepInjectionMetaEntry>());
                inject.add(metaEntries);
                StepInjectionMetaEntry metaEntry=rootEntry.getDetails().get(0);
                for (int i=0; i < rows.size(); i++) {
                  StepInjectionMetaEntry metaCopy=metaEntry.clone();
                  metaEntries.getDetails().add(metaCopy);
                  metaCopy.setDetails(new ArrayList<StepInjectionMetaEntry>());
                  for (                  StepInjectionMetaEntry me : metaEntry.getDetails()) {
                    StepInjectionMetaEntry meCopy=me.clone();
                    metaCopy.getDetails().add(meCopy);
                  }
                }
              }
 else {
                StepInjectionMetaEntry rootEntry=findDetailRootEntry(inject,metaEntries);
                metaEntries=rootEntry;
              }
              for (int i=0; i < rows.size(); i++) {
                RowMetaAndData row=rows.get(i);
                try {
                  List<StepInjectionMetaEntry> rowEntries=metaEntries.getDetails().get(i).getDetails();
                  for (                  StepInjectionMetaEntry rowEntry : rowEntries) {
                    SourceStepField detailSource=findDetailSource(targetMap,targetStep,rowEntry.getKey());
                    if (detailSource != null) {
                      setEntryValue(rowEntry,row,detailSource);
                    }
 else {
                      System.out.println("No detail source found for key: " + rowEntry.getKey() + " and target step: "+ targetStep);
                    }
                  }
                }
 catch (                Exception e) {
                  e.printStackTrace();
                }
              }
              System.out.println("injected entry: " + entry);
            }
          }
 else {
            System.out.println("entry not found: " + target.getAttributeKey());
          }
        }
 else {
          System.out.println("No rows found for source step: " + source.getStepname());
        }
      }
    }
    injectionInterface.injectStepMetadataEntries(inject);
  }
  System.out.println(data.transMeta.getXML());
  final Trans injectTrans=new Trans(data.transMeta,this);
  getTrans().addTransStoppedListener(new TransStoppedListener(){
    public void transStopped(    Trans parentTrans){
      injectTrans.stopAll();
    }
  }
);
  injectTrans.execute(null);
  while (!injectTrans.isFinished() && !injectTrans.isStopped()) {
    copyResult(injectTrans);
    try {
      Thread.sleep(500);
    }
 catch (    Exception e) {
    }
  }
  copyResult(injectTrans);
  setOutputDone();
  return false;
}
