{
  if (spoon.getTransMeta().nrSelectedSteps() == 0)   return;
  StepMeta steps[]=new StepMeta[spoon.getTransMeta().nrSelectedSteps()];
  Point before[]=new Point[spoon.getTransMeta().nrSelectedSteps()];
  Point after[]=new Point[spoon.getTransMeta().nrSelectedSteps()];
  int min=99999;
  int max=-99999;
  int sels=spoon.getTransMeta().nrSelectedSteps();
  if (sels <= 1)   return;
  int order[]=new int[sels];
  int selnr=0;
  for (int i=0; i < spoon.getTransMeta().nrSteps(); i++) {
    StepMeta stepMeta=spoon.getTransMeta().getStep(i);
    if (stepMeta.isSelected() && stepMeta.isDrawn()) {
      Point p=stepMeta.getLocation();
      if (p.y < min)       min=p.y;
      if (p.y > max)       max=p.y;
      order[selnr]=i;
      selnr++;
    }
  }
  for (int i=0; i < sels; i++) {
    for (int j=0; j < sels - 1; j++) {
      Point p1=spoon.getTransMeta().getStep(order[j]).getLocation();
      Point p2=spoon.getTransMeta().getStep(order[j + 1]).getLocation();
      if (p1.y > p2.y) {
        int dummy=order[j];
        order[j]=order[j + 1];
        order[j + 1]=dummy;
      }
    }
  }
  int distance=(max - min) / (sels - 1);
  for (int i=0; i < sels; i++) {
    steps[i]=spoon.getTransMeta().getStep(order[i]);
    Point p=steps[i].getLocation();
    before[i]=new Point(p.x,p.y);
    p.y=min + (i * distance);
    after[i]=new Point(p.x,p.y);
  }
  spoon.addUndoPosition(steps,spoon.getTransMeta().getStepIndexes(steps),before,after);
  redraw();
}
