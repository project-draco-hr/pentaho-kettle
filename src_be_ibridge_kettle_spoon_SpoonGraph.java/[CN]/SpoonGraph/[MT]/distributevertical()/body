{
  if (spoon.transMeta.nrSelectedSteps() == 0)   return;
  StepMeta steps[]=new StepMeta[spoon.transMeta.nrSelectedSteps()];
  Point before[]=new Point[spoon.transMeta.nrSelectedSteps()];
  Point after[]=new Point[spoon.transMeta.nrSelectedSteps()];
  int min=99999;
  int max=-99999;
  int sels=spoon.transMeta.nrSelectedSteps();
  if (sels <= 1)   return;
  int order[]=new int[sels];
  int selnr=0;
  for (int i=0; i < spoon.transMeta.nrSteps(); i++) {
    StepMeta stepMeta=spoon.transMeta.getStep(i);
    if (stepMeta.isSelected()) {
      Point p=stepMeta.getLocation();
      if (p.y < min)       min=p.y;
      if (p.y > max)       max=p.y;
      order[selnr]=i;
      selnr++;
    }
  }
  for (int i=0; i < sels; i++) {
    for (int j=0; j < sels - 1; j++) {
      Point p1=spoon.transMeta.getStep(order[j]).getLocation();
      Point p2=spoon.transMeta.getStep(order[j + 1]).getLocation();
      if (p1.y > p2.y) {
        int dummy=order[j];
        order[j]=order[j + 1];
        order[j + 1]=dummy;
      }
    }
  }
  int distance=(max - min) / (sels - 1);
  for (int i=0; i < sels; i++) {
    steps[i]=spoon.transMeta.getStep(order[i]);
    Point p=steps[i].getLocation();
    before[i]=new Point(p.x,p.y);
    p.y=min + (i * distance);
    after[i]=new Point(p.x,p.y);
  }
  spoon.addUndoPosition(steps,spoon.transMeta.getStepIndexes(steps),before,after);
  redraw();
}
