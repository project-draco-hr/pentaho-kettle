{
  if (Const.isEmpty(clusteredRunId)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a cluster run ID but it was empty");
  }
  if (portRangeStart <= 0) {
    throw new RuntimeException("A server socket allocation always has to accompanied by port range start > 0 but it was " + portRangeStart);
  }
  if (Const.isEmpty(hostname)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a hostname but it was empty");
  }
  if (Const.isEmpty(transformationName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a transformation name but it was empty");
  }
  if (Const.isEmpty(sourceSlaveName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a source slave server name but it was empty");
  }
  if (Const.isEmpty(targetSlaveName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a target slave server name but it was empty");
  }
  if (Const.isEmpty(sourceStepName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a source step name but it was empty");
  }
  if (Const.isEmpty(targetStepName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a target step name but it was empty");
  }
  if (Const.isEmpty(sourceStepCopy)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a source step copy but it was empty");
  }
  if (Const.isEmpty(targetStepCopy)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a target step copy but it was empty");
  }
synchronized (hostServerSocketPortsMap) {
    List<SocketPortAllocation> serverSocketPortsMap=hostServerSocketPortsMap.get(hostname);
    if (serverSocketPortsMap == null) {
      serverSocketPortsMap=new ArrayList<SocketPortAllocation>();
      hostServerSocketPortsMap.put(hostname,serverSocketPortsMap);
    }
synchronized (serverSocketPortsMap) {
      SocketPortAllocation socketPortAllocation=null;
      int maxPort=portRangeStart - 1;
      for (int index=0; index < serverSocketPortsMap.size(); index++) {
        SocketPortAllocation spa=serverSocketPortsMap.get(index);
        if (spa.getPort() > maxPort) {
          maxPort=spa.getPort();
        }
        if (spa.getClusterRunId().equalsIgnoreCase(clusteredRunId) && spa.getSourceSlaveName().equalsIgnoreCase(sourceSlaveName) && spa.getTargetSlaveName().equalsIgnoreCase(targetSlaveName)&& spa.getTransformationName().equalsIgnoreCase(transformationName)&& spa.getSourceStepName().equalsIgnoreCase(sourceStepName)&& spa.getSourceStepCopy().equalsIgnoreCase(sourceStepCopy)&& spa.getTargetStepName().equalsIgnoreCase(targetStepName)&& spa.getTargetStepCopy().equalsIgnoreCase(targetStepCopy)) {
          spa.setAllocated(true);
          socketPortAllocation=spa;
          break;
        }
 else {
          if (!spa.isAllocated()) {
            if (spa.getSourceSlaveName().equalsIgnoreCase(sourceSlaveName) && spa.getTargetSlaveName().equalsIgnoreCase(targetSlaveName)) {
              socketPortAllocation=new SocketPortAllocation(spa.getPort(),new Date(),clusteredRunId,transformationName,sourceSlaveName,sourceStepName,sourceStepCopy,targetSlaveName,targetStepName,targetStepCopy);
              serverSocketPortsMap.set(index,socketPortAllocation);
              break;
            }
          }
        }
      }
      if (socketPortAllocation == null) {
        socketPortAllocation=new SocketPortAllocation(maxPort + 1,new Date(),clusteredRunId,transformationName,sourceSlaveName,sourceStepName,sourceStepCopy,targetSlaveName,targetStepName,targetStepCopy);
        serverSocketPortsMap.add(socketPortAllocation);
      }
      for (int i=0; i < serverSocketPortsMap.size(); i++) {
        for (int j=0; j < serverSocketPortsMap.size(); j++) {
          if (i != j) {
            SocketPortAllocation one=serverSocketPortsMap.get(i);
            SocketPortAllocation two=serverSocketPortsMap.get(j);
            if (one.getPort() == two.getPort()) {
              System.out.println("!! Error detected !! Identical ports discovered in the ports list.");
            }
          }
        }
      }
      return socketPortAllocation;
    }
  }
}
