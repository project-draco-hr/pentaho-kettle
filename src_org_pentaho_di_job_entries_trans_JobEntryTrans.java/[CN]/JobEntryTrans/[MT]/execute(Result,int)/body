{
  result.setEntryNr(nr);
  Log4jFileAppender appender=null;
  int backupLogLevel=LogWriter.getInstance().getLogLevel();
  if (setLogfile) {
    String realLogFilename=environmentSubstitute(getLogFilename());
    if (!createParentFolder(realLogFilename)) {
      result.setNrErrors(1);
      result.setResult(false);
      return result;
    }
    try {
      appender=LogWriter.createFileAppender(realLogFilename,true,setAppendLogfile);
    }
 catch (    KettleException e) {
      logError(BaseMessages.getString(PKG,"JobTrans.Error.UnableOpenAppender",getLogFilename(),e.toString()));
      logError(Const.getStackTracker(e));
      result.setNrErrors(1);
      result.setResult(false);
      return result;
    }
    LogWriter.getInstance().addAppender(appender);
    LogWriter.getInstance().setLogLevel(loglevel);
  }
  SlaveServer remoteSlaveServer=null;
  if (!Const.isEmpty(remoteSlaveServerName)) {
    String realRemoteSlaveServerName=environmentSubstitute(remoteSlaveServerName);
    remoteSlaveServer=parentJob.getJobMeta().findSlaveServer(realRemoteSlaveServerName);
    if (remoteSlaveServer == null) {
      throw new KettleException(BaseMessages.getString(PKG,"JobTrans.Exception.UnableToFindRemoteSlaveServer",realRemoteSlaveServerName));
    }
  }
  if (log.isDetailed())   logDetailed(BaseMessages.getString(PKG,"JobTrans.Log.OpeningFile",environmentSubstitute(getFilename())));
  if (!Const.isEmpty(getFilename())) {
    if (log.isDetailed())     logDetailed(BaseMessages.getString(PKG,"JobTrans.Log.OpeningTrans",environmentSubstitute(getFilename())));
  }
 else {
    if (log.isDetailed())     logDetailed(BaseMessages.getString(PKG,"JobTrans.Log.OpeningTransInDirec",environmentSubstitute(getFilename()),environmentSubstitute(directory)));
  }
  TransMeta transMeta=getTransMeta(rep);
  int iteration=0;
  String args1[]=arguments;
  if (args1 == null || args1.length == 0) {
    args1=parentJob.getJobMeta().getArguments();
  }
  String args[]=null;
  if (args1 != null) {
    args=new String[args1.length];
    for (int idx=0; idx < args1.length; idx++) {
      args[idx]=environmentSubstitute(args1[idx]);
    }
  }
  NamedParams namedParam=new NamedParamsDefault();
  if (parameters != null) {
    for (int idx=0; idx < parameters.length; idx++) {
      if (!Const.isEmpty(parameters[idx])) {
        namedParam.addParameterDefinition(parameters[idx],"","Job entry runtime");
        if (Const.isEmpty(Const.trim(parameterFieldNames[idx]))) {
          String value=Const.NVL(environmentSubstitute(parameterValues[idx]),"");
          namedParam.setParameterValue(parameters[idx],value);
        }
 else {
          namedParam.setParameterValue(parameters[idx],"");
        }
      }
    }
  }
  RowMetaAndData resultRow=null;
  boolean first=true;
  List<RowMetaAndData> rows=new ArrayList<RowMetaAndData>(result.getRows());
  while ((first && !execPerRow) || (execPerRow && rows != null && iteration < rows.size() && result.getNrErrors() == 0) && !parentJob.isStopped()) {
    if (execPerRow) {
      result.getRows().clear();
    }
    first=false;
    if (rows != null && execPerRow) {
      resultRow=rows.get(iteration);
    }
 else {
      resultRow=null;
    }
    try {
      if (log.isDetailed())       logDetailed(BaseMessages.getString(PKG,"JobTrans.StartingTrans",getFilename(),getName(),getDescription()));
      transMeta.setPreviousResult(result);
      if (clearResultRows) {
        transMeta.getPreviousResult().setRows(new ArrayList<RowMetaAndData>());
      }
      if (clearResultFiles) {
        transMeta.getPreviousResult().getResultFiles().clear();
      }
      if (execPerRow) {
        if (argFromPrevious) {
          args=null;
          if (resultRow != null) {
            args=new String[resultRow.size()];
            for (int i=0; i < resultRow.size(); i++) {
              args[i]=resultRow.getString(i,null);
            }
          }
        }
 else {
          List<RowMetaAndData> newList=new ArrayList<RowMetaAndData>();
          newList.add(resultRow);
          transMeta.getPreviousResult().getRows().addAll(newList);
        }
        if (paramsFromPrevious) {
          if (parameters != null) {
            for (int idx=0; idx < parameters.length; idx++) {
              if (!Const.isEmpty(parameters[idx])) {
                if (Const.isEmpty(Const.trim(parameterFieldNames[idx]))) {
                  namedParam.setParameterValue(parameters[idx],Const.NVL(environmentSubstitute(parameterValues[idx]),""));
                }
 else {
                  String fieldValue="";
                  if (resultRow != null) {
                    fieldValue=resultRow.getString(parameterFieldNames[idx],"");
                  }
                  namedParam.setParameterValue(parameters[idx],Const.NVL(fieldValue,""));
                }
              }
            }
          }
        }
      }
 else {
        if (argFromPrevious) {
          args=null;
          if (resultRow != null) {
            args=new String[resultRow.size()];
            for (int i=0; i < resultRow.size(); i++) {
              args[i]=resultRow.getString(i,null);
            }
          }
        }
 else {
        }
        if (paramsFromPrevious) {
          if (parameters != null) {
            for (int idx=0; idx < parameters.length; idx++) {
              if (!Const.isEmpty(parameters[idx])) {
                if (Const.isEmpty(Const.trim(parameterFieldNames[idx]))) {
                  namedParam.setParameterValue(parameters[idx],Const.NVL(environmentSubstitute(parameterValues[idx]),""));
                }
 else {
                  String fieldValue="";
                  if (resultRow != null) {
                    fieldValue=resultRow.getString(parameterFieldNames[idx],"");
                  }
                  namedParam.setParameterValue(parameters[idx],Const.NVL(fieldValue,""));
                }
              }
            }
          }
        }
      }
      transMeta.clearParameters();
      String[] parameterNames=transMeta.listParameters();
      for (int idx=0; idx < parameterNames.length; idx++) {
        String thisValue=namedParam.getParameterValue(parameterNames[idx]);
        if (!Const.isEmpty(thisValue)) {
          transMeta.setParameterValue(parameterNames[idx],thisValue);
        }
 else {
          if (isPassingAllParameters()) {
            String parentValue=parentJob.getParameterValue(parameterNames[idx]);
            if (!Const.isEmpty(parentValue)) {
              transMeta.setParameterValue(parameterNames[idx],parentValue);
            }
          }
        }
      }
      if (clustering) {
        TransExecutionConfiguration executionConfiguration=new TransExecutionConfiguration();
        executionConfiguration.setClusterPosting(true);
        executionConfiguration.setClusterPreparing(true);
        executionConfiguration.setClusterStarting(true);
        executionConfiguration.setClusterShowingTransformation(false);
        executionConfiguration.setSafeModeEnabled(false);
        executionConfiguration.setRepository(rep);
        executionConfiguration.setLogLevel(LogWriter.getInstance().getLogLevel());
        executionConfiguration.setVariables(transMeta);
        executionConfiguration.setArgumentStrings(args);
        TransSplitter transSplitter=Trans.executeClustered(transMeta,executionConfiguration);
        long errors=Trans.monitorClusteredTransformation(log,transSplitter,parentJob);
        Result clusterResult=Trans.getClusteredTransformationResult(log,transSplitter,parentJob);
        result.clear();
        result.add(clusterResult);
        result.setNrErrors(result.getNrErrors() + errors);
      }
 else       if (remoteSlaveServer != null) {
        TransExecutionConfiguration transExecutionConfiguration=new TransExecutionConfiguration();
        transExecutionConfiguration.setPreviousResult(transMeta.getPreviousResult().clone());
        transExecutionConfiguration.setArgumentStrings(args);
        transExecutionConfiguration.setVariables(this);
        transExecutionConfiguration.setRemoteServer(remoteSlaveServer);
        transExecutionConfiguration.setLogLevel(LogWriter.getInstance().getLogLevel());
        Trans.sendToSlaveServer(transMeta,transExecutionConfiguration,rep);
        SlaveServerTransStatus transStatus=null;
        while (!parentJob.isStopped() && waitingToFinish) {
          try {
            transStatus=remoteSlaveServer.getTransStatus(transMeta.getName());
            if (!transStatus.isRunning()) {
              Result remoteResult=transStatus.getResult();
              result.clear();
              result.add(remoteResult);
              if (remoteResult.isStopped()) {
                result.setNrErrors(result.getNrErrors() + 1);
              }
              remoteSlaveServer.cleanupTransformation(transMeta.getName());
              break;
            }
          }
 catch (          Exception e1) {
            logError(BaseMessages.getString(PKG,"JobTrans.Error.UnableContactSlaveServer","" + remoteSlaveServer,transMeta.getName()));
            result.setNrErrors(result.getNrErrors() + 1L);
            break;
          }
          try {
            Thread.sleep(2000);
          }
 catch (          InterruptedException e) {
          }
          ;
        }
        if (parentJob.isStopped()) {
          if (transStatus == null || transStatus.isRunning()) {
            remoteSlaveServer.stopTransformation(transMeta.getName());
            remoteSlaveServer.cleanupTransformation(transMeta.getName());
            result.setNrErrors(result.getNrErrors() + 1L);
          }
        }
      }
 else {
        Trans trans=new Trans(transMeta);
        trans.setSocketRepository(parentJob.getSocketRepository());
        if (parentJob.getJobMeta().isBatchIdPassed()) {
          trans.setPassedBatchId(parentJob.getPassedBatchId());
        }
        trans.setParentJob(parentJob);
        trans.setParentVariableSpace(parentJob);
        Job rootJob=parentJob;
        while (rootJob.getParentJob() != null)         rootJob=rootJob.getParentJob();
        trans.setJobStartDate(rootJob.getStartDate());
        trans.setJobEndDate(rootJob.getEndDate());
        try {
          trans.execute(args);
          while (!trans.isFinished() && !parentJob.isStopped() && trans.getErrors() == 0) {
            try {
              Thread.sleep(0,500);
            }
 catch (            InterruptedException e) {
            }
          }
          if (parentJob.isStopped() || trans.getErrors() != 0) {
            trans.stopAll();
            trans.waitUntilFinished();
            result.setNrErrors(1);
          }
          Result newResult=trans.getResult();
          result.clear();
          result.add(newResult);
          result.setRows(newResult.getRows());
          if (setLogfile) {
            ResultFile resultFile=new ResultFile(ResultFile.FILE_TYPE_LOG,KettleVFS.getFileObject(getLogFilename(),this),parentJob.getJobname(),toString());
            result.getResultFiles().put(resultFile.getFile().toString(),resultFile);
          }
        }
 catch (        KettleException e) {
          logError(BaseMessages.getString(PKG,"JobTrans.Error.UnablePrepareExec"),e);
          result.setNrErrors(1);
        }
      }
    }
 catch (    Exception e) {
      logError(BaseMessages.getString(PKG,"JobTrans.ErrorUnableOpenTrans",e.getMessage()));
      logError(Const.getStackTracker(e));
      result.setNrErrors(1);
    }
    iteration++;
  }
  if (setLogfile) {
    if (appender != null) {
      LogWriter.getInstance().removeAppender(appender);
      appender.close();
      ResultFile resultFile=new ResultFile(ResultFile.FILE_TYPE_LOG,appender.getFile(),parentJob.getJobname(),getName());
      result.getResultFiles().put(resultFile.getFile().toString(),resultFile);
    }
    LogWriter.getInstance().setLogLevel(backupLogLevel);
  }
  if (result.getNrErrors() == 0) {
    result.setResult(true);
  }
 else {
    result.setResult(false);
  }
  System.gc();
  return result;
}
