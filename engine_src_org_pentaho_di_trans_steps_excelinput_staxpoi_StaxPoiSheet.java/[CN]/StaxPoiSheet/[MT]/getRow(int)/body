{
  rownr+=1;
  try {
    while (sheetReader.hasNext()) {
      int event=sheetReader.next();
      if (event == XMLStreamConstants.START_ELEMENT && sheetReader.getLocalName().equals("row")) {
        currentRow=Integer.parseInt(sheetReader.getAttributeValue(null,"r"));
        if (currentRow < rownr)         continue;
        if (currentRow > rownr)         throw new KettleException("Going back in stream is not supported yet");
        KCell[] cells=new StaxPoiCell[numCols];
        for (int i=0; i < numCols; i++) {
          while (sheetReader.hasNext()) {
            if (event == XMLStreamConstants.START_ELEMENT && sheetReader.getLocalName().equals("c"))             break;
            event=sheetReader.next();
          }
          String cellType=sheetReader.getAttributeValue(null,"t");
          while (sheetReader.hasNext()) {
            event=sheetReader.next();
            if (event == XMLStreamConstants.START_ELEMENT && sheetReader.getLocalName().equals("v"))             break;
            if (event == XMLStreamConstants.END_ELEMENT && sheetReader.getLocalName().equals("c")) {
              numRows=currentRow;
              return new KCell[]{};
            }
          }
          String content=null;
          if (cellType != null && cellType.equals("s")) {
            int idx=Integer.parseInt(sheetReader.getElementText());
            content=new XSSFRichTextString(sst.getEntryAt(idx)).toString();
          }
 else           content=sheetReader.getElementText();
          cells[i]=new StaxPoiCell(content,currentRow);
        }
        return cells;
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  numRows=currentRow;
  return new KCell[]{};
}
