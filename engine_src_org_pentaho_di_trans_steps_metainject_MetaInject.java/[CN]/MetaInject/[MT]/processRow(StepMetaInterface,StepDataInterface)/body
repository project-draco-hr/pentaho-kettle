{
  meta=(MetaInjectMeta)smi;
  data=(MetaInjectData)sdi;
  data.rowMap=new HashMap<String,List<RowMetaAndData>>();
  for (  String prevStepName : getTransMeta().getPrevStepNames(getStepMeta())) {
    if (!data.streaming || !prevStepName.equalsIgnoreCase(data.streamingSourceStepname)) {
      List<RowMetaAndData> list=new ArrayList<RowMetaAndData>();
      RowSet rowSet=findInputRowSet(prevStepName);
      Object[] row=getRowFrom(rowSet);
      while (row != null) {
        RowMetaAndData rd=new RowMetaAndData();
        rd.setRowMeta(rowSet.getRowMeta());
        rd.setData(row);
        list.add(rd);
        row=getRowFrom(rowSet);
      }
      if (!list.isEmpty()) {
        data.rowMap.put(prevStepName,list);
      }
    }
  }
  for (  String targetStep : data.stepInjectionMap.keySet()) {
    if (log.isDetailed()) {
      logDetailed("Handing step '" + targetStep + "' injection!");
    }
    StepMetaInjectionInterface injectionInterface=data.stepInjectionMap.get(targetStep);
    List<StepInjectionMetaEntry> metadataEntries=injectionInterface.getStepInjectionMetadataEntries();
    List<StepInjectionMetaEntry> inject=new ArrayList<StepInjectionMetaEntry>();
    Map<TargetStepAttribute,SourceStepField> targetMap=meta.getTargetSourceMapping();
    for (    TargetStepAttribute target : targetMap.keySet()) {
      SourceStepField source=targetMap.get(target);
      if (target.getStepname().equalsIgnoreCase(targetStep)) {
        List<RowMetaAndData> rows=data.rowMap.get(source.getStepname());
        if (rows != null && rows.size() > 0) {
          StepInjectionMetaEntry entry=findMetaEntry(metadataEntries,target.getAttributeKey());
          if (entry != null) {
            if (!target.isDetail()) {
              setEntryValueIfFieldExists(entry,rows.get(0),source);
              inject.add(entry);
            }
 else {
              StepInjectionMetaEntry metaEntries=findMetaEntry(inject,entry.getKey());
              if (metaEntries == null) {
                StepInjectionMetaEntry rootEntry=findDetailRootEntry(metadataEntries,entry);
                metaEntries=rootEntry.clone();
                metaEntries.setDetails(new ArrayList<StepInjectionMetaEntry>());
                inject.add(metaEntries);
                StepInjectionMetaEntry metaEntry=rootEntry.getDetails().get(0);
                for (int i=0; i < rows.size(); i++) {
                  StepInjectionMetaEntry metaCopy=metaEntry.clone();
                  metaEntries.getDetails().add(metaCopy);
                  metaCopy.setDetails(new ArrayList<StepInjectionMetaEntry>());
                  for (                  StepInjectionMetaEntry me : metaEntry.getDetails()) {
                    StepInjectionMetaEntry meCopy=me.clone();
                    metaCopy.getDetails().add(meCopy);
                  }
                }
              }
 else {
                StepInjectionMetaEntry rootEntry=findDetailRootEntry(inject,metaEntries);
                metaEntries=rootEntry;
              }
              for (int i=0; i < rows.size(); i++) {
                RowMetaAndData row=rows.get(i);
                try {
                  List<StepInjectionMetaEntry> rowEntries=metaEntries.getDetails().get(i).getDetails();
                  for (                  StepInjectionMetaEntry rowEntry : rowEntries) {
                    SourceStepField detailSource=findDetailSource(targetMap,targetStep,rowEntry.getKey());
                    if (detailSource != null) {
                      setEntryValueIfFieldExists(rowEntry,row,detailSource);
                    }
 else {
                      if (log.isDetailed()) {
                        logDetailed("No detail source found for key: " + rowEntry.getKey() + " and target step: "+ targetStep);
                      }
                    }
                  }
                }
 catch (                Exception e) {
                  throw new KettleException("Unexpected error occurred while injecting metadata",e);
                }
              }
              if (log.isDetailed()) {
                logDetailed("injected entry: " + entry);
              }
            }
          }
 else {
            if (log.isDetailed()) {
              logDetailed("entry not found: " + target.getAttributeKey());
            }
          }
        }
 else {
          if (log.isDetailed()) {
            logDetailed("No rows found for source step: " + source.getStepname());
          }
        }
      }
    }
    injectionInterface.injectStepMetadataEntries(inject);
  }
  if (log.isDetailed()) {
    logDetailed("XML of transformation after injection: " + data.transMeta.getXML());
  }
  String targetFile=environmentSubstitute(meta.getTargetFile());
  if (!Const.isEmpty(targetFile)) {
    OutputStream os=null;
    try {
      os=KettleVFS.getOutputStream(targetFile,false);
      os.write(XMLHandler.getXMLHeader().getBytes(Const.XML_ENCODING));
      os.write(data.transMeta.getXML().getBytes(Const.XML_ENCODING));
    }
 catch (    IOException e) {
      throw new KettleException("Unable to write target file (ktr after injection) to file '" + targetFile + "'",e);
    }
 finally {
      if (os != null) {
        try {
          os.close();
        }
 catch (        Exception e) {
          throw new KettleException(e);
        }
      }
    }
  }
  if (!meta.isNoExecution()) {
    final Trans injectTrans=new Trans(data.transMeta,this);
    if (getTrans().getParentJob() != null) {
      injectTrans.setParentJob(getTrans().getParentJob());
    }
    getTrans().addTransStoppedListener(new TransStoppedListener(){
      public void transStopped(      Trans parentTrans){
        injectTrans.stopAll();
      }
    }
);
    injectTrans.prepareExecution(null);
    RowProducer rowProducer=null;
    if (data.streaming) {
      rowProducer=injectTrans.addRowProducer(data.streamingTargetStepname,0);
    }
    getTrans().getActiveSubtransformations().put(getStepname(),injectTrans);
    if (!Const.isEmpty(meta.getSourceStepName())) {
      StepInterface stepInterface=injectTrans.getStepInterface(meta.getSourceStepName(),0);
      if (stepInterface == null) {
        throw new KettleException("Unable to find step '" + meta.getSourceStepName() + "' to read from.");
      }
      stepInterface.addRowListener(new RowAdapter(){
        @Override public void rowWrittenEvent(        RowMetaInterface rowMeta,        Object[] row) throws KettleStepException {
          MetaInject.this.putRow(rowMeta,row);
        }
      }
);
    }
    injectTrans.startThreads();
    if (data.streaming) {
      RowSet rowSet=findInputRowSet(data.streamingSourceStepname);
      if (rowSet == null) {
        throw new KettleException("Unable to find step '" + data.streamingSourceStepname + "' to stream data from");
      }
      Object[] row=getRowFrom(rowSet);
      while (row != null && !isStopped()) {
        rowProducer.putRow(rowSet.getRowMeta(),row);
        row=getRowFrom(rowSet);
      }
      rowProducer.finished();
    }
    while (!injectTrans.isFinished() && !injectTrans.isStopped() && !isStopped()) {
      copyResult(injectTrans);
      try {
        Thread.sleep(50);
      }
 catch (      Exception e) {
      }
    }
    copyResult(injectTrans);
  }
  setOutputDone();
  return false;
}
