{
  meta=(MetaInjectMeta)smi;
  data=(MetaInjectData)sdi;
  data.rowMap=new HashMap<String,List<RowMetaAndData>>();
  for (  String prevStepName : getTransMeta().getPrevStepNames(getStepMeta())) {
    if (!data.streaming || !prevStepName.equalsIgnoreCase(data.streamingSourceStepname)) {
      List<RowMetaAndData> list=new ArrayList<RowMetaAndData>();
      RowSet rowSet=findInputRowSet(prevStepName);
      Object[] row=getRowFrom(rowSet);
      while (row != null) {
        RowMetaAndData rd=new RowMetaAndData();
        rd.setRowMeta(rowSet.getRowMeta());
        rd.setData(row);
        list.add(rd);
        row=getRowFrom(rowSet);
      }
      if (!list.isEmpty()) {
        data.rowMap.put(prevStepName,list);
      }
    }
  }
  for (  Map.Entry<String,StepMetaInterface> en : data.stepInjectionMetasMap.entrySet()) {
    newInjection(en.getKey(),en.getValue());
  }
  for (  String targetStep : data.stepInjectionMap.keySet()) {
    if (!data.stepInjectionMetasMap.containsKey(targetStep)) {
      oldInjection(targetStep);
    }
  }
  if (log.isDetailed()) {
    logDetailed("XML of transformation after injection: " + data.transMeta.getXML());
  }
  String targetFile=environmentSubstitute(meta.getTargetFile());
  if (!Const.isEmpty(targetFile)) {
    OutputStream os=null;
    try {
      os=KettleVFS.getOutputStream(targetFile,false);
      os.write(XMLHandler.getXMLHeader().getBytes(Const.XML_ENCODING));
      os.write(data.transMeta.getXML().getBytes(Const.XML_ENCODING));
    }
 catch (    IOException e) {
      throw new KettleException("Unable to write target file (ktr after injection) to file '" + targetFile + "'",e);
    }
 finally {
      if (os != null) {
        try {
          os.close();
        }
 catch (        Exception e) {
          throw new KettleException(e);
        }
      }
    }
  }
  if (!meta.isNoExecution()) {
    final Trans injectTrans=new Trans(data.transMeta,this);
    if (getTrans().getParentJob() != null) {
      injectTrans.setParentJob(getTrans().getParentJob());
    }
    getTrans().addTransStoppedListener(new TransStoppedListener(){
      public void transStopped(      Trans parentTrans){
        injectTrans.stopAll();
      }
    }
);
    injectTrans.prepareExecution(null);
    RowProducer rowProducer=null;
    if (data.streaming) {
      rowProducer=injectTrans.addRowProducer(data.streamingTargetStepname,0);
    }
    getTrans().getActiveSubtransformations().put(getStepname(),injectTrans);
    if (!Const.isEmpty(meta.getSourceStepName())) {
      StepInterface stepInterface=injectTrans.getStepInterface(meta.getSourceStepName(),0);
      if (stepInterface == null) {
        throw new KettleException("Unable to find step '" + meta.getSourceStepName() + "' to read from.");
      }
      stepInterface.addRowListener(new RowAdapter(){
        @Override public void rowWrittenEvent(        RowMetaInterface rowMeta,        Object[] row) throws KettleStepException {
          MetaInject.this.putRow(rowMeta,row);
        }
      }
);
    }
    injectTrans.startThreads();
    if (data.streaming) {
      RowSet rowSet=findInputRowSet(data.streamingSourceStepname);
      if (rowSet == null) {
        throw new KettleException("Unable to find step '" + data.streamingSourceStepname + "' to stream data from");
      }
      Object[] row=getRowFrom(rowSet);
      while (row != null && !isStopped()) {
        rowProducer.putRow(rowSet.getRowMeta(),row);
        row=getRowFrom(rowSet);
      }
      rowProducer.finished();
    }
    while (!injectTrans.isFinished() && !injectTrans.isStopped() && !isStopped()) {
      copyResult(injectTrans);
      try {
        Thread.sleep(50);
      }
 catch (      Exception e) {
      }
    }
    copyResult(injectTrans);
  }
  setOutputDone();
  return false;
}
