{
  RowSet rs;
  int nroutput;
  int nrcopies;
  int prevcopies;
  int nextcopies;
  startDate=null;
  transMeta.setArguments(arguments);
  if (transMeta.isLogfieldUsed()) {
    log.startStringCapture();
    log.setString("START" + Const.CR);
  }
  if (transMeta.getName() == null) {
    log.logBasic(toString(),"Dispatching started for filename [" + transMeta.getFilename() + "]");
  }
 else {
    log.logBasic(toString(),"Dispatching started for transformation [" + transMeta.getName() + "]");
  }
  if (transMeta.getArguments() != null) {
    log.logBasic(toString(),"Nr of arguments detected: " + transMeta.getArguments().length);
  }
  if (getReplayDate() != null) {
    log.logBasic(toString(),"This is a replay transformation for : " + getReplayDate());
  }
 else {
    log.logBasic(toString(),"This is not a replay transformation");
  }
  steps=new ArrayList();
  rowsets=new ArrayList();
  if (isMonitored()) {
    transMeta.sortStepsNatural();
    transMeta.sortHopsNatural();
  }
  ArrayList hopsteps=transMeta.getTransHopSteps(false);
  log.logDetailed(toString(),"I found " + hopsteps.size() + " different steps to launch.");
  log.logDetailed(toString(),"Allocating rowsets...");
  for (int i=0; i < hopsteps.size(); i++) {
    StepMeta stepMeta=(StepMeta)hopsteps.get(i);
    log.logDetailed(toString()," Allocating rowsets for step " + i + " --> "+ stepMeta.getName());
    nroutput=transMeta.findNrNextSteps(stepMeta);
    for (int n=0; n < nroutput; n++) {
      StepMeta nsi=transMeta.findNextStep(stepMeta,n);
      nextcopies=nsi.getCopies();
      prevcopies=stepMeta.getCopies();
      log.logDetailed(toString(),"  prevcopies = " + prevcopies + ", nextcopies="+ nextcopies);
      int disptype;
      if (prevcopies == 1 && nextcopies == 1) {
        disptype=TYPE_DISP_1_1;
        nrcopies=1;
      }
 else       if (prevcopies == 1 && nextcopies > 1) {
        disptype=TYPE_DISP_1_N;
        nrcopies=nextcopies;
      }
 else       if (prevcopies > 1 && nextcopies == 1) {
        disptype=TYPE_DISP_N_1;
        nrcopies=prevcopies;
      }
 else       if (prevcopies == nextcopies) {
        disptype=TYPE_DISP_N_N;
        nrcopies=nextcopies;
      }
 else {
        log.logError(toString(),"Only 1-1, 1-n, n-1 and n-n relationships are allowed!");
        log.logError(toString(),"This means you can't have x-y relationships!");
        return false;
      }
      for (int c=0; c < nrcopies; c++) {
        rs=new RowSet(transMeta.getSizeRowset());
switch (disptype) {
case TYPE_DISP_1_1:
          rs.setThreadNameFromToCopy(stepMeta.getName(),0,nsi.getName(),0);
        break;
case TYPE_DISP_1_N:
      rs.setThreadNameFromToCopy(stepMeta.getName(),0,nsi.getName(),c);
    break;
case TYPE_DISP_N_1:
  rs.setThreadNameFromToCopy(stepMeta.getName(),c,nsi.getName(),0);
break;
case TYPE_DISP_N_N:
rs.setThreadNameFromToCopy(stepMeta.getName(),c,nsi.getName(),c);
break;
}
rowsets.add(rs);
log.logDetailed(toString(),"Transformation allocated new rowset [" + rs.toString() + "]");
}
}
log.logDetailed(toString()," Allocated " + rowsets.size() + " rowsets for step "+ i+ " --> "+ stepMeta.getName()+ " ");
}
log.logDetailed(toString(),"Allocating Steps & StepData...");
for (int i=0; i < hopsteps.size(); i++) {
StepMeta stepMeta=(StepMeta)hopsteps.get(i);
String stepid=stepMeta.getStepID();
log.logDetailed(toString()," Transformation is about to allocate step [" + stepMeta.getName() + "] of type ["+ stepid+ "]");
nrcopies=stepMeta.getCopies();
log.logDebug(toString(),"  Step has nrcopies=" + nrcopies);
for (int c=0; c < nrcopies; c++) {
if (!hasStepStarted(stepMeta.getName(),c)) {
StepMetaDataCombi combi=new StepMetaDataCombi();
combi.stepname=stepMeta.getName();
combi.copy=c;
combi.meta=stepMeta.getStepMetaInterface();
StepDataInterface data=combi.meta.getStepData();
combi.data=data;
StepInterface step=combi.meta.getStep(stepMeta,data,c,transMeta,this);
combi.step=step;
steps.add(combi);
log.logDetailed(toString()," Transformation has allocated a new step: [" + stepMeta.getName() + "]."+ c);
}
}
}
setThreadsOnRowSets();
try {
beginProcessing();
}
 catch (KettleTransException kte) {
log.logError(toString(),kte.getMessage());
return false;
}
if (preview && preview_steps != null) {
for (int i=0; i < steps.size(); i++) {
StepMetaDataCombi sid=(StepMetaDataCombi)steps.get(i);
BaseStep rt=(BaseStep)sid.step;
for (int x=0; x < preview_steps.length; x++) {
if (preview_steps[x].equalsIgnoreCase(rt.getStepname()) && rt.getCopy() == 0) {
rt.previewSize=preview_sizes[x];
rt.previewBuffer=new ArrayList();
}
}
}
}
boolean ok=true;
for (int i=0; i < steps.size(); i++) {
StepMetaDataCombi sid=(StepMetaDataCombi)steps.get(i);
if (sid.step.init(sid.meta,sid.data)) {
sid.data.setStatus(StepDataInterface.STATUS_IDLE);
}
 else {
sid.step.setErrors(1);
log.logError(toString(),"Error initializing step [" + sid.step.getStepname() + "]");
ok=false;
}
}
if (!ok) {
log.logError(toString(),"We failed to initialize at least one step.  Execution can not begin!");
return false;
}
return true;
}
