{
  LogWriter log=LogWriter.getInstance();
  Result result=previousResult;
  result.setResult(false);
  result.setNrErrors(1);
  String realCustomSQL=null;
  String realTablename=environmentSubstitute(tablename);
  String realSchemaname=environmentSubstitute(schemaname);
  if (connection == null) {
    log.logError(toString(),Messages.getString("JobEntryWaitForSQLTables.NoDbConnection"));
    return result;
  }
  if (iscustomSQL) {
    if (isClearResultList)     result.getRows().clear();
    realCustomSQL=customSQL;
    if (isUseVars)     realCustomSQL=environmentSubstitute(realCustomSQL);
    if (log.isDebug())     log.logDebug(toString(),Messages.getString("JobEntryWaitForSQL.Log.EnteredCustomSQL",realCustomSQL));
    if (Const.isEmpty(realCustomSQL)) {
      log.logError(toString(),Messages.getString("JobEntryWaitForSQL.Error.NoCustomSQL"));
      return result;
    }
  }
 else {
    if (Const.isEmpty(realTablename)) {
      log.logError(toString(),Messages.getString("JobEntryWaitForSQL.Error.NoTableName"));
      return result;
    }
  }
  try {
    Database dbchecked=null;
    try {
      dbchecked=new Database(connection);
      dbchecked.connect();
    }
  finally {
      if (dbchecked != null)       dbchecked.disconnect();
    }
    long timeStart=System.currentTimeMillis() / 1000;
    int nrRowsLimit=Const.toInt(environmentSubstitute(rowsCountValue),0);
    if (log.isDetailed())     log.logDetailed(toString(),Messages.getString("JobEntryWaitForSQL.Log.nrRowsLimit","" + nrRowsLimit));
    long iMaximumTimeout=Const.toInt(environmentSubstitute(maximumTimeout),Const.toInt(DEFAULT_MAXIMUM_TIMEOUT,0));
    long iCycleTime=Const.toInt(environmentSubstitute(checkCycleTime),Const.toInt(DEFAULT_CHECK_CYCLE_TIME,0));
    if (iMaximumTimeout < 0) {
      iMaximumTimeout=Const.toInt(DEFAULT_MAXIMUM_TIMEOUT,0);
      log.logBasic(toString(),"Maximum timeout invalid, reset to " + iMaximumTimeout);
    }
    if (iCycleTime < 1) {
      iCycleTime=Const.toInt(DEFAULT_CHECK_CYCLE_TIME,1);
      log.logBasic(toString(),"Check cycle time invalid, reset to " + iCycleTime);
    }
    if (iMaximumTimeout == 0) {
      log.logBasic(toString(),"Waiting indefinitely for SQL data");
    }
 else {
      log.logBasic(toString(),"Waiting " + iMaximumTimeout + " seconds for SQL data");
    }
    boolean continueLoop=true;
    while (continueLoop && !parentJob.isStopped()) {
      if (SQLDataOK(log,result,nrRowsLimit,realSchemaname,realTablename,realCustomSQL)) {
        log.logBasic(toString(),"Detected SQL data within timeout");
        result.setResult(true);
        continueLoop=false;
      }
 else {
        long now=System.currentTimeMillis() / 1000;
        if ((iMaximumTimeout > 0) && (now > (timeStart + iMaximumTimeout))) {
          continueLoop=false;
          if (isSuccessOnTimeout()) {
            log.logBasic(toString(),"Didn't detect SQL data before timeout, success");
            result.setResult(true);
          }
 else {
            log.logBasic(toString(),"Didn't detect SQL data before timeout, failure");
            result.setResult(false);
          }
        }
        long sleepTime=0;
        if (iMaximumTimeout == 0) {
          sleepTime=iCycleTime;
        }
 else {
          if ((now + iCycleTime) < (timeStart + iMaximumTimeout)) {
            sleepTime=iCycleTime;
          }
 else {
            sleepTime=iCycleTime - ((now + iCycleTime) - (timeStart + iMaximumTimeout));
          }
        }
        try {
          if (sleepTime > 0) {
            if (log.isDetailed()) {
              log.logDetailed(toString(),"Sleeping " + sleepTime + " seconds before next check for SQL data");
            }
            Thread.sleep(sleepTime * 1000);
          }
        }
 catch (        InterruptedException e) {
          result.setResult(false);
          continueLoop=false;
        }
      }
    }
  }
 catch (  Exception e) {
    log.logBasic(toString(),"Exception while waiting for SQL data: " + e.getMessage());
  }
  return result;
}
