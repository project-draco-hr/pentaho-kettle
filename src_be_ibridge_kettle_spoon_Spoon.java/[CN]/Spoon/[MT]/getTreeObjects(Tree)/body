{
  List objects=new ArrayList();
  if (tree.equals(selectionTree)) {
    TreeItem[] selection=selectionTree.getSelection();
    for (int s=0; s < selection.length; s++) {
      TreeItem treeItem=selection[s];
      String[] path=Const.getTreeStrings(treeItem);
      TreeSelection object=null;
switch (path.length) {
case 0:
        break;
case 1:
      if (path[0].equals(STRING_TRANSFORMATIONS)) {
        object=new TreeSelection(TransMeta.class);
      }
    break;
case 2:
  if (path[0].equals(STRING_BUILDING_BLOCKS)) {
    if (path[1].equals(STRING_BASE) || path[1].equals(STRING_PLUGIN)) {
      object=new TreeSelection(StepPlugin.class);
    }
  }
if (path[0].equals(STRING_TRANSFORMATIONS)) {
  object=new TreeSelection(findTransformation(path[1]));
}
break;
case 3:
if (path[0].equals(STRING_TRANSFORMATIONS)) {
TransMeta transMeta=findTransformation(path[1]);
if (path[2].equals(STRING_CONNECTIONS)) object=new TreeSelection(DatabaseMeta.class,transMeta);
if (path[2].equals(STRING_STEPS)) object=new TreeSelection(StepMeta.class,transMeta);
if (path[2].equals(STRING_HOPS)) object=new TreeSelection(TransHopMeta.class,transMeta);
if (path[2].equals(STRING_PARTITIONS)) object=new TreeSelection(PartitionSchema.class,transMeta);
if (path[2].equals(STRING_SLAVES)) object=new TreeSelection(SlaveServer.class,transMeta);
if (path[2].equals(STRING_CLUSTERS)) object=new TreeSelection(ClusterSchema.class,transMeta);
}
break;
case 4:
if (path[0].equals(STRING_TRANSFORMATIONS)) {
TransMeta transMeta=findTransformation(path[1]);
if (path[2].equals(STRING_CONNECTIONS)) object=new TreeSelection(transMeta.findDatabase(path[3]),transMeta);
if (path[2].equals(STRING_STEPS)) object=new TreeSelection(transMeta.findStep(path[3]),transMeta);
if (path[2].equals(STRING_HOPS)) object=new TreeSelection(transMeta.findTransHop(path[3]),transMeta);
if (path[2].equals(STRING_PARTITIONS)) object=new TreeSelection(transMeta.findPartitionSchema(path[3]),transMeta);
if (path[2].equals(STRING_SLAVES)) object=new TreeSelection(transMeta.findSlaveServer(path[3]),transMeta);
if (path[2].equals(STRING_CLUSTERS)) object=new TreeSelection(transMeta.findClusterSchema(path[3]),transMeta);
}
if (path[0].equals(STRING_BUILDING_BLOCKS)) {
if (path[1].equals(STRING_BASE) || path[1].equals(STRING_PLUGIN)) {
object=new TreeSelection(StepLoader.getInstance().findStepPluginWithDescription(path[3]));
}
}
break;
case 5:
if (path[0].equals(STRING_TRANSFORMATIONS)) {
TransMeta transMeta=findTransformation(path[1]);
if (path[2].equals(STRING_CLUSTERS)) {
ClusterSchema clusterSchema=transMeta.findClusterSchema(path[3]);
object=new TreeSelection(clusterSchema.findSlaveServer(path[4]),clusterSchema,transMeta);
}
}
break;
default :
break;
}
if (object != null) {
objects.add(object);
}
}
}
if (tree.equals(pluginHistoryTree)) {
TreeItem[] selection=pluginHistoryTree.getSelection();
for (int s=0; s < selection.length; s++) {
TreeItem treeItem=selection[s];
String[] path=Const.getTreeStrings(treeItem);
TreeSelection object=null;
switch (path.length) {
case 0:
break;
case 1:
break;
case 2:
if (path[0].equals(STRING_HISTORY)) {
StepPlugin stepPlugin=StepLoader.getInstance().findStepPluginWithDescription(path[1]);
if (stepPlugin != null) {
object=new TreeSelection(stepPlugin);
}
}
break;
default :
break;
}
if (object != null) {
objects.add(object);
}
}
}
return (TreeSelection[])objects.toArray(new TreeSelection[objects.size()]);
}
