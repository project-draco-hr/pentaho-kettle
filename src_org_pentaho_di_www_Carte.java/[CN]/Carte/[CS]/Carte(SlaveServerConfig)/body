{
  this.config=config;
  this.log=new LogChannel("Carte");
  boolean allOK=true;
  final TransformationMap transformationMap=new TransformationMap();
  final JobMap jobMap=new JobMap();
  List<SlaveServerDetection> detections=Collections.synchronizedList(new ArrayList<SlaveServerDetection>());
  SocketRepository socketRepository=new SocketRepository(log);
  Trans trans=generateTestTransformation();
  transformationMap.addTransformation(trans.getName(),trans,new TransConfiguration(trans.getTransMeta(),new TransExecutionConfiguration()));
  SlaveServer slaveServer=config.getSlaveServer();
  String hostname=slaveServer.getHostname();
  int port=WebServer.PORT;
  if (!Const.isEmpty(slaveServer.getPort())) {
    try {
      port=Integer.parseInt(slaveServer.getPort());
    }
 catch (    Exception e) {
      log.logError(BaseMessages.getString(PKG,"Carte.Error.CanNotPartPort",slaveServer.getHostname(),"" + port),e);
      allOK=false;
    }
  }
  if (config.isReportingToMasters()) {
    final SlaveServer client=new SlaveServer("Dynamic slave [" + hostname + ":"+ port+ "]",hostname,"" + port,slaveServer.getUsername(),slaveServer.getPassword());
    for (    final SlaveServer master : config.getMasters()) {
      try {
        SlaveServerDetection slaveServerDetection=new SlaveServerDetection(client);
        master.sendXML(slaveServerDetection.getXML(),RegisterSlaveServlet.CONTEXT_PATH + "/");
        log.logBasic("Registered this slave server to master slave server [" + master.toString() + "] on address ["+ master.getServerAndPort()+ "]");
      }
 catch (      Exception e) {
        log.logError("Unable to register to master slave server [" + master.toString() + "] on address ["+ master.getServerAndPort()+ "]");
        allOK=false;
      }
    }
  }
  if (config.getObjectTimeoutMinutes() > 0) {
    log.logBasic("Installing timer to purge stale objects after " + config.getObjectTimeoutMinutes() + " minutes.");
    Timer timer=new Timer();
    final AtomicBoolean busy=new AtomicBoolean(false);
    TimerTask timerTask=new TimerTask(){
      public void run(){
        if (!busy.get()) {
          busy.set(true);
          try {
            for (            CarteObjectEntry entry : transformationMap.getTransformationObjects()) {
              Trans trans=transformationMap.getTransformation(entry);
              if (trans != null && (trans.isFinished() || trans.isStopped()) && trans.getLogDate() != null) {
                int diffInMinutes=(int)Math.floor((System.currentTimeMillis() - trans.getLogDate().getTime()) / 60000);
                if (diffInMinutes >= config.getObjectTimeoutMinutes()) {
                  transformationMap.removeTransformation(entry);
                  transformationMap.deallocateServerSocketPorts(entry);
                }
              }
            }
            for (            CarteObjectEntry entry : jobMap.getJobObjects()) {
              Job job=jobMap.getJob(entry);
              if (job != null && (job.isFinished() || job.isStopped()) && job.getLogDate() != null) {
                int diffInMinutes=(int)Math.floor((System.currentTimeMillis() - job.getLogDate().getTime()) / 60000);
                if (diffInMinutes >= config.getObjectTimeoutMinutes()) {
                  jobMap.removeJob(entry);
                }
              }
            }
          }
  finally {
            busy.set(false);
          }
        }
      }
    }
;
    timer.schedule(timerTask,60000,60000);
  }
  if (allOK) {
    this.webServer=new WebServer(log,transformationMap,jobMap,socketRepository,detections,hostname,port,config.isJoining());
  }
}
