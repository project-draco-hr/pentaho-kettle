{
  Row lu=new Row();
  Row add;
  Value technicalKey;
  Value val_version;
  Value val_date=null;
  Value val_datfrom=null;
  Value val_datto=null;
  debug="Start of lookupValues()";
  if (first) {
    debug="init of lookupValues()";
    first=false;
    if (getCopy() == 0)     data.db.checkDimZero(meta.getTableName(),meta.getKeyField(),meta.getVersionField(),meta.isAutoIncrement());
    debug="first: setDimLookup()";
    data.db.setDimLookup(meta.getTableName(),meta.getKeyLookup(),meta.getKeyField(),meta.getVersionField(),meta.getFieldLookup(),meta.getFieldStream(),meta.getDateFrom(),meta.getDateTo());
    debug="first: lookup key nrs";
    data.keynrs=new int[meta.getKeyStream().length];
    for (int i=0; i < meta.getKeyStream().length; i++) {
      data.keynrs[i]=row.searchValueIndex(meta.getKeyStream()[i]);
      if (data.keynrs[i] < 0) {
        throw new KettleStepException("Key field [" + meta.getKeyStream()[i] + "] couldn't be found!");
      }
    }
    debug="first: lookup value nrs";
    if (meta.isUpdate()) {
      data.fieldnrs=new int[meta.getFieldStream().length];
      for (int i=0; meta.getFieldStream() != null && i < meta.getFieldStream().length; i++) {
        data.fieldnrs[i]=row.searchValueIndex(meta.getFieldStream()[i]);
      }
    }
    if (meta.getDateField() != null && meta.getDateField().length() > 0) {
      data.datefieldnr=row.searchValueIndex(meta.getDateField());
    }
 else {
      data.datefieldnr=-1;
    }
    debug="first: notfound field";
    meta.setNotFound(new Value(meta.getKeyField(),(double)meta.getDatabaseMeta().getNotFoundTK(meta.isAutoIncrement())));
    if (meta.getKeyRename() != null && meta.getKeyRename().length() > 0)     meta.getNotFound().setName(meta.getKeyRename());
    if (meta.getDateField() != null && data.datefieldnr >= 0) {
      data.val_datnow=row.getValue(data.datefieldnr);
    }
 else {
      Calendar cal=Calendar.getInstance();
      data.val_datnow=new Value("MIN",new Date(cal.getTimeInMillis()));
    }
    debug="first: end";
  }
  if (meta.getDateField() != null && data.datefieldnr >= 0) {
    data.val_datnow=row.getValue(data.datefieldnr);
  }
  for (int i=0; i < meta.getKeyStream().length; i++) {
    try {
      lu.addValue(row.getValue(data.keynrs[i]));
    }
 catch (    Exception e) {
      throw new KettleStepException("Error detected getting key #" + i + ", pos="+ data.keynrs[i]+ "/"+ row.size()+ " from row: "+ row.toString());
    }
  }
  if (data.datefieldnr >= 0)   val_date=row.getValue(data.datefieldnr);
 else   val_date=data.val_datnow;
  logDebug("lookup row : " + lu.toString() + " val_date="+ val_date.toString());
  debug="setDimValues()";
  data.db.setDimValues(lu,val_date);
  debug="getLookup()";
  add=data.db.getLookup();
  if (!meta.isUpdate()) {
    debug="lookup";
    if (add == null) {
      debug="lookup: nothing found";
      add=new Row();
      add.addValue(meta.getNotFound());
      Value v;
      for (int i=0; i < meta.getFieldStream().length; i++) {
        debug="lookup: fieldstream #" + i;
        if (meta.getFieldStream()[i] != null) {
          debug="lookup: new value #" + i;
          if (meta.getFieldStream()[i] != null)           v=new Value(meta.getFieldStream()[i],meta.getFieldUpdate()[i]);
 else           v=new Value(meta.getFieldLookup()[i],meta.getFieldUpdate()[i]);
          v.setNull();
          add.addValue(v);
        }
      }
    }
 else {
      add.removeValue(1);
      if (meta.getKeyRename() != null && meta.getKeyRename().length() > 0)       add.getValue(0).setName(meta.getKeyRename());
    }
  }
 else {
    if (add == null) {
      debug="insert";
      logRowlevel("No dimension entry found: INSERT (lookup= " + lu + ")");
      val_datfrom=new Value("MIN",meta.getMinDate());
      val_datto=new Value("MAX",meta.getMaxDate());
      val_version=new Value(meta.getVersionField(),1L);
      boolean autoinc=false;
      if (meta.getDatabaseMeta().supportsAutoinc() && meta.isAutoIncrement()) {
        autoinc=true;
        technicalKey=new Value(meta.getKeyField(),0L);
      }
 else       if (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName() != null && meta.getSequenceName().length() > 0) {
        technicalKey=data.db.getNextSequenceValue(meta.getSequenceName(),meta.getKeyField());
        if (technicalKey != null)         logRowlevel("Found next sequence value: " + technicalKey.toString());
      }
 else {
        technicalKey=new Value(meta.getKeyField(),0L);
        data.db.getNextValue(getTransMeta().getCounters(),meta.getTableName(),technicalKey);
      }
      debug="insert row";
      data.db.dimInsert(row,meta.getTableName(),true,autoinc ? null : meta.getKeyField(),autoinc,technicalKey,meta.getVersionField(),val_version,meta.getDateFrom(),val_datfrom,meta.getDateTo(),val_datto,meta.getFieldLookup(),data.fieldnrs,meta.getKeyStream(),meta.getKeyLookup(),data.keynrs);
      linesOutput++;
      add=new Row();
      if (meta.getKeyRename() != null && meta.getKeyRename().length() > 0)       technicalKey.setName(meta.getKeyRename());
      add.addValue(technicalKey);
      logRowlevel("added dimension entry with key=" + add.toString());
    }
 else {
      logRowlevel("Dimension entry found : " + add);
      debug="update";
      technicalKey=add.getValue(0);
      val_version=add.getValue(1);
      val_datfrom=new Value("MIN",meta.getMinDate());
      val_datto=new Value("MAX",meta.getMaxDate());
      int cmp;
      boolean insert=false;
      boolean identical=true;
      boolean punch=false;
      Value v1, v2;
      for (int i=0; i < meta.getFieldStream().length; i++) {
        v1=row.getValue(data.fieldnrs[i]);
        v2=add.getValue(i + 2);
        cmp=v1.compare(v2);
        if (cmp != 0)         identical=false;
        if (cmp != 0 && meta.getFieldUpdate()[i] == DimensionLookupMeta.TYPE_UPDATE_DIM_INSERT) {
          insert=true;
        }
        if (cmp != 0 && meta.getFieldUpdate()[i] == DimensionLookupMeta.TYPE_UPDATE_DIM_PUNCHTHROUGH) {
          punch=true;
        }
        logRowlevel("Comparing " + v1 + " and "+ v2+ " (cmp="+ cmp+ ") --> identical="+ identical+ ", insert="+ insert+ ", punch="+ punch);
      }
      if (!insert) {
        if (!identical) {
          logRowlevel("UPDATE row with values: " + row);
          debug="update row";
          data.db.dimUpdate(row,meta.getTableName(),meta.getFieldLookup(),data.fieldnrs,meta.getKeyField(),technicalKey);
          linesUpdated++;
        }
 else {
          logRowlevel("SKIP line: identical!");
          linesSkipped++;
        }
      }
 else {
        logRowlevel("INSERT new version: val_key=" + technicalKey.toString());
        val_datfrom=data.val_datnow;
        val_datto=new Value("MAX",meta.getMaxDate());
        boolean autoinc=false;
        if (meta.getDatabaseMeta().supportsAutoinc() && meta.isAutoIncrement()) {
          autoinc=true;
          technicalKey=new Value(meta.getKeyField(),0.0);
        }
 else         if (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName() != null && meta.getSequenceName().length() > 0) {
          technicalKey=data.db.getNextSequenceValue(meta.getSequenceName(),meta.getKeyField());
          if (technicalKey != null)           logRowlevel("Found next sequence value: " + technicalKey.toString());
        }
 else {
          technicalKey=new Value(meta.getKeyField(),0L);
          data.db.getNextValue(getTransMeta().getCounters(),meta.getTableName(),technicalKey);
        }
        data.db.dimInsert(row,meta.getTableName(),false,meta.getKeyField(),autoinc,technicalKey,meta.getVersionField(),val_version,meta.getDateFrom(),val_datfrom,meta.getDateTo(),val_datto,meta.getFieldLookup(),data.fieldnrs,meta.getKeyStream(),meta.getKeyLookup(),data.keynrs);
        linesOutput++;
      }
      if (punch) {
        data.db.dimPunchThrough(row,meta.getTableName(),meta.getFieldUpdate(),meta.getFieldLookup(),data.fieldnrs,meta.getKeyStream(),meta.getKeyLookup(),data.keynrs);
        linesUpdated++;
      }
      add=new Row();
      if (meta.getKeyRename() != null && meta.getKeyRename().length() > 0)       technicalKey.setName(meta.getKeyRename());
      add.addValue(technicalKey);
      logRowlevel("Technical key = " + technicalKey);
    }
  }
  debug="add values to row";
  logRowlevel("Values to add to row: " + add);
  for (int i=0; i < add.size(); i++) {
    row.addValue(add.getValue(i));
  }
  debug="get date from date field, datefieldnr=" + data.datefieldnr;
  Value date;
  if (data.datefieldnr >= 0)   date=row.getValue(data.datefieldnr);
 else   date=new Value("date",new Date());
  debug="check min date (min_date==null? " + (data.min_date == null) + ", date==null? "+ (date == null)+ "), datefieldnr="+ data.datefieldnr;
  if (data.min_date.compare(date) > 0)   data.min_date.setValue(date.getDate());
  debug="check max date";
  if (data.max_date.compare(date) < 0)   data.max_date.setValue(date.getDate());
  debug="end of lookupValues()";
}
