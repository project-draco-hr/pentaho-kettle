{
  int i;
  if (prepStatementInsert == null && prepStatementUpdate == null) {
    String sql="INSERT INTO " + databaseMeta.quoteField(table) + "( ";
    if (!autoinc)     sql+=databaseMeta.quoteField(keyfield) + ", ";
 else     if (databaseMeta.getDatabaseType() == DatabaseMeta.TYPE_DATABASE_INFORMIX)     sql+="0, ";
    sql+=databaseMeta.quoteField(versionfield) + ", " + databaseMeta.quoteField(datefrom)+ ", "+ databaseMeta.quoteField(dateto);
    for (i=0; i < keylookup.length; i++) {
      sql+=", " + databaseMeta.quoteField(keylookup[i]);
    }
    for (i=0; i < fieldlookup.length; i++) {
      sql+=", " + databaseMeta.quoteField(fieldlookup[i]);
    }
    sql+=") VALUES(";
    if (!autoinc)     sql+="?, ";
    sql+="?, ?, ?";
    for (i=0; i < keynrs.length; i++) {
      sql+=", ?";
    }
    for (i=0; i < fieldnrs.length; i++) {
      sql+=", ?";
    }
    sql+=" )";
    try {
      if (keyfield == null) {
        log.logDetailed(toString(),"SQL w/ return keys=[" + sql + "]");
        prepStatementInsert=connection.prepareStatement(databaseMeta.stripCR(sql),Statement.RETURN_GENERATED_KEYS);
      }
 else {
        log.logDetailed(toString(),"SQL=[" + sql + "]");
        prepStatementInsert=connection.prepareStatement(databaseMeta.stripCR(sql));
      }
    }
 catch (    SQLException ex) {
      throw new KettleDatabaseException("Unable to prepare dimension insert :" + Const.CR + sql,ex);
    }
    String sql_upd="UPDATE " + databaseMeta.quoteField(table) + Const.CR+ "SET "+ databaseMeta.quoteField(dateto)+ " = ?"+ Const.CR;
    sql_upd+="WHERE ";
    for (i=0; i < keylookup.length; i++) {
      if (i > 0)       sql_upd+="AND   ";
      sql_upd+=databaseMeta.quoteField(keylookup[i]) + " = ?" + Const.CR;
    }
    sql_upd+="AND   " + databaseMeta.quoteField(versionfield) + " = ? ";
    try {
      log.logDetailed(toString(),"Preparing update: " + Const.CR + sql_upd+ Const.CR);
      prepStatementUpdate=connection.prepareStatement(databaseMeta.stripCR(sql_upd));
    }
 catch (    SQLException ex) {
      throw new KettleDatabaseException("Unable to prepare dimension update :" + Const.CR + sql_upd,ex);
    }
  }
  Row rins=new Row();
  if (!autoinc)   rins.addValue(technicalKey);
  if (!newentry) {
    Value val_new_version=new Value(val_version);
    val_new_version.setValue(val_new_version.getNumber() + 1);
    rins.addValue(val_new_version);
  }
 else {
    rins.addValue(val_version);
  }
  rins.addValue(val_datfrom);
  rins.addValue(val_datto);
  for (i=0; i < keynrs.length; i++) {
    rins.addValue(row.getValue(keynrs[i]));
  }
  for (i=0; i < fieldnrs.length; i++) {
    Value val=row.getValue(fieldnrs[i]);
    rins.addValue(val);
  }
  log.logDebug(toString(),"rins, size=" + rins.size() + ", values="+ rins.toString());
  setValues(rins,prepStatementInsert);
  insertRow(prepStatementInsert);
  log.logDebug(toString(),"Row inserted!");
  if (keyfield == null) {
    try {
      Row keys=getGeneratedKeys(prepStatementInsert);
      if (keys.size() > 0) {
        technicalKey.setValue(keys.getValue(0).getInteger());
      }
 else {
        throw new KettleDatabaseException("Unable to retrieve value of auto-generated technical key : no value found!");
      }
    }
 catch (    Exception e) {
      throw new KettleDatabaseException("Unable to retrieve value of auto-generated technical key : unexpected error: ",e);
    }
  }
  if (!newentry) {
    Row rupd=new Row();
    rupd.addValue(val_datfrom);
    for (i=0; i < keynrs.length; i++) {
      rupd.addValue(row.getValue(keynrs[i]));
    }
    rupd.addValue(val_version);
    log.logRowlevel(toString(),"UPDATE using rupd=" + rupd.toString());
    setValues(rupd,prepStatementUpdate);
    log.logDebug(toString(),"Values set for update (" + rupd.size() + ")");
    insertRow(prepStatementUpdate);
    log.logDebug(toString(),"Row updated!");
  }
}
