{
  int nrcols;
  int i;
  Value v;
  String name;
  int type, valtype;
  int precision;
  int length;
  if (rm == null)   return null;
  rowinfo=new Row();
  try {
    nrcols=rm.getColumnCount();
    for (i=1; i <= nrcols; i++) {
      name=new String(rm.getColumnName(i));
      type=rm.getColumnType(i);
      valtype=Value.VALUE_TYPE_NONE;
      length=-1;
      precision=-1;
switch (type) {
case java.sql.Types.CHAR:
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
        valtype=Value.VALUE_TYPE_STRING;
      if (!ignoreLength)       length=rm.getColumnDisplaySize(i);
    break;
case java.sql.Types.CLOB:
  valtype=Value.VALUE_TYPE_STRING;
length=DatabaseMeta.CLOB_LENGTH;
break;
case java.sql.Types.BIGINT:
valtype=Value.VALUE_TYPE_INTEGER;
precision=0;
length=15;
break;
case java.sql.Types.INTEGER:
valtype=Value.VALUE_TYPE_INTEGER;
precision=0;
length=9;
break;
case java.sql.Types.SMALLINT:
valtype=Value.VALUE_TYPE_INTEGER;
precision=0;
length=4;
break;
case java.sql.Types.TINYINT:
valtype=Value.VALUE_TYPE_INTEGER;
precision=0;
length=2;
break;
case java.sql.Types.DECIMAL:
case java.sql.Types.DOUBLE:
case java.sql.Types.FLOAT:
case java.sql.Types.REAL:
case java.sql.Types.NUMERIC:
valtype=Value.VALUE_TYPE_NUMBER;
length=rm.getPrecision(i);
precision=rm.getScale(i);
if (length >= 126) length=-1;
if (precision >= 126) precision=-1;
if (type == java.sql.Types.DOUBLE || type == java.sql.Types.FLOAT || type == java.sql.Types.REAL) {
if (precision == 0) {
precision=-1;
}
if (databaseMeta.getDatabaseType() == DatabaseMeta.TYPE_DATABASE_POSTGRES && type == java.sql.Types.DOUBLE && precision == 16 && length == 16) {
precision=-1;
length=-1;
}
}
 else {
if (precision == 0 && length < 18 && length > 0) {
valtype=Value.VALUE_TYPE_INTEGER;
}
}
if (length > 18 || precision > 18) valtype=Value.VALUE_TYPE_BIGNUMBER;
if (databaseMeta.getDatabaseType() == DatabaseMeta.TYPE_DATABASE_ORACLE) {
if (precision <= 0 && length <= 0) {
valtype=Value.VALUE_TYPE_BIGNUMBER;
length=-1;
precision=-1;
}
}
break;
case java.sql.Types.DATE:
case java.sql.Types.TIME:
case java.sql.Types.TIMESTAMP:
valtype=Value.VALUE_TYPE_DATE;
break;
case java.sql.Types.BOOLEAN:
case java.sql.Types.BIT:
valtype=Value.VALUE_TYPE_BOOLEAN;
break;
default :
valtype=Value.VALUE_TYPE_STRING;
length=rm.getPrecision(i);
precision=rm.getScale(i);
if (databaseMeta.getDatabaseType() == DatabaseMeta.TYPE_DATABASE_DB2) {
if (type == java.sql.Types.BINARY && ((2 * length) == rm.getColumnDisplaySize(i))) {
length=rm.getColumnDisplaySize(i);
}
}
break;
}
v=new Value(name,valtype);
v.setLength(length,precision);
rowinfo.addValue(v);
}
return rowinfo;
}
 catch (SQLException ex) {
throw new KettleDatabaseException("Error getting row information from database: ",ex);
}
}
