{
  String debug="Combination insert";
  try {
    boolean comma;
    if (prepStatementInsert == null) {
      debug="First: construct prepared statement";
      StringBuffer sql=new StringBuffer(100);
      sql.append("INSERT INTO ").append(databaseMeta.quoteField(table)).append("( ");
      comma=false;
      if (!autoinc) {
        sql.append(databaseMeta.quoteField(keyfield));
        comma=true;
      }
 else       if (databaseMeta.needsPlaceHolder()) {
        sql.append('0');
        comma=true;
      }
      if (crc) {
        if (comma)         sql.append(", ");
        sql.append(databaseMeta.quoteField(crcfield));
        comma=true;
      }
      for (int i=0; i < keylookup.length; i++) {
        if (comma)         sql.append(", ");
        sql.append(databaseMeta.quoteField(keylookup[i]));
        comma=true;
      }
      sql.append(") VALUES (");
      comma=false;
      if (keyfield != null) {
        sql.append('?');
        comma=true;
      }
      if (crc) {
        if (comma)         sql.append(',');
        sql.append('?');
        comma=true;
      }
      for (int i=0; i < keylookup.length; i++) {
        if (comma)         sql.append(',');
 else         comma=true;
        sql.append('?');
      }
      sql.append(" )");
      String sqlStatement=sql.toString();
      try {
        debug="First: prepare statement";
        if (keyfield == null) {
          log.logDetailed(toString(),"SQL with return keys: " + sqlStatement);
          prepStatementInsert=connection.prepareStatement(databaseMeta.stripCR(sqlStatement),Statement.RETURN_GENERATED_KEYS);
        }
 else {
          log.logDetailed(toString(),"SQL without return keys: " + sqlStatement);
          prepStatementInsert=connection.prepareStatement(databaseMeta.stripCR(sqlStatement));
        }
      }
 catch (      SQLException ex) {
        throw new KettleDatabaseException("Unable to prepare combi insert statement : " + Const.CR + sqlStatement,ex);
      }
catch (      Exception ex) {
        throw new KettleDatabaseException("Unable to prepare combi insert statement : " + Const.CR + sqlStatement,ex);
      }
    }
    debug="Create new insert row rins";
    Row rins=new Row();
    if (!autoinc)     rins.addValue(val_key);
    if (crc) {
      rins.addValue(val_crc);
    }
    for (int i=0; i < keynrs.length; i++) {
      rins.addValue(row.getValue(keynrs[i]));
    }
    if (log.isRowLevel())     log.logRowlevel(toString(),"rins=" + rins.toString());
    debug="Set values on insert";
    setValues(rins,prepStatementInsert);
    debug="Insert row";
    insertRow(prepStatementInsert);
    debug="Retrieve key";
    if (keyfield == null) {
      ResultSet keys=null;
      try {
        keys=prepStatementInsert.getGeneratedKeys();
        if (keys.next())         val_key.setValue(keys.getDouble(1));
 else {
          throw new KettleDatabaseException("Unable to retrieve auto-increment of combi insert key : " + keyfield + ", no fields in resultset");
        }
      }
 catch (      SQLException ex) {
        throw new KettleDatabaseException("Unable to retrieve auto-increment of combi insert key : " + keyfield,ex);
      }
 finally {
        try {
          if (keys != null)           keys.close();
        }
 catch (        SQLException ex) {
          throw new KettleDatabaseException("Unable to retrieve auto-increment of combi insert key : " + keyfield,ex);
        }
      }
    }
  }
 catch (  Exception e) {
    log.logError(toString(),Const.getStackTracker(e));
    throw new KettleDatabaseException("Unexpected error in combination insert in part [" + debug + "] : "+ e.toString(),e);
  }
}
