{
  this();
  try {
    String pathAndName=repdir.isRoot() ? repdir + transname : repdir + RepositoryDirectory.DIRECTORY_SEPARATOR + transname;
    setName(transname);
    directory=repdir;
    directoryTree=directory.findRoot();
    log.logDetailed(toString(),Messages.getString("TransMeta.Log.LookingForTransformation",transname,directory.getPath()));
    if (monitor != null)     monitor.subTask(Messages.getString("TransMeta.Monitor.ReadingTransformationInfoTask.Title"));
    setID(rep.getTransformationID(transname,directory.getID()));
    if (monitor != null)     monitor.worked(1);
    if (getID() > 0) {
      long noteids[]=rep.getTransNoteIDs(getID());
      long stepids[]=rep.getStepIDs(getID());
      long hopids[]=rep.getTransHopIDs(getID());
      int nrWork=3 + noteids.length + stepids.length+ hopids.length;
      if (monitor != null)       monitor.beginTask(Messages.getString("TransMeta.Monitor.LoadingTransformationTask.Title") + pathAndName,nrWork);
      log.logDetailed(toString(),Messages.getString("TransMeta.Log.LoadingTransformation",getName()));
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.ReadingTheAvailableSharedObjectsTask.Title"));
      try {
        readSharedObjects(rep);
      }
 catch (      Exception e) {
        LogWriter.getInstance().logError(toString(),Messages.getString("TransMeta.ErrorReadingSharedObjects.Message",e.toString()));
        LogWriter.getInstance().logError(toString(),Const.getStackTracker(e));
      }
      if (monitor != null)       monitor.worked(1);
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.ReadingNoteTask.Title"));
      for (int i=0; i < noteids.length; i++) {
        NotePadMeta ni=new NotePadMeta(log,rep,noteids[i]);
        if (indexOfNote(ni) < 0)         addNote(ni);
        if (monitor != null)         monitor.worked(1);
      }
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.ReadingStepsTask.Title"));
      rep.fillStepAttributesBuffer(getID());
      for (int i=0; i < stepids.length; i++) {
        log.logDetailed(toString(),Messages.getString("TransMeta.Log.LoadingStepWithID") + stepids[i]);
        if (monitor != null)         monitor.subTask(Messages.getString("TransMeta.Monitor.ReadingStepTask.Title") + (i + 1) + "/"+ (stepids.length));
        StepMeta stepMeta=new StepMeta(rep,stepids[i],databases,counters,partitionSchemas);
        addOrReplaceStep(stepMeta);
        if (monitor != null)         monitor.worked(1);
      }
      if (monitor != null)       monitor.worked(1);
      rep.setStepAttributesBuffer(null);
      for (int i=0; i < nrSteps(); i++) {
        StepMetaInterface sii=getStep(i).getStepMetaInterface();
        sii.searchInfoAndTargetSteps(steps);
      }
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.LoadingTransformationDetailsTask.Title"));
      loadRepTrans(rep);
      if (monitor != null)       monitor.worked(1);
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.ReadingHopTask.Title"));
      for (int i=0; i < hopids.length; i++) {
        TransHopMeta hi=new TransHopMeta(rep,hopids[i],steps);
        addTransHop(hi);
        if (monitor != null)         monitor.worked(1);
      }
      for (int i=0; i < nrSteps(); i++) {
        StepPartitioningMeta stepPartitioningMeta=getStep(i).getStepPartitioningMeta();
        if (stepPartitioningMeta != null) {
          stepPartitioningMeta.setPartitionSchemaAfterLoading(partitionSchemas);
        }
      }
      for (int i=0; i < nrSteps(); i++) {
        getStep(i).setClusterSchemaAfterLoading(clusterSchemas);
      }
      for (int i=0; i < nrSteps(); i++) {
        getStep(i).getStepPartitioningMeta().setPartitionSchemaAfterLoading(partitionSchemas);
      }
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.ReadingTheDependenciesTask.Title"));
      long depids[]=rep.getTransDependencyIDs(getID());
      for (int i=0; i < depids.length; i++) {
        TransDependency td=new TransDependency(rep,depids[i],databases);
        addDependency(td);
      }
      if (monitor != null)       monitor.worked(1);
      for (int i=0; i < nrSteps(); i++) {
        StepMeta stepMeta=getStep(i);
        String sourceStep=rep.getStepAttributeString(stepMeta.getID(),"step_error_handling_source_step");
        if (sourceStep != null) {
        }
      }
      if (monitor != null)       monitor.subTask(Messages.getString("TransMeta.Monitor.SortingStepsTask.Title"));
      sortSteps();
      if (monitor != null)       monitor.worked(1);
      if (monitor != null)       monitor.done();
    }
 else {
      throw new KettleException(Messages.getString("TransMeta.Exception.TransformationDoesNotExist") + name);
    }
    log.logDetailed(toString(),Messages.getString("TransMeta.Log.LoadedTransformation2",transname,String.valueOf(directory == null)));
    log.logDetailed(toString(),Messages.getString("TransMeta.Log.LoadedTransformation",transname,directory.getPath()));
  }
 catch (  KettleDatabaseException e) {
    log.logError(toString(),Messages.getString("TransMeta.Log.DatabaseErrorOccuredReadingTransformation") + Const.CR + e);
    throw new KettleException(Messages.getString("TransMeta.Exception.DatabaseErrorOccuredReadingTransformation"),e);
  }
catch (  Exception e) {
    log.logError(toString(),Messages.getString("TransMeta.Log.DatabaseErrorOccuredReadingTransformation") + Const.CR + e);
    throw new KettleException(Messages.getString("TransMeta.Exception.DatabaseErrorOccuredReadingTransformation2"),e);
  }
 finally {
    if (setInternalVariables)     setInternalKettleVariables();
  }
}
