{
  try {
    Row r=rep.getTransformation(getID());
    if (r != null) {
      name=r.searchValue("NAME").getString();
      readStep=findStep(steps,r.getInteger("ID_STEP_READ",-1L));
      writeStep=findStep(steps,r.getInteger("ID_STEP_WRITE",-1L));
      inputStep=findStep(steps,r.getInteger("ID_STEP_INPUT",-1L));
      outputStep=findStep(steps,r.getInteger("ID_STEP_OUTPUT",-1L));
      updateStep=findStep(steps,r.getInteger("ID_STEP_UPDATE",-1L));
      logConnection=Const.findDatabase(databases,r.getInteger("ID_DATABASE_LOG",-1L));
      logTable=r.getString("TABLE_NAME_LOG",null);
      useBatchId=r.getBoolean("USE_BATCHID",false);
      logfieldUsed=r.getBoolean("USE_LOGFIELD",false);
      maxDateConnection=Const.findDatabase(databases,r.getInteger("ID_DATABASE_MAXDATE",-1L));
      maxDateTable=r.getString("TABLE_NAME_MAXDATE",null);
      maxDateField=r.getString("FIELD_NAME_MAXDATE",null);
      maxDateOffset=r.getNumber("OFFSET_MAXDATE",0.0);
      maxDateDifference=r.getNumber("DIFF_MAXDATE",0.0);
      modifiedUser=r.getString("MODIFIED_USER",null);
      modifiedDate=r.searchValue("MODIFIED_DATE");
      sizeRowset=Const.ROWS_IN_ROWSET;
      Value val_size_rowset=r.searchValue("SIZE_ROWSET");
      if (val_size_rowset != null && !val_size_rowset.isNull()) {
        sizeRowset=(int)val_size_rowset.getInteger();
      }
      long id_directory=r.getInteger("ID_DIRECTORY",-1L);
      if (id_directory >= 0) {
        log.logDetailed(toString(),"ID_DIRECTORY=" + id_directory);
        directory=directoryTree.findDirectory(id_directory);
      }
      usingUniqueConnections=rep.getTransAttributeBoolean(getID(),0,"UNIQUE_CONNECTIONS");
      feedbackShown=!"N".equalsIgnoreCase(rep.getTransAttributeString(getID(),0,"FEEDBACK_SHOWN"));
      feedbackSize=(int)rep.getTransAttributeInteger(getID(),0,"FEEDBACK_SIZE");
      usingThreadPriorityManagment=!"N".equalsIgnoreCase(rep.getTransAttributeString(getID(),0,"USING_THREAD_PRIORITIES"));
      int nrSchemas=rep.countNrTransAttributes(getID(),"SCHEMA_NAME");
      for (int i=0; i < nrSchemas; i++) {
        String schemaName=rep.getTransAttributeString(getID(),i,"SCHEMA_NAME");
        int nrPartitions=(int)rep.getTransAttributeInteger(getID(),i,"SCHEMA_NAME");
        String[] ids=new String[nrPartitions];
        for (int p=0; p < nrPartitions; p++) {
          ids[p]=rep.getTransAttributeString(getID(),i,"SCHEMA_PARTITION_" + p);
        }
        partitionSchemas.add(new PartitionSchema(schemaName,ids));
      }
    }
  }
 catch (  KettleDatabaseException dbe) {
    throw new KettleException(Messages.getString("TransMeta.Exception.UnableToLoadTransformationInfoFromRepository"),dbe);
  }
 finally {
    setInternalKettleVariables();
  }
}
