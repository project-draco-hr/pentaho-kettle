{
  sdi.setStatus(StepDataInterface.STATUS_INIT);
  String slaveNr=transMeta.getVariable(Const.INTERNAL_VARIABLE_SLAVE_SERVER_NUMBER);
  String clusterSize=transMeta.getVariable(Const.INTERNAL_VARIABLE_CLUSTER_SIZE);
  if (!Const.isEmpty(slaveNr) && !Const.isEmpty(clusterSize)) {
    this.slaveNr=Integer.parseInt(slaveNr);
    this.clusterSize=Integer.parseInt(clusterSize);
    logDetailed("Running on slave server #" + slaveNr + "/"+ clusterSize+ ".");
  }
 else {
    this.slaveNr=0;
    this.clusterSize=0;
  }
  SlaveStepCopyPartitionDistribution partitionDistribution=transMeta.getSlaveStepCopyPartitionDistribution();
  if (stepMeta.isPartitioned() && partitionDistribution != null) {
    String slaveServerName=getVariable(Const.INTERNAL_VARIABLE_SLAVE_SERVER_NAME);
    String stepName=stepname;
    int stepCopyNr=stepcopy;
    int partitionNr=partitionDistribution.getPartition(slaveServerName,stepName,stepCopyNr);
    if (partitionNr >= 0) {
      String partitionNrString=new DecimalFormat("000").format(partitionNr);
      setVariable(Const.INTERNAL_VARIABLE_STEP_PARTITION_NR,partitionNrString);
      if (partitionDistribution.getOriginalPartitionSchemas() != null) {
        String partitionSchemaName=stepMeta.getStepPartitioningMeta().getPartitionSchema().getName();
        for (        PartitionSchema originalPartitionSchema : partitionDistribution.getOriginalPartitionSchemas()) {
          String slavePartitionSchemaName=TransSplitter.createSlavePartitionSchemaName(originalPartitionSchema.getName());
          if (slavePartitionSchemaName.equals(partitionSchemaName)) {
            PartitionSchema schema=(PartitionSchema)originalPartitionSchema.clone();
            if (schema.isDynamicallyDefined()) {
              schema.expandPartitionsDynamically(this.clusterSize,this);
            }
            String partID=schema.getPartitionIDs().get(partitionNr);
            setVariable(Const.INTERNAL_VARIABLE_STEP_PARTITION_ID,partID);
            break;
          }
        }
      }
    }
  }
 else   if (!Const.isEmpty(partitionID)) {
    setVariable(Const.INTERNAL_VARIABLE_STEP_PARTITION_ID,partitionID);
  }
  uniqueStepNrAcrossSlaves=this.slaveNr * getStepMeta().getCopies() + stepcopy;
  uniqueStepCountAcrossSlaves=this.clusterSize == 0 ? getStepMeta().getCopies() : this.clusterSize * getStepMeta().getCopies();
  if (uniqueStepCountAcrossSlaves == 0)   uniqueStepCountAcrossSlaves=1;
  setVariable(Const.INTERNAL_VARIABLE_STEP_UNIQUE_NUMBER,Integer.toString(uniqueStepNrAcrossSlaves));
  setVariable(Const.INTERNAL_VARIABLE_STEP_UNIQUE_COUNT,Integer.toString(uniqueStepCountAcrossSlaves));
  try {
    remoteOutputSteps=new ArrayList<RemoteStep>();
    for (    RemoteStep remoteStep : stepMeta.getRemoteOutputSteps()) {
      RemoteStep copy=(RemoteStep)remoteStep.clone();
      try {
        copy.openServerSocket(this);
        logDetailed("Opened a server socket connection to " + copy);
      }
 catch (      Exception e) {
        log.logError(toString(),"Unable to open server socket during step initialisation: " + copy.toString(),e);
        throw new Exception(e);
      }
      remoteOutputSteps.add(copy);
    }
  }
 catch (  Exception e) {
    for (    RemoteStep remoteStep : remoteOutputSteps) {
      if (remoteStep.getServerSocket() != null) {
        try {
          remoteStep.getServerSocket().close();
        }
 catch (        IOException e1) {
          log.logError(toString(),"Unable to close server socket after error during step initialisation",e);
        }
      }
    }
    return false;
  }
  try {
    remoteInputSteps=new ArrayList<RemoteStep>();
    if (stepMeta.isPartitioned() && stepMeta.getClusterSchema() != null) {
      RemoteStep remoteStep=(RemoteStep)stepMeta.getRemoteInputSteps().get(stepcopy).clone();
      remoteInputSteps.add(remoteStep);
      logBasic("added remote input step : " + remoteStep);
    }
 else {
      for (      RemoteStep remoteStep : stepMeta.getRemoteInputSteps()) {
        RemoteStep copy=(RemoteStep)remoteStep.clone();
        remoteInputSteps.add(copy);
      }
    }
  }
 catch (  Exception e) {
    log.logError(toString(),"Unable to initialize remote input steps during step initialisation",e);
    return false;
  }
  return true;
}
