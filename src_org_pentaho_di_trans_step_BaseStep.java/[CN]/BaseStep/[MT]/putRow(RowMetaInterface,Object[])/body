{
  while (paused.get() && !stopped.get()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new KettleStepException(e);
    }
  }
  if (this.checkTransRunning == false) {
    while (!trans.isRunning() && !stopped.get()) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
    this.checkTransRunning=true;
  }
synchronized (this) {
    for (int i=0; i < rowListeners.size(); i++) {
      RowListener rowListener=(RowListener)rowListeners.get(i);
      rowListener.rowWrittenEvent(rowMeta,row);
    }
  }
  if (terminator && terminator_rows != null) {
    try {
      terminator_rows.add(rowMeta.cloneRow(row));
    }
 catch (    KettleValueException e) {
      throw new KettleStepException("Unable to clone row while adding rows to the terminator rows.",e);
    }
  }
  if (!remoteOutputSteps.isEmpty()) {
    if (!remoteOutputStepsInitialized) {
      for (int c=0; c < outputRowSets.size(); c++) {
        RowSet rowSet=outputRowSets.get(c);
        rowSet.setRemoteSlaveServerName(getVariable(Const.INTERNAL_VARIABLE_SLAVE_SERVER_NAME));
        if (getVariable(Const.INTERNAL_VARIABLE_SLAVE_SERVER_NAME) == null) {
          throw new KettleStepException("Variable '" + Const.INTERNAL_VARIABLE_SLAVE_SERVER_NAME + "' is not defined.");
        }
      }
      for (      RemoteStep remoteStep : remoteOutputSteps) {
        try {
          if (remoteStep.getTargetSlaveServerName() == null) {
            throw new KettleStepException("The target slave server name is not defined for remote output step: " + remoteStep);
          }
          RowSet rowSet=remoteStep.openWriterSocket();
          if (log.isDetailed())           logDetailed("Opened a writer socket to remote step: " + remoteStep);
          outputRowSets.add(rowSet);
        }
 catch (        IOException e) {
          throw new KettleStepException("Error opening writer socket to remote step '" + remoteStep + "'",e);
        }
      }
      remoteOutputStepsInitialized=true;
    }
  }
  if (outputRowSets.isEmpty()) {
    linesWritten++;
    return;
  }
  if (stopped.get()) {
    if (log.isDebug())     logDebug(Messages.getString("BaseStep.Log.StopPuttingARow"));
    stopAll();
    return;
  }
switch (repartitioning) {
case StepPartitioningMeta.PARTITIONING_METHOD_NONE:
{
      if (distributed) {
        RowSet rs=outputRowSets.get(currentOutputRowSetNr);
        while (!rs.putRow(rowMeta,row) && !isStopped())         ;
        linesWritten++;
        if (outputRowSets.size() > 1) {
          currentOutputRowSetNr++;
          if (currentOutputRowSetNr >= outputRowSets.size())           currentOutputRowSetNr=0;
        }
      }
 else {
        for (int i=1; i < outputRowSets.size(); i++) {
          RowSet rs=outputRowSets.get(i);
          try {
            while (!rs.putRow(rowMeta,rowMeta.cloneRow(row)) && !isStopped())             ;
            linesWritten++;
          }
 catch (          KettleValueException e) {
            throw new KettleStepException("Unable to clone row while copying rows to multiple target steps",e);
          }
        }
        RowSet rs=outputRowSets.get(0);
        while (!rs.putRow(rowMeta,row) && !isStopped())         ;
        linesWritten++;
      }
    }
  break;
case StepPartitioningMeta.PARTITIONING_METHOD_SPECIAL:
{
  if (nextStepPartitioningMeta == null) {
    StepMeta[] nextSteps=transMeta.getNextSteps(stepMeta);
    if (nextSteps.length > 0) {
      nextStepPartitioningMeta=nextSteps[0].getStepPartitioningMeta();
    }
  }
  int partitionNr;
  try {
    partitionNr=nextStepPartitioningMeta.getPartition(rowMeta,row);
  }
 catch (  KettleException e) {
    throw new KettleStepException("Unable to convert a value to integer while calculating the partition number",e);
  }
  RowSet selectedRowSet=null;
  if (clusteredPartitioningFirst) {
    clusteredPartitioningFirst=false;
    clusteredPartitioning=transMeta.getSlaveStepCopyPartitionDistribution() != null && !transMeta.getSlaveStepCopyPartitionDistribution().getDistribution().isEmpty();
  }
  if (clusteredPartitioning) {
    if (partitionNrRowSetList == null) {
      partitionNrRowSetList=new RowSet[outputRowSets.size()];
      SlaveStepCopyPartitionDistribution distribution=transMeta.getSlaveStepCopyPartitionDistribution();
      String nextPartitionSchemaName=TransSplitter.createPartitionSchemaNameFromTarget(nextStepPartitioningMeta.getPartitionSchema().getName());
      for (      RowSet outputRowSet : outputRowSets) {
        try {
          int partNr=distribution.getPartition(outputRowSet.getRemoteSlaveServerName(),nextPartitionSchemaName,outputRowSet.getDestinationStepCopy());
          if (partNr < 0) {
            throw new KettleStepException("Unable to find partition using rowset data, slave=" + outputRowSet.getRemoteSlaveServerName() + ", partition schema="+ nextStepPartitioningMeta.getPartitionSchema().getName()+ ", copy="+ outputRowSet.getDestinationStepCopy());
          }
          partitionNrRowSetList[partNr]=outputRowSet;
        }
 catch (        NullPointerException e) {
          throw (e);
        }
      }
    }
    selectedRowSet=partitionNrRowSetList[partitionNr];
  }
 else {
    selectedRowSet=outputRowSets.get(partitionNr);
  }
  if (selectedRowSet == null) {
    logBasic("Target rowset is not available for target partition, partitionNr=" + partitionNr);
  }
  while (!selectedRowSet.putRow(rowMeta,row) && !isStopped())   ;
  linesWritten++;
  if (log.isRowLevel())   try {
    logRowlevel("Partitioned #" + partitionNr + " to "+ selectedRowSet+ ", row="+ rowMeta.getString(row));
  }
 catch (  KettleValueException e) {
    throw new KettleStepException(e);
  }
}
break;
case StepPartitioningMeta.PARTITIONING_METHOD_MIRROR:
{
for (int r=0; r < outputRowSets.size(); r++) {
RowSet rowSet=outputRowSets.get(r);
while (!rowSet.putRow(rowMeta,row) && !isStopped()) ;
}
}
break;
default :
throw new KettleStepException("Internal error: invalid repartitioning type: " + repartitioning);
}
}
