{
  if (this.checkTransRunning == false) {
    while (!trans.isRunning() && !stopped.get()) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
    this.checkTransRunning=true;
  }
  if (previewSize > 0) {
    if (previewBuffer.size() < previewSize) {
      try {
        if (previewRowMeta == null)         previewRowMeta=(RowMetaInterface)rowMeta.clone();
        previewBuffer.add(rowMeta.cloneRow(row));
      }
 catch (      KettleValueException e) {
        throw new KettleStepException("Unable to clone row while adding rows to the preview buffer",e);
      }
    }
  }
  for (int i=0; i < rowListeners.size(); i++) {
    RowListener rowListener=(RowListener)rowListeners.get(i);
    rowListener.rowWrittenEvent(rowMeta,row);
  }
  if (terminator && terminator_rows != null) {
    try {
      terminator_rows.add(rowMeta.cloneRow(row));
    }
 catch (    KettleValueException e) {
      throw new KettleStepException("Unable to clone row while adding rows to the terminator rows.",e);
    }
  }
  if (!remoteOutputSteps.isEmpty()) {
    if (!remoteOutputStepsInitialized) {
      for (int c=0; c < outputRowSets.size(); c++) {
        RowSet rowSet=outputRowSets.get(c);
        rowSet.setRemoteSlaveServerName(getVariable(Const.INTERNAL_VARIABLE_SLAVE_SERVER_NAME));
      }
      for (      RemoteStep remoteStep : remoteOutputSteps) {
        try {
          RowSet rowSet=remoteStep.openWriterSocket(this);
          logBasic("Opened a writer socket to remote step: " + remoteStep);
          outputRowSets.add(rowSet);
        }
 catch (        IOException e) {
          throw new KettleStepException("Error opening writer socket to remote step '" + remoteStep + "'",e);
        }
      }
      remoteOutputStepsInitialized=true;
    }
  }
  if (outputRowSets.size() == 0) {
    linesWritten++;
    return;
  }
  if (stopped.get()) {
    if (log.isDebug())     logDebug(Messages.getString("BaseStep.Log.StopPuttingARow"));
    stopAll();
    return;
  }
  int partitioningType=StepPartitioningMeta.getMethodType(repartitioning);
switch (partitioningType) {
case StepPartitioningMeta.PARTITIONING_METHOD_NONE:
{
      if (distributed) {
        RowSet rs=outputRowSets.get(currentOutputRowSetNr);
        while (!rs.putRow(rowMeta,row) && !isStopped())         ;
        linesWritten++;
        if (outputRowSets.size() > 1) {
          currentOutputRowSetNr++;
          if (currentOutputRowSetNr >= outputRowSets.size())           currentOutputRowSetNr=0;
        }
      }
 else {
        for (int i=1; i < outputRowSets.size(); i++) {
          RowSet rs=outputRowSets.get(i);
          try {
            while (!rs.putRow(rowMeta,rowMeta.cloneRow(row)) && !isStopped())             ;
            linesWritten++;
          }
 catch (          KettleValueException e) {
            throw new KettleStepException("Unable to clone row while copying rows to multiple target steps",e);
          }
        }
        RowSet rs=outputRowSets.get(0);
        while (!rs.putRow(rowMeta,row) && !isStopped())         ;
        linesWritten++;
      }
    }
  break;
case StepPartitioningMeta.PARTITIONING_METHOD_SPECIAL:
{
  if (nextStepPartitioningMeta == null) {
    nextStepPartitioningMeta=stepMeta.getTargetStepPartitioningMeta();
  }
  int partitionNr;
  try {
    partitionNr=nextStepPartitioningMeta.getPartition(rowMeta,row);
  }
 catch (  KettleException e) {
    throw new KettleStepException("Unable to convert a value to integer while calculating the partition number",e);
  }
  RowSet rs=null;
  if (transMeta.getSlaveStepCopyPartitionDistribution() != null) {
    if (partitionNrRowSetMap == null) {
      partitionNrRowSetMap=new Hashtable<Integer,RowSet>();
      SlaveStepCopyPartitionDistribution distribution=transMeta.getSlaveStepCopyPartitionDistribution();
      for (      RowSet outputRowSet : outputRowSets) {
        int partNr=distribution.getPartition(outputRowSet.getRemoteSlaveServerName(),outputRowSet.getDestinationStepName(),outputRowSet.getDestinationStepCopy());
        if (partNr == -1) {
          throw new KettleStepException("Unable to find partition using rowset data, slave=" + outputRowSet.getRemoteSlaveServerName() + ", step="+ outputRowSet.getDestinationStepName()+ ", copy="+ outputRowSet.getDestinationStepCopy());
        }
        partitionNrRowSetMap.put(partNr,outputRowSet);
      }
    }
    rs=partitionNrRowSetMap.get(partitionNr);
  }
 else {
    rs=outputRowSets.get(partitionNr);
  }
  if (rs == null) {
    logBasic("Target rowset is not available for target partition, partitionNr=" + partitionNr);
  }
  while (!rs.putRow(rowMeta,row) && !isStopped())   ;
  linesWritten++;
}
break;
case StepPartitioningMeta.PARTITIONING_METHOD_MIRROR:
{
for (int r=0; r < outputRowSets.size(); r++) {
RowSet rowSet=outputRowSets.get(r);
while (!rowSet.putRow(rowMeta,row) && !isStopped()) ;
}
}
break;
}
}
