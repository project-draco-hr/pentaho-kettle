{
  log=LogWriter.getInstance();
  this.stepMeta=stepMeta;
  this.stepDataInterface=stepDataInterface;
  this.stepcopy=copyNr;
  this.transMeta=transMeta;
  this.trans=trans;
  this.stepname=stepMeta.getName();
  if (stepMeta.getName() != null) {
    setName(toString() + " (" + super.getName()+ ")");
  }
 else {
    throw new RuntimeException("A step in transformation [" + transMeta.toString() + "] doesn't have a name.  A step should always have a name to identify it by.");
  }
  first=true;
  stopped=new AtomicBoolean(false);
  ;
  paused=new AtomicBoolean(false);
  ;
  init=false;
  linesRead=0L;
  linesWritten=0L;
  linesUpdated=0L;
  linesSkipped=0L;
  inputRowSets=null;
  outputRowSets=null;
  nextSteps=null;
  terminator=stepMeta.hasTerminator();
  if (terminator) {
    terminator_rows=new ArrayList<Object[]>();
  }
 else {
    terminator_rows=null;
  }
  start_time=null;
  stop_time=null;
  distributed=stepMeta.isDistributes();
  if (distributed)   if (log.isDetailed())   logDetailed(Messages.getString("BaseStep.Log.DistributionActivated"));
 else   if (log.isDetailed())   logDetailed(Messages.getString("BaseStep.Log.DistributionDeactivated"));
  rowListeners=new ArrayList<RowListener>();
  resultFiles=new Hashtable<String,ResultFile>();
  repartitioning=StepPartitioningMeta.PARTITIONING_METHOD_NONE;
  partitionTargets=new Hashtable<String,RowSet>();
  serverSockets=new ArrayList<ServerSocket>();
  checkTransRunning=false;
  blockPointer=0;
  dispatch();
}
