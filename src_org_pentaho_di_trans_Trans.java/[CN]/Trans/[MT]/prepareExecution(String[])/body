{
  preparing=true;
  startDate=null;
  running=false;
  if (arguments != null)   transMeta.setArguments(arguments);
  if (transMeta.getName() == null) {
    if (transMeta.getFilename() != null) {
      log.logMinimal(toString(),Messages.getString("Trans.Log.DispacthingStartedForFilename",transMeta.getFilename()));
    }
  }
 else {
    log.logMinimal(toString(),Messages.getString("Trans.Log.DispacthingStartedForTransformation",transMeta.getName()));
  }
  if (transMeta.getArguments() != null) {
    log.logBasic(toString(),Messages.getString("Trans.Log.NumberOfArgumentsDetected",String.valueOf(transMeta.getArguments().length)));
  }
  if (isSafeModeEnabled()) {
    log.logBasic(toString(),Messages.getString("Trans.Log.SafeModeIsEnabled",transMeta.getName()));
  }
  if (getReplayDate() != null) {
    SimpleDateFormat df=new SimpleDateFormat(REPLAY_DATE_FORMAT);
    log.logBasic(toString(),Messages.getString("Trans.Log.ThisIsAReplayTransformation") + df.format(getReplayDate()));
  }
 else {
    log.logBasic(toString(),Messages.getString("Trans.Log.ThisIsNotAReplayTransformation"));
  }
  steps=new ArrayList<StepMetaDataCombi>();
  rowsets=new ArrayList<RowSet>();
  if (isMonitored() && transMeta.nrSteps() < 10) {
    transMeta.sortStepsNatural();
    transMeta.sortHopsNatural();
  }
  List<StepMeta> hopsteps=transMeta.getTransHopSteps(false);
  if (log.isDetailed()) {
    log.logDetailed(toString(),Messages.getString("Trans.Log.FoundDefferentSteps",String.valueOf(hopsteps.size())));
    log.logDetailed(toString(),Messages.getString("Trans.Log.AllocatingRowsets"));
  }
  for (int i=0; i < hopsteps.size(); i++) {
    StepMeta thisStep=hopsteps.get(i);
    if (thisStep.isMapping())     continue;
    if (log.isDetailed())     log.logDetailed(toString(),Messages.getString("Trans.Log.AllocateingRowsetsForStep",String.valueOf(i),thisStep.getName()));
    int nrTargets=transMeta.findNrNextSteps(thisStep);
    for (int n=0; n < nrTargets; n++) {
      StepMeta nextStep=transMeta.findNextStep(thisStep,n);
      if (nextStep.isMapping())       continue;
      int thisCopies=thisStep.getCopies();
      int nextCopies=nextStep.getCopies();
      int nrCopies;
      if (log.isDetailed())       log.logDetailed(toString(),Messages.getString("Trans.Log.copiesInfo",String.valueOf(thisCopies),String.valueOf(nextCopies)));
      int dispatchType;
      if (thisCopies == 1 && nextCopies == 1) {
        dispatchType=TYPE_DISP_1_1;
        nrCopies=1;
      }
 else       if (thisCopies == 1 && nextCopies > 1) {
        dispatchType=TYPE_DISP_1_N;
        nrCopies=nextCopies;
      }
 else       if (thisCopies > 1 && nextCopies == 1) {
        dispatchType=TYPE_DISP_N_1;
        nrCopies=thisCopies;
      }
 else       if (thisCopies == nextCopies) {
        dispatchType=TYPE_DISP_N_N;
        nrCopies=nextCopies;
      }
 else {
        dispatchType=TYPE_DISP_N_M;
        nrCopies=nextCopies;
      }
      if (dispatchType != TYPE_DISP_N_M) {
        for (int c=0; c < nrCopies; c++) {
          RowSet rowSet=new RowSet(transMeta.getSizeRowset());
switch (dispatchType) {
case TYPE_DISP_1_1:
            rowSet.setThreadNameFromToCopy(thisStep.getName(),0,nextStep.getName(),0);
          break;
case TYPE_DISP_1_N:
        rowSet.setThreadNameFromToCopy(thisStep.getName(),0,nextStep.getName(),c);
      break;
case TYPE_DISP_N_1:
    rowSet.setThreadNameFromToCopy(thisStep.getName(),c,nextStep.getName(),0);
  break;
case TYPE_DISP_N_N:
rowSet.setThreadNameFromToCopy(thisStep.getName(),c,nextStep.getName(),c);
break;
}
rowsets.add(rowSet);
if (log.isDetailed()) log.logDetailed(toString(),Messages.getString("Trans.TransformationAllocatedNewRowset",rowSet.toString()));
}
}
 else {
for (int s=0; s < thisCopies; s++) {
for (int t=0; t < nextCopies; t++) {
RowSet rowSet=new RowSet(transMeta.getSizeRowset());
rowSet.setThreadNameFromToCopy(thisStep.getName(),s,nextStep.getName(),t);
rowsets.add(rowSet);
if (log.isDetailed()) log.logDetailed(toString(),Messages.getString("Trans.TransformationAllocatedNewRowset",rowSet.toString()));
}
}
}
}
log.logDetailed(toString(),Messages.getString("Trans.Log.AllocatedRowsets",String.valueOf(rowsets.size()),String.valueOf(i),thisStep.getName()) + " ");
}
if (log.isDetailed()) log.logDetailed(toString(),Messages.getString("Trans.Log.AllocatingStepsAndStepData"));
for (int i=0; i < hopsteps.size(); i++) {
StepMeta stepMeta=hopsteps.get(i);
String stepid=stepMeta.getStepID();
if (log.isDetailed()) log.logDetailed(toString(),Messages.getString("Trans.Log.TransformationIsToAllocateStep",stepMeta.getName(),stepid));
int nrCopies=stepMeta.getCopies();
if (log.isDebug()) log.logDebug(toString(),Messages.getString("Trans.Log.StepHasNumberRowCopies",String.valueOf(nrCopies)));
for (int c=0; c < nrCopies; c++) {
if (!hasStepStarted(stepMeta.getName(),c)) {
StepMetaDataCombi combi=new StepMetaDataCombi();
combi.stepname=stepMeta.getName();
combi.copy=c;
combi.stepMeta=stepMeta;
combi.meta=stepMeta.getStepMetaInterface();
StepDataInterface data=combi.meta.getStepData();
combi.data=data;
StepInterface step=combi.meta.getStep(stepMeta,data,c,transMeta,this);
((BaseStep)step).initializeVariablesFrom(this);
((BaseStep)step).setUsingThreadPriorityManagment(transMeta.isUsingThreadPriorityManagment());
if (stepMeta.isPartitioned()) {
List<String> partitionIDs=stepMeta.getStepPartitioningMeta().getPartitionSchema().getPartitionIDs();
if (partitionIDs != null && partitionIDs.size() > 0) {
step.setPartitionID(partitionIDs.get(c));
}
}
((BaseStep)step).setSafeModeEnabled(safeModeEnabled);
combi.step=step;
steps.add(combi);
if (log.isDetailed()) log.logDetailed(toString(),Messages.getString("Trans.Log.TransformationHasAllocatedANewStep",stepMeta.getName(),String.valueOf(c)));
}
}
}
for (int s=0; s < steps.size(); s++) {
StepMetaDataCombi combi=steps.get(s);
if (combi.stepMeta.isDoingErrorHandling()) {
StepErrorMeta stepErrorMeta=combi.stepMeta.getStepErrorMeta();
BaseStep baseStep=(BaseStep)combi.step;
boolean stop=false;
for (int rowsetNr=0; rowsetNr < baseStep.outputRowSets.size() && !stop; rowsetNr++) {
RowSet outputRowSet=baseStep.outputRowSets.get(rowsetNr);
if (outputRowSet.getDestinationStepName().equalsIgnoreCase(stepErrorMeta.getTargetStep().getName())) {
baseStep.errorRowSet=outputRowSet;
baseStep.outputRowSets.remove(rowsetNr);
stop=true;
}
}
}
}
beginProcessing();
for (int i=0; i < steps.size(); i++) {
StepMetaDataCombi sid=steps.get(i);
StepMeta stepMeta=sid.stepMeta;
BaseStep baseStep=(BaseStep)sid.step;
baseStep.setPartitioned(stepMeta.isPartitioned());
boolean isThisPartitioned=stepMeta.isPartitioned();
PartitionSchema thisPartitionSchema=null;
if (isThisPartitioned) thisPartitionSchema=stepMeta.getStepPartitioningMeta().getPartitionSchema();
boolean isNextPartitioned=false;
StepPartitioningMeta nextStepPartitioningMeta=null;
PartitionSchema nextPartitionSchema=null;
int nrNext=transMeta.findNrNextSteps(stepMeta);
for (int p=0; p < nrNext; p++) {
StepMeta nextStep=transMeta.findNextStep(stepMeta,p);
if (nextStep.isPartitioned()) {
isNextPartitioned=true;
nextStepPartitioningMeta=nextStep.getStepPartitioningMeta();
nextPartitionSchema=nextStepPartitioningMeta.getPartitionSchema();
}
}
baseStep.setRepartitioning(StepPartitioningMeta.PARTITIONING_METHOD_NONE);
if ((!isThisPartitioned && isNextPartitioned) || (isThisPartitioned && isNextPartitioned && !thisPartitionSchema.equals(nextPartitionSchema))) {
baseStep.setRepartitioning(nextStepPartitioningMeta.getMethodType());
}
}
preparing=false;
initializing=true;
log.logBasic(toString(),Messages.getString("Trans.Log.InitialisingSteps",String.valueOf(steps.size())));
StepInitThread initThreads[]=new StepInitThread[steps.size()];
Thread[] threads=new Thread[steps.size()];
for (int i=0; i < steps.size(); i++) {
final StepMetaDataCombi sid=steps.get(i);
initThreads[i]=new StepInitThread(sid,log);
threads[i]=new Thread(initThreads[i]);
threads[i].setName("init of " + sid.stepname + "."+ sid.copy+ " ("+ threads[i].getName()+ ")");
threads[i].start();
}
for (int i=0; i < threads.length; i++) {
try {
threads[i].join();
}
 catch (Exception ex) {
log.logError("Error with init thread: " + ex.getMessage(),ex.getMessage());
log.logError(toString(),Const.getStackTracker(ex));
}
}
initializing=false;
boolean ok=true;
for (int i=0; i < initThreads.length; i++) {
StepMetaDataCombi combi=initThreads[i].getCombi();
if (!initThreads[i].isOk()) {
log.logError(toString(),Messages.getString("Trans.Log.StepFailedToInit",combi.stepname + "." + combi.copy));
combi.data.setStatus(StepDataInterface.STATUS_STOPPED);
ok=false;
}
 else {
combi.data.setStatus(StepDataInterface.STATUS_IDLE);
if (log.isDetailed()) log.logDetailed(toString(),Messages.getString("Trans.Log.StepInitialized",combi.stepname + "." + combi.copy));
}
}
if (!ok) {
for (int i=0; i < initThreads.length; i++) {
StepMetaDataCombi combi=initThreads[i].getCombi();
combi.step.dispose(combi.meta,combi.data);
if (initThreads[i].isOk()) {
combi.data.setStatus(StepDataInterface.STATUS_HALTED);
}
 else {
combi.data.setStatus(StepDataInterface.STATUS_STOPPED);
}
}
throw new KettleException(Messages.getString("Trans.Log.FailToInitializeAtLeastOneStep"));
}
readyToStart=true;
}
