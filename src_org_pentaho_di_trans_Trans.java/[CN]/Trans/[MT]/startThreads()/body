{
  nrOfFinishedSteps=0;
  for (int i=0; i < steps.size(); i++) {
    final StepMetaDataCombi sid=steps.get(i);
    sid.step.markStart();
    sid.step.initBeforeStart();
    StepListener stepListener=new StepListener(){
      public void stepFinished(      Trans trans,      StepMeta stepMeta,      StepInterface step){
synchronized (Trans.this) {
          nrOfFinishedSteps++;
          if (nrOfFinishedSteps >= steps.size()) {
            finished.set(true);
            addStepPerformanceSnapShot();
            try {
              fireTransFinishedListeners();
            }
 catch (            Exception e) {
              step.setErrors(step.getErrors() + 1L);
              log.logError(getName(),BaseMessages.getString(PKG,"Trans.Log.UnexpectedErrorAtTransformationEnd"));
            }
          }
          if (step.getErrors() > 0) {
            log.logMinimal(getName(),BaseMessages.getString(PKG,"Trans.Log.TransformationDetectedErrors"));
            log.logMinimal(getName(),BaseMessages.getString(PKG,"Trans.Log.TransformationIsKillingTheOtherSteps"));
            killAllNoWait();
          }
        }
      }
    }
;
    sid.step.addStepListener(stepListener);
  }
  if (transMeta.isCapturingStepPerformanceSnapShots()) {
    stepPerformanceSnapshotSeqNr=new AtomicInteger(0);
    stepPerformanceSnapShots=new HashMap<String,List<StepPerformanceSnapShot>>();
    stepPerformanceSnapShotTimer=new Timer();
    TimerTask timerTask=new TimerTask(){
      public void run(){
        addStepPerformanceSnapShot();
      }
    }
;
    stepPerformanceSnapShotTimer.schedule(timerTask,100,transMeta.getStepPerformanceCapturingDelay());
  }
  finished.set(false);
  paused.set(false);
  stopped.set(false);
  TransListener transListener=new TransListener(){
    public void transFinished(    Trans trans){
      if (transMeta.isCapturingStepPerformanceSnapShots() && stepPerformanceSnapShotTimer != null) {
        stepPerformanceSnapShotTimer.cancel();
      }
      finished.set(true);
      running=false;
    }
  }
;
  addTransListener(transListener);
  running=true;
  for (int i=0; i < steps.size(); i++) {
    steps.get(i).step.start();
  }
  if (log.isDetailed())   log.logDetailed(BaseMessages.getString(PKG,"Trans.Log.TransformationHasAllocated",String.valueOf(steps.size()),String.valueOf(rowsets.size())));
}
