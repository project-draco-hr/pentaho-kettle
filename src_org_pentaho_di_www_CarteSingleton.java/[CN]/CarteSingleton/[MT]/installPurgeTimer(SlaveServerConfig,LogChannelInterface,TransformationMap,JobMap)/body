{
  final int objectTimeout;
  String systemTimeout=EnvUtil.getSystemProperty(Const.KETTLE_CARTE_OBJECT_TIMEOUT_MINUTES,null);
  if (config.getObjectTimeoutMinutes() > 0) {
    objectTimeout=config.getObjectTimeoutMinutes();
  }
 else   if (!Const.isEmpty(systemTimeout)) {
    objectTimeout=Const.toInt(systemTimeout,1440);
  }
 else {
    objectTimeout=24 * 60;
  }
  if (objectTimeout > 0) {
    log.logBasic("Installing timer to purge stale objects after " + objectTimeout + " minutes.");
    Timer timer=new Timer(true);
    final AtomicBoolean busy=new AtomicBoolean(false);
    TimerTask timerTask=new TimerTask(){
      public void run(){
        if (!busy.get()) {
          busy.set(true);
          try {
            for (            CarteObjectEntry entry : transformationMap.getTransformationObjects()) {
              Trans trans=transformationMap.getTransformation(entry);
              if (trans != null && (trans.isFinished() || trans.isStopped()) && trans.getLogDate() != null) {
                int diffInMinutes=(int)Math.floor((System.currentTimeMillis() - trans.getLogDate().getTime()) / 60000);
                if (diffInMinutes >= config.getObjectTimeoutMinutes()) {
                  transformationMap.removeTransformation(entry);
                  transformationMap.deallocateServerSocketPorts(entry);
                }
              }
            }
            for (            CarteObjectEntry entry : jobMap.getJobObjects()) {
              Job job=jobMap.getJob(entry);
              if (job != null && (job.isFinished() || job.isStopped()) && job.getLogDate() != null) {
                int diffInMinutes=(int)Math.floor((System.currentTimeMillis() - job.getLogDate().getTime()) / 60000);
                if (diffInMinutes >= config.getObjectTimeoutMinutes()) {
                  jobMap.removeJob(entry);
                }
              }
            }
          }
  finally {
            busy.set(false);
          }
        }
      }
    }
;
    timer.schedule(timerTask,20000,20000);
  }
}
