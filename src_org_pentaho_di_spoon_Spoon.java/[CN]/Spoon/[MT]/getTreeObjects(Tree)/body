{
  List<TreeSelection> objects=new ArrayList<TreeSelection>();
  if (tree.equals(selectionTree)) {
    TreeItem[] selection=selectionTree.getSelection();
    for (int s=0; s < selection.length; s++) {
      TreeItem treeItem=selection[s];
      String[] path=Const.getTreeStrings(treeItem);
      TreeSelection object=null;
switch (path.length) {
case 0:
        break;
case 1:
      if (path[0].equals(STRING_TRANSFORMATIONS)) {
        object=new TreeSelection(path[0],TransMeta.class);
      }
    if (path[0].equals(STRING_JOBS)) {
      object=new TreeSelection(path[0],JobMeta.class);
    }
  break;
case 2:
if (path[0].equals(STRING_BUILDING_BLOCKS)) {
  if (path[1].equals(STRING_TRANS_BASE)) {
    object=new TreeSelection(path[1],StepPlugin.class);
  }
}
if (path[0].equals(STRING_TRANSFORMATIONS)) {
object=new TreeSelection(path[1],findTransformation(path[1]));
}
if (path[0].equals(STRING_JOBS)) {
object=new TreeSelection(path[1],findJob(path[1]));
}
break;
case 3:
if (path[0].equals(STRING_TRANSFORMATIONS)) {
TransMeta transMeta=findTransformation(path[1]);
if (path[2].equals(STRING_CONNECTIONS)) object=new TreeSelection(path[2],DatabaseMeta.class,transMeta);
if (path[2].equals(STRING_STEPS)) object=new TreeSelection(path[2],StepMeta.class,transMeta);
if (path[2].equals(STRING_HOPS)) object=new TreeSelection(path[2],TransHopMeta.class,transMeta);
if (path[2].equals(STRING_PARTITIONS)) object=new TreeSelection(path[2],PartitionSchema.class,transMeta);
if (path[2].equals(STRING_SLAVES)) object=new TreeSelection(path[2],SlaveServer.class,transMeta);
if (path[2].equals(STRING_CLUSTERS)) object=new TreeSelection(path[2],ClusterSchema.class,transMeta);
}
if (path[0].equals(STRING_JOBS)) {
JobMeta jobMeta=findJob(path[1]);
if (path[2].equals(STRING_CONNECTIONS)) object=new TreeSelection(path[2],DatabaseMeta.class,jobMeta);
if (path[2].equals(STRING_JOB_ENTRIES)) object=new TreeSelection(path[2],JobEntryCopy.class,jobMeta);
}
break;
case 4:
if (path[0].equals(STRING_TRANSFORMATIONS)) {
TransMeta transMeta=findTransformation(path[1]);
if (path[2].equals(STRING_CONNECTIONS)) object=new TreeSelection(path[3],transMeta.findDatabase(path[3]),transMeta);
if (path[2].equals(STRING_STEPS)) object=new TreeSelection(path[3],transMeta.findStep(path[3]),transMeta);
if (path[2].equals(STRING_HOPS)) object=new TreeSelection(path[3],transMeta.findTransHop(path[3]),transMeta);
if (path[2].equals(STRING_PARTITIONS)) object=new TreeSelection(path[3],transMeta.findPartitionSchema(path[3]),transMeta);
if (path[2].equals(STRING_SLAVES)) object=new TreeSelection(path[3],transMeta.findSlaveServer(path[3]),transMeta);
if (path[2].equals(STRING_CLUSTERS)) object=new TreeSelection(path[3],transMeta.findClusterSchema(path[3]),transMeta);
}
if (path[0].equals(STRING_JOBS)) {
JobMeta jobMeta=findJob(path[1]);
if (jobMeta != null && path[2].equals(STRING_CONNECTIONS)) object=new TreeSelection(path[3],jobMeta.findDatabase(path[3]),jobMeta);
if (jobMeta != null && path[2].equals(STRING_JOB_ENTRIES)) object=new TreeSelection(path[3],jobMeta.findJobEntry(path[3]),jobMeta);
}
break;
case 5:
if (path[0].equals(STRING_TRANSFORMATIONS)) {
TransMeta transMeta=findTransformation(path[1]);
if (transMeta != null && path[2].equals(STRING_CLUSTERS)) {
ClusterSchema clusterSchema=transMeta.findClusterSchema(path[3]);
object=new TreeSelection(path[4],clusterSchema.findSlaveServer(path[4]),clusterSchema,transMeta);
}
}
break;
default :
break;
}
if (object != null) {
objects.add(object);
}
}
}
if (tree.equals(coreObjectsTree)) {
TreeItem[] selection=coreObjectsTree.getSelection();
for (int s=0; s < selection.length; s++) {
TreeItem treeItem=selection[s];
String[] path=Const.getTreeStrings(treeItem);
TreeSelection object=null;
switch (path.length) {
case 0:
break;
case 1:
break;
case 2:
if (path[0].equals(STRING_JOB_BASE)) {
JobPlugin jobPlugin=JobEntryLoader.getInstance().findJobEntriesWithDescription(path[1]);
if (jobPlugin != null) {
object=new TreeSelection(path[1],jobPlugin);
}
 else {
object=new TreeSelection(path[1],JobPlugin.class);
}
}
break;
case 3:
if (path[0].equals(STRING_TRANS_BASE)) {
object=new TreeSelection(path[2],StepLoader.getInstance().findStepPluginWithDescription(path[2]));
}
break;
default :
break;
}
if (object != null) {
objects.add(object);
}
}
}
return objects.toArray(new TreeSelection[objects.size()]);
}
