{
  debug="fillRow start";
  Row r=new Row(baserow);
  boolean errorHandled=false;
  for (int i=startcolumn; i < excelInputRow.cells.length && i - startcolumn < r.size(); i++) {
    debug="get cell #" + i;
    Cell cell=excelInputRow.cells[i];
    int rowcolumn=i - startcolumn;
    debug="Rowcolumn = " + rowcolumn;
    Value v=r.getValue(rowcolumn);
    debug="Value v = " + v;
    try {
      checkType(cell,v);
    }
 catch (    KettleException ex) {
      if (!meta.isErrorIgnored())       throw ex;
      logBasic("Warning processing [" + debug + "] from Excel file ["+ data.filename+ "] : "+ ex.getMessage());
      if (!errorHandled) {
        data.errorHandler.handleLineError(excelInputRow.rownr,excelInputRow.sheetName);
        errorHandled=true;
      }
      if (meta.isErrorLineSkipped()) {
        r.setIgnore();
        return r;
      }
    }
    if (cell.getType().equals(CellType.BOOLEAN)) {
      v.setValue(((BooleanCell)cell).getValue());
    }
 else {
      if (cell.getType().equals(CellType.DATE)) {
        Date date=((DateCell)cell).getDate();
        long time=date.getTime();
        int offset=TimeZone.getDefault().getOffset(time);
        v.setValue(new Date(time - offset));
      }
 else {
        if (cell.getType().equals(CellType.LABEL)) {
          v.setValue(((LabelCell)cell).getString());
switch (meta.getField()[rowcolumn].getTrimType()) {
case ExcelInputMeta.TYPE_TRIM_LEFT:
            v.ltrim();
          break;
case ExcelInputMeta.TYPE_TRIM_RIGHT:
        v.rtrim();
      break;
case ExcelInputMeta.TYPE_TRIM_BOTH:
    v.trim();
  break;
default :
break;
}
}
 else {
if (cell.getType().equals(CellType.NUMBER)) {
v.setValue(((NumberCell)cell).getValue());
}
 else {
if (log.isDetailed()) logDetailed("Unknown type : " + cell.getType().toString() + " : ["+ cell.getContents()+ "]");
v.setNull();
}
}
}
}
ExcelInputField field=meta.getField()[rowcolumn];
try {
if (v.getType() != field.getType()) {
switch (v.getType()) {
case Value.VALUE_TYPE_STRING:
debug="Convert string to date/number";
switch (field.getType()) {
case Value.VALUE_TYPE_DATE:
v.str2dat(field.getFormat());
break;
case Value.VALUE_TYPE_NUMBER:
v.str2num(field.getFormat(),field.getDecimalSymbol(),field.getGroupSymbol(),field.getCurrencySymbol());
break;
default :
v.setType(field.getType());
break;
}
break;
case Value.VALUE_TYPE_NUMBER:
case Value.VALUE_TYPE_INTEGER:
debug="Convert number to string";
switch (field.getType()) {
case Value.VALUE_TYPE_STRING:
v.num2str(field.getFormat(),field.getDecimalSymbol(),field.getGroupSymbol(),field.getCurrencySymbol());
break;
case Value.VALUE_TYPE_DATE:
v.num2str("#").str2dat(field.getFormat());
break;
default :
v.setType(field.getType());
break;
}
break;
case Value.VALUE_TYPE_DATE:
debug="Convert date to string";
switch (field.getType()) {
case Value.VALUE_TYPE_STRING:
v.dat2str(field.getFormat());
break;
default :
v.setType(field.getType());
break;
}
break;
default :
v.setType(field.getType());
}
}
}
 catch (KettleException ex) {
if (!meta.isErrorIgnored()) throw ex;
logBasic("Warning processing [" + debug + "] from Excel file ["+ data.filename+ "] : "+ ex.toString());
if (!errorHandled) {
data.errorHandler.handleLineError(excelInputRow.rownr,excelInputRow.sheetName);
errorHandled=true;
}
if (meta.isErrorLineSkipped()) {
r.setIgnore();
return r;
}
 else {
v.setNull();
}
}
v.setLength(meta.getField()[rowcolumn].getLength(),meta.getField()[rowcolumn].getPrecision());
}
debug="filename";
if (meta.getFileField() != null && meta.getFileField().length() > 0) {
Value value=new Value(meta.getFileField(),data.filename);
value.setLength(data.maxfilelength);
r.addValue(value);
}
debug="sheetname";
if (meta.getSheetField() != null && meta.getSheetField().length() > 0) {
Value value=new Value(meta.getSheetField(),excelInputRow.sheetName);
value.setLength(data.maxsheetlength);
r.addValue(value);
}
debug="rownumber";
if (meta.getRowNumberField() != null && meta.getRowNumberField().length() > 0) {
Value value=new Value(meta.getRowNumberField(),linesWritten + 1);
r.addValue(value);
}
debug="end of fillRow";
return r;
}
