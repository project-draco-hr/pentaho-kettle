{
  clear();
  findUsedOriginalSteps();
  checkClusterConfiguration();
  generateSlavePartitionSchemas();
  try {
    SlaveServer masterServer=getMasterServer();
    master=getOriginalCopy(false,null,null);
    for (int r=0; r < referenceSteps.length; r++) {
      StepMeta referenceStep=referenceSteps[r];
      ClusterSchema referenceClusterSchema=referenceStep.getClusterSchema();
      int nrPreviousSteps=originalTransformation.findNrPrevSteps(referenceStep);
      for (int p=0; p < nrPreviousSteps; p++) {
        StepMeta previousStep=originalTransformation.findPrevStep(referenceStep,p);
        ClusterSchema previousClusterSchema=previousStep.getClusterSchema();
        if (referenceClusterSchema == null) {
          if (previousClusterSchema == null) {
            StepMeta target=master.findStep(referenceStep.getName());
            if (target == null) {
              target=(StepMeta)referenceStep.clone();
              master.addStep(target);
            }
            StepMeta source=master.findStep(previousStep.getName());
            if (source == null) {
              source=(StepMeta)previousStep.clone();
              master.addStep(source);
            }
            TransHopMeta masterHop=new TransHopMeta(source,target);
            master.addTransHop(masterHop);
          }
 else {
            StepMeta masterStep=master.findStep(referenceStep.getName());
            if (masterStep == null) {
              masterStep=(StepMeta)referenceStep.clone();
              masterStep.setLocation(masterStep.getLocation().x,masterStep.getLocation().y);
              master.addStep(masterStep);
            }
            int slaveStepCopyNr=-1;
            int nrSlaves=previousClusterSchema.getSlaveServers().size();
            for (int slaveNr=0; slaveNr < nrSlaves; slaveNr++) {
              SlaveServer slaveServer=(SlaveServer)previousClusterSchema.getSlaveServers().get(slaveNr);
              if (!slaveServer.isMaster()) {
                slaveStepCopyNr++;
                TransMeta slave=getSlaveTransformation(previousClusterSchema,slaveServer);
                StepMeta slaveStep=slave.findStep(previousStep.getName());
                if (slaveStep == null) {
                  slaveStep=addSlaveCopy(slave,previousStep,slaveServer);
                }
                int nrOfSourceCopies=slaveStep.getCopies();
                if (masterStep.getCopies() != 1 && masterStep.getCopies() != (referenceClusterSchema.findNrSlaves() * nrOfSourceCopies)) {
                  throw new KettleException("The number of step copies on the master has to be 1 or equal to the number of slaves (" + referenceClusterSchema.findNrSlaves() + ") to work.  Note that you can insert a dummy step to make the transformation work as desired.");
                }
                Map<PartitionSchema,List<String>> partitionsMap=slaveServerPartitionsMap.get(slaveServer);
                StepPartitioningMeta previousStepPartitioningMeta=previousStep.getStepPartitioningMeta();
                PartitionSchema previousPartitionSchema=previousStepPartitioningMeta.getPartitionSchema();
                int nrOfPreviousPartitions=1;
                if (slaveStep.isPartitioned() && previousPartitionSchema != null) {
                  List<String> sourcePartitionsList=partitionsMap.get(previousPartitionSchema);
                  nrOfPreviousPartitions=sourcePartitionsList.size();
                }
                for (int sourceCopyNr=0; sourceCopyNr < (nrOfPreviousPartitions * nrOfSourceCopies); sourceCopyNr++) {
                  slaveStepCopyNr+=sourceCopyNr;
                  if (masterStep.getCopies() == 1) {
                    slaveStepCopyNr=0;
                  }
                  int port=getPort(previousClusterSchema,slaveServer,slaveServer + "-" + masterStep.getName()+ "."+ slaveStepCopyNr+ " --> "+ slaveStep.getName()+ "."+ sourceCopyNr);
                  RemoteStep remoteMasterStep=new RemoteStep(slaveServer.getHostname(),masterServer.getHostname(),Integer.toString(port),slaveStep.getName(),sourceCopyNr,masterStep.getName(),slaveStepCopyNr,masterServer.getName(),socketsBufferSize,compressingSocketStreams);
                  slaveStep.getRemoteOutputSteps().add(remoteMasterStep);
                  RemoteStep remoteSlaveStep=new RemoteStep(slaveServer.getHostname(),masterServer.getHostname(),Integer.toString(port),slaveStep.getName(),sourceCopyNr,masterStep.getName(),slaveStepCopyNr,masterServer.getName(),socketsBufferSize,compressingSocketStreams);
                  masterStep.getRemoteInputSteps().add(remoteSlaveStep);
                  if (slaveStep.isPartitioned()) {
                    slaveStepCopyPartitionDistribution.addPartition(slaveServer.getName(),previousPartitionSchema.getName(),sourceCopyNr);
                  }
                }
                if (previousStepPartitioningMeta.isPartitioned()) {
                  StepPartitioningMeta stepPartitioningMeta=previousStepPartitioningMeta.clone();
                  PartitionSchema partitionSchema=stepPartitioningMeta.getPartitionSchema();
                  partitionSchema.setName(createTargetPartitionSchemaName(partitionSchema.getName()));
                  if (partitionSchema.isDynamicallyDefined()) {
                    partitionSchema.expandPartitionsDynamically(previousClusterSchema.findNrSlaves(),originalTransformation);
                  }
                  masterStep.setTargetStepPartitioningMeta(stepPartitioningMeta);
                  master.addOrReplacePartitionSchema(partitionSchema);
                  stepPartitioningMeta=previousStepPartitioningMeta.clone();
                  partitionSchema=stepPartitioningMeta.getPartitionSchema();
                  partitionSchema.setName(createSlavePartitionSchemaName(partitionSchema.getName()));
                  if (partitionSchema.isDynamicallyDefined()) {
                    partitionSchema.expandPartitionsDynamically(previousClusterSchema.findNrSlaves(),originalTransformation);
                  }
                  partitionSchema.retainPartitionsForSlaveServer(referenceClusterSchema.findNrSlaves(),getSlaveServerNumber(referenceClusterSchema,slaveServer));
                  slave.addOrReplacePartitionSchema(partitionSchema);
                }
              }
            }
          }
        }
 else {
          if (previousClusterSchema == null) {
            int masterStepCopyNr=-1;
            int nrSlaves=referenceClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)referenceClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                masterStepCopyNr++;
                StepMeta masterStep=master.findStep(previousStep.getName());
                if (masterStep == null) {
                  masterStep=(StepMeta)previousStep.clone();
                  masterStep.setLocation(previousStep.getLocation().x,previousStep.getLocation().y);
                  master.addStep(masterStep);
                }
                int nrOfTargetCopies=referenceStep.getCopies();
                if (masterStep.getCopies() != 1 && masterStep.getCopies() != (referenceClusterSchema.findNrSlaves() * nrOfTargetCopies)) {
                  throw new KettleException("The number of step copies on the master has to be 1 or equal to the number of slaves (" + referenceClusterSchema.findNrSlaves() + ") to work.  Note that you can insert a dummy step to make the transformation work as desired.");
                }
                TransMeta slave=getSlaveTransformation(referenceClusterSchema,slaveServer);
                StepMeta slaveStep=slave.findStep(referenceStep.getName());
                if (slaveStep == null) {
                  slaveStep=addSlaveCopy(slave,referenceStep,slaveServer);
                }
                Map<PartitionSchema,List<String>> partitionsMap=slaveServerPartitionsMap.get(slaveServer);
                StepPartitioningMeta targetStepPartitioningMeta=referenceStep.getStepPartitioningMeta();
                PartitionSchema targetPartitionSchema=targetStepPartitioningMeta.getPartitionSchema();
                int nrOfTargetPartitions=1;
                if (slaveStep.isPartitioned() && targetPartitionSchema != null) {
                  List<String> targetPartitionsList=partitionsMap.get(targetPartitionSchema);
                  nrOfTargetPartitions=targetPartitionsList.size();
                }
                for (int targetCopyNr=0; targetCopyNr < (nrOfTargetPartitions * nrOfTargetCopies); targetCopyNr++) {
                  masterStepCopyNr+=targetCopyNr;
                  if (masterStep.getCopies() == 1) {
                    masterStepCopyNr=0;
                  }
                  int port=getPort(referenceClusterSchema,slaveServer,slaveServer + "-" + masterStep.getName()+ "."+ masterStepCopyNr+ " --> "+ slaveStep.getName()+ "."+ targetCopyNr);
                  RemoteStep remoteMasterStep=new RemoteStep(slaveServer.getHostname(),masterServer.getHostname(),Integer.toString(port),masterStep.getName(),masterStepCopyNr,referenceStep.getName(),targetCopyNr,slaveServer.getName(),socketsBufferSize,compressingSocketStreams);
                  masterStep.getRemoteOutputSteps().add(remoteMasterStep);
                  RemoteStep remoteSlaveStep=new RemoteStep(masterServer.getHostname(),slaveServer.getHostname(),Integer.toString(port),masterStep.getName(),masterStepCopyNr,referenceStep.getName(),targetCopyNr,masterServer.getName(),socketsBufferSize,compressingSocketStreams);
                  slaveStep.getRemoteInputSteps().add(remoteSlaveStep);
                  if (slaveStep.isPartitioned()) {
                    slaveStepCopyPartitionDistribution.addPartition(slaveServer.getName(),targetPartitionSchema.getName(),targetCopyNr);
                  }
                }
                if (targetStepPartitioningMeta.isPartitioned()) {
                  StepPartitioningMeta stepPartitioningMeta=targetStepPartitioningMeta.clone();
                  PartitionSchema partitionSchema=stepPartitioningMeta.getPartitionSchema();
                  partitionSchema.setName(createTargetPartitionSchemaName(partitionSchema.getName()));
                  if (partitionSchema.isDynamicallyDefined()) {
                    partitionSchema.expandPartitionsDynamically(referenceClusterSchema.findNrSlaves(),originalTransformation);
                  }
                  masterStep.setTargetStepPartitioningMeta(stepPartitioningMeta);
                  master.addOrReplacePartitionSchema(partitionSchema);
                  stepPartitioningMeta=targetStepPartitioningMeta.clone();
                  partitionSchema=stepPartitioningMeta.getPartitionSchema();
                  partitionSchema.setName(createSlavePartitionSchemaName(partitionSchema.getName()));
                  if (partitionSchema.isDynamicallyDefined()) {
                    partitionSchema.expandPartitionsDynamically(referenceClusterSchema.findNrSlaves(),originalTransformation);
                  }
                  partitionSchema.retainPartitionsForSlaveServer(referenceClusterSchema.findNrSlaves(),getSlaveServerNumber(referenceClusterSchema,slaveServer));
                  slave.addOrReplacePartitionSchema(partitionSchema);
                }
              }
            }
          }
 else {
            int nrSlaves=referenceClusterSchema.getSlaveServers().size();
            for (int slaveNr=0; slaveNr < nrSlaves; slaveNr++) {
              SlaveServer slaveServer=referenceClusterSchema.getSlaveServers().get(slaveNr);
              if (!slaveServer.isMaster()) {
                TransMeta slave=getSlaveTransformation(referenceClusterSchema,slaveServer);
                StepMeta target=slave.findStep(referenceStep.getName());
                if (target == null) {
                  target=addSlaveCopy(slave,referenceStep,slaveServer);
                }
                StepMeta source=slave.findStep(previousStep.getName());
                if (source == null) {
                  source=addSlaveCopy(slave,previousStep,slaveServer);
                }
                TransHopMeta slaveHop=new TransHopMeta(source,target);
                slave.addTransHop(slaveHop);
                StepPartitioningMeta sourceStepPartitioningMeta=previousStep.getStepPartitioningMeta();
                StepPartitioningMeta targetStepPartitioningMeta=referenceStep.getStepPartitioningMeta();
                if (previousStep.isPartitioned() && referenceStep.isPartitioned() && sourceStepPartitioningMeta.equals(targetStepPartitioningMeta)) {
                  StepPartitioningMeta stepPartitioningMeta=sourceStepPartitioningMeta.clone();
                  PartitionSchema partitionSchema=stepPartitioningMeta.getPartitionSchema();
                  partitionSchema.setName(createSlavePartitionSchemaName(partitionSchema.getName()));
                  if (partitionSchema.isDynamicallyDefined()) {
                    partitionSchema.expandPartitionsDynamically(referenceClusterSchema.findNrSlaves(),originalTransformation);
                  }
                  partitionSchema.retainPartitionsForSlaveServer(referenceClusterSchema.findNrSlaves(),getSlaveServerNumber(referenceClusterSchema,slaveServer));
                  source.setStepPartitioningMeta(stepPartitioningMeta);
                  target.setStepPartitioningMeta(stepPartitioningMeta);
                  slave.addOrReplacePartitionSchema(partitionSchema);
                }
 else                 if ((!previousStep.isPartitioned() && referenceStep.isPartitioned()) || (previousStep.isPartitioned() && referenceStep.isPartitioned() && !sourceStepPartitioningMeta.equals(target.getStepPartitioningMeta()))) {
                  PartitionSchema targetPartitionSchema=targetStepPartitioningMeta.getPartitionSchema();
                  PartitionSchema sourcePartitionSchema=sourceStepPartitioningMeta.getPartitionSchema();
                  for (int partSlaveNr=0; partSlaveNr < referenceClusterSchema.getSlaveServers().size(); partSlaveNr++) {
                    SlaveServer partSlaveServer=referenceClusterSchema.getSlaveServers().get(partSlaveNr);
                    if (!partSlaveServer.isMaster()) {
                      Map<PartitionSchema,List<String>> partitionsMap=slaveServerPartitionsMap.get(partSlaveServer);
                      int nrOfTargetPartitions=1;
                      if (target.isPartitioned() && targetPartitionSchema != null) {
                        List<String> targetPartitionsList=partitionsMap.get(targetPartitionSchema);
                        nrOfTargetPartitions=targetPartitionsList.size();
                      }
                      int nrOfSourcePartitions=1;
                      if (source.isPartitioned() && sourcePartitionSchema != null) {
                        List<String> sourcePartitionsList=partitionsMap.get(sourcePartitionSchema);
                        nrOfSourcePartitions=sourcePartitionsList.size();
                      }
                      for (int sourceCopyNr=0; sourceCopyNr < nrOfSourcePartitions; sourceCopyNr++) {
                        for (int targetCopyNr=0; targetCopyNr < nrOfTargetPartitions; targetCopyNr++) {
                          if (!slaveServer.equals(partSlaveServer)) {
                            int outPort=getPort(referenceClusterSchema,slaveServer,partSlaveServer + "-" + source.getName()+ "."+ sourceCopyNr+ " --> "+ target.getName()+ "."+ targetCopyNr);
                            RemoteStep remoteOutputStep=new RemoteStep(slaveServer.getHostname(),partSlaveServer.getHostname(),Integer.toString(outPort),source.getName(),sourceCopyNr,target.getName(),targetCopyNr,partSlaveServer.getName(),socketsBufferSize,compressingSocketStreams);
                            source.getRemoteOutputSteps().add(remoteOutputStep);
                            int inPort=getPort(referenceClusterSchema,partSlaveServer,slaveServer + "-" + source.getName()+ "."+ sourceCopyNr+ " --> "+ target.getName()+ "."+ targetCopyNr);
                            RemoteStep remoteInputStep=new RemoteStep(partSlaveServer.getHostname(),slaveServer.getHostname(),Integer.toString(inPort),source.getName(),sourceCopyNr,target.getName(),targetCopyNr,partSlaveServer.getName(),socketsBufferSize,compressingSocketStreams);
                            target.getRemoteInputSteps().add(remoteInputStep);
                          }
                          slaveStepCopyPartitionDistribution.addPartition(partSlaveServer.getName(),targetPartitionSchema.getName(),targetCopyNr);
                        }
                      }
                      if (sourceStepPartitioningMeta.isPartitioned()) {
                        StepPartitioningMeta stepPartitioningMeta=sourceStepPartitioningMeta.clone();
                        PartitionSchema partitionSchema=stepPartitioningMeta.getPartitionSchema();
                        partitionSchema.setName(createSlavePartitionSchemaName(partitionSchema.getName()));
                        if (partitionSchema.isDynamicallyDefined()) {
                          partitionSchema.expandPartitionsDynamically(referenceClusterSchema.findNrSlaves(),originalTransformation);
                        }
                        partitionSchema.retainPartitionsForSlaveServer(referenceClusterSchema.findNrSlaves(),getSlaveServerNumber(referenceClusterSchema,slaveServer));
                        source.setStepPartitioningMeta(stepPartitioningMeta);
                        slave.addOrReplacePartitionSchema(partitionSchema);
                      }
                      if (targetStepPartitioningMeta.isPartitioned()) {
                        StepPartitioningMeta stepPartitioningMeta=targetStepPartitioningMeta.clone();
                        PartitionSchema partitionSchema=stepPartitioningMeta.getPartitionSchema();
                        partitionSchema.setName(createSlavePartitionSchemaName(partitionSchema.getName()));
                        if (partitionSchema.isDynamicallyDefined()) {
                          partitionSchema.expandPartitionsDynamically(referenceClusterSchema.findNrSlaves(),originalTransformation);
                        }
                        partitionSchema.retainPartitionsForSlaveServer(referenceClusterSchema.findNrSlaves(),getSlaveServerNumber(referenceClusterSchema,slaveServer));
                        target.setStepPartitioningMeta(stepPartitioningMeta);
                        slave.addOrReplacePartitionSchema(partitionSchema);
                      }
                      if (!sourceStepPartitioningMeta.isPartitioned() || !sourceStepPartitioningMeta.equals(targetStepPartitioningMeta)) {
                        StepPartitioningMeta stepPartitioningMeta=targetStepPartitioningMeta.clone();
                        PartitionSchema partitionSchema=stepPartitioningMeta.getPartitionSchema();
                        partitionSchema.setName(createTargetPartitionSchemaName(partitionSchema.getName()));
                        if (partitionSchema.isDynamicallyDefined()) {
                          partitionSchema.expandPartitionsDynamically(referenceClusterSchema.findNrSlaves(),originalTransformation);
                        }
                        source.setTargetStepPartitioningMeta(stepPartitioningMeta);
                        slave.addOrReplacePartitionSchema(partitionSchema);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (nrPreviousSteps == 0) {
        if (referenceClusterSchema == null) {
          if (master.findStep(referenceStep.getName()) == null) {
            master.addStep((StepMeta)referenceStep.clone());
          }
        }
 else {
          int nrSlaves=referenceClusterSchema.getSlaveServers().size();
          for (int s=0; s < nrSlaves; s++) {
            SlaveServer slaveServer=(SlaveServer)referenceClusterSchema.getSlaveServers().get(s);
            if (!slaveServer.isMaster()) {
              TransMeta slave=getSlaveTransformation(referenceClusterSchema,slaveServer);
              if (slave.findStep(referenceStep.getName()) == null) {
                addSlaveCopy(slave,referenceStep,slaveServer);
              }
            }
          }
        }
      }
    }
    for (int i=0; i < referenceSteps.length; i++) {
      StepMeta originalStep=referenceSteps[i];
      ClusterSchema originalClusterSchema=originalStep.getClusterSchema();
      StepMeta infoSteps[]=originalTransformation.getInfoStep(originalStep);
      for (int p=0; infoSteps != null && p < infoSteps.length; p++) {
        StepMeta infoStep=infoSteps[p];
        ClusterSchema infoClusterSchema=infoStep.getClusterSchema();
        if (originalClusterSchema == null) {
          if (infoClusterSchema == null) {
            StepMeta target=master.findStep(originalStep.getName());
            StepMeta source=master.findStep(infoStep.getName());
            TransHopMeta masterHop=new TransHopMeta(source,target);
            master.addTransHop(masterHop);
          }
 else {
            int nrSlaves=infoClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)infoClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                TransMeta slave=getSlaveTransformation(infoClusterSchema,slaveServer);
                SocketWriterMeta socketWriterMeta=new SocketWriterMeta();
                int port=getPort(infoClusterSchema,slaveServer,infoStep.getName() + " - " + originalStep.getName());
                socketWriterMeta.setPort("" + port);
                socketWriterMeta.setBufferSize(infoClusterSchema.getSocketsBufferSize());
                socketWriterMeta.setFlushInterval(infoClusterSchema.getSocketsFlushInterval());
                socketWriterMeta.setCompressed(infoClusterSchema.isSocketsCompressed());
                StepMeta writerStep=new StepMeta(getWriterName(infoStep.getName(),infoClusterSchema,slaveServer),socketWriterMeta);
                writerStep.setLocation(infoStep.getLocation().x + 50,infoStep.getLocation().y + 50);
                writerStep.setDraw(true);
                slave.addStep(writerStep);
                TransHopMeta slaveHop=new TransHopMeta(infoStep,writerStep);
                if (slave.findTransHop(slaveHop) == null)                 slave.addTransHop(slaveHop);
                SocketReaderMeta socketReaderMeta=new SocketReaderMeta();
                socketReaderMeta.setPort("" + port);
                socketReaderMeta.setBufferSize(infoClusterSchema.getSocketsBufferSize());
                socketReaderMeta.setCompressed(infoClusterSchema.isSocketsCompressed());
                StepMeta readerStep=new StepMeta(getReaderName(infoStep.getName(),infoClusterSchema,slaveServer),socketReaderMeta);
                readerStep.setLocation(infoStep.getLocation().x,infoStep.getLocation().y + (s * FANOUT * 2) - (nrSlaves * FANOUT / 2));
                readerStep.setDraw(true);
                master.addStep(readerStep);
                String dummyName=infoStep.getName();
                StepMeta dummyStep=master.findStep(dummyName);
                if (dummyStep == null) {
                  DummyTransMeta dummy=new DummyTransMeta();
                  dummyStep=new StepMeta(dummyName,dummy);
                  dummyStep.setLocation(infoStep.getLocation().x + (SPLIT / 2),infoStep.getLocation().y);
                  dummyStep.setDraw(true);
                  dummyStep.setDescription("This step merges the data from the various data streams coming from the slave transformations.\nIt does that right before it hits the step that reads from a specific (info) step.");
                  master.addStep(dummyStep);
                  StepMeta masterTargetStep=master.findStep(originalStep.getName());
                  TransHopMeta targetHop=new TransHopMeta(dummyStep,masterTargetStep);
                  master.addTransHop(targetHop);
                  String infoStepNames[]=masterTargetStep.getStepMetaInterface().getInfoSteps();
                  if (infoStepNames != null) {
                    StepMeta is[]=new StepMeta[infoStepNames.length];
                    for (int n=0; n < infoStepNames.length; n++) {
                      is[n]=slave.findStep(infoStepNames[n]);
                      if (infoStepNames[n].equals(infoStep.getName())) {
                        infoSteps[n]=readerStep;
                      }
                    }
                    masterTargetStep.getStepMetaInterface().setInfoSteps(infoSteps);
                  }
                }
                TransHopMeta mergeHop=new TransHopMeta(readerStep,dummyStep);
                if (master.findTransHop(mergeHop) == null) {
                  master.addTransHop(mergeHop);
                }
              }
            }
          }
        }
 else {
          if (infoClusterSchema == null) {
            int nrSlaves=originalClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)originalClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                SocketWriterMeta socketWriterMeta=new SocketWriterMeta();
                socketWriterMeta.setPort("" + getPort(originalClusterSchema,slaveServer,infoStep.getName() + " - " + originalStep.getName()));
                socketWriterMeta.setBufferSize(originalClusterSchema.getSocketsBufferSize());
                socketWriterMeta.setFlushInterval(originalClusterSchema.getSocketsFlushInterval());
                socketWriterMeta.setCompressed(originalClusterSchema.isSocketsCompressed());
                StepMeta writerStep=new StepMeta(getWriterName(originalStep.getName(),originalClusterSchema,slaveServer),socketWriterMeta);
                writerStep.setLocation(originalStep.getLocation().x,originalStep.getLocation().y + (s * FANOUT * 2) - (nrSlaves * FANOUT / 2));
                writerStep.setDraw(originalStep.isDrawn());
                master.addStep(writerStep);
                StepMeta previous=master.findStep(infoStep.getName());
                if (previous == null) {
                  previous=(StepMeta)infoStep.clone();
                  master.addStep(previous);
                }
                TransHopMeta masterHop=new TransHopMeta(previous,writerStep);
                master.addTransHop(masterHop);
                TransMeta slave=getSlaveTransformation(originalClusterSchema,slaveServer);
                SocketReaderMeta socketReaderMeta=new SocketReaderMeta();
                socketReaderMeta.setHostname(masterServer.getHostname());
                socketReaderMeta.setPort("" + getPort(originalClusterSchema,slaveServer,infoStep.getName() + " - " + originalStep.getName()));
                socketReaderMeta.setBufferSize(originalClusterSchema.getSocketsBufferSize());
                socketReaderMeta.setCompressed(originalClusterSchema.isSocketsCompressed());
                StepMeta readerStep=new StepMeta(getReaderName(originalStep.getName(),originalClusterSchema,slaveServer),socketReaderMeta);
                readerStep.setLocation(originalStep.getLocation().x - (SPLIT / 2),originalStep.getLocation().y);
                readerStep.setDraw(originalStep.isDrawn());
                slave.addStep(readerStep);
                StepMeta slaveStep=slave.findStep(originalStep.getName());
                if (slaveStep == null) {
                  slaveStep=addSlaveCopy(slave,originalStep,slaveServer);
                }
                TransHopMeta slaveHop=new TransHopMeta(readerStep,slaveStep);
                slave.addTransHop(slaveHop);
                String infoStepNames[]=slaveStep.getStepMetaInterface().getInfoSteps();
                if (infoStepNames != null) {
                  StepMeta is[]=new StepMeta[infoStepNames.length];
                  for (int n=0; n < infoStepNames.length; n++) {
                    is[n]=slave.findStep(infoStepNames[n]);
                    if (infoStepNames[n].equals(infoStep.getName())) {
                      infoSteps[n]=readerStep;
                    }
                  }
                  slaveStep.getStepMetaInterface().setInfoSteps(infoSteps);
                }
              }
            }
          }
 else {
            int nrSlaves=originalClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)originalClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                TransMeta slave=getSlaveTransformation(originalClusterSchema,slaveServer);
                StepMeta slaveStep=slave.findStep(originalStep.getName());
                String infoStepNames[]=slaveStep.getStepMetaInterface().getInfoSteps();
                if (infoStepNames != null) {
                  StepMeta is[]=new StepMeta[infoStepNames.length];
                  for (int n=0; n < infoStepNames.length; n++) {
                    is[n]=slave.findStep(infoStepNames[n]);
                    if (slave.findTransHop(is[n],slaveStep) == null) {
                      TransHopMeta infoHop=new TransHopMeta(is[n],slaveStep);
                      slave.addTransHop(infoHop);
                    }
                  }
                  slaveStep.getStepMetaInterface().setInfoSteps(infoSteps);
                }
              }
            }
          }
        }
      }
    }
    slaveStepCopyPartitionDistribution.setOriginalPartitionSchemas(originalTransformation.getPartitionSchemas());
    for (    SlaveStepCopyPartitionDistribution.SlaveStepCopy slaveStepCopy : slaveStepCopyPartitionDistribution.getDistribution().keySet()) {
      int partition=slaveStepCopyPartitionDistribution.getPartition(slaveStepCopy.getSlaveServerName(),slaveStepCopy.getPartitionSchemaName(),slaveStepCopy.getStepCopyNr());
      System.out.println("slave step copy: slaveServer=" + slaveStepCopy.getSlaveServerName() + ", partition schema="+ slaveStepCopy.getPartitionSchemaName()+ ", copynr="+ slaveStepCopy.getStepCopyNr()+ " ---> partition="+ partition);
    }
    for (    TransMeta transMeta : slaveTransMap.values()) {
      transMeta.setSlaveStepCopyPartitionDistribution(slaveStepCopyPartitionDistribution);
      transMeta.clearChanged();
    }
    master.setSlaveStepCopyPartitionDistribution(slaveStepCopyPartitionDistribution);
    master.clearChanged();
  }
 catch (  Exception e) {
    throw new KettleException("Unexpected problem while generating master transformation",e);
  }
}
