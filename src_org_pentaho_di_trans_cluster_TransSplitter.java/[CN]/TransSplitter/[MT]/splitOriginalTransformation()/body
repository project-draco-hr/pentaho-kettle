{
  clear();
  findUsedOriginalSteps();
  checkClusterConfiguration();
  generateSlaveDatabasePartitions();
  try {
    SlaveServer masterServer=getMasterServer();
    master=getOriginalCopy(false,null,null);
    for (int i=0; i < referenceSteps.length; i++) {
      StepMeta referenceStep=referenceSteps[i];
      ClusterSchema originalClusterSchema=referenceStep.getClusterSchema();
      int nrPreviousSteps=originalTransformation.findNrPrevSteps(referenceStep);
      for (int p=0; p < nrPreviousSteps; p++) {
        StepMeta previousStep=originalTransformation.findPrevStep(referenceStep,p);
        ClusterSchema previousClusterSchema=previousStep.getClusterSchema();
        if (originalClusterSchema == null) {
          if (previousClusterSchema == null) {
            StepMeta target=master.findStep(referenceStep.getName());
            if (target == null) {
              target=(StepMeta)referenceStep.clone();
              master.addStep(target);
            }
            StepMeta source=master.findStep(previousStep.getName());
            if (source == null) {
              source=(StepMeta)previousStep.clone();
              master.addStep(source);
            }
            TransHopMeta masterHop=new TransHopMeta(source,target);
            master.addTransHop(masterHop);
          }
 else {
            StepMeta target=master.findStep(referenceStep.getName());
            if (target == null) {
              target=(StepMeta)referenceStep.clone();
              target.setLocation(target.getLocation().x,target.getLocation().y);
              master.addStep(target);
            }
            int nrSlaves=previousClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)previousClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                int port=getPort(previousClusterSchema,slaveServer,referenceStep.getName());
                RemoteStep remoteSlaveStep=new RemoteStep(slaveServer.getHostname(),Integer.toString(port),previousStep.getName() + ":" + slaveServer.toString(),target.getName(),slaveServer.getName());
                target.getRemoteInputSteps().add(remoteSlaveStep);
                TransMeta slave=getSlaveTransformation(previousClusterSchema,slaveServer);
                StepMeta previous=slave.findStep(previousStep.getName());
                if (previous == null) {
                  previous=(StepMeta)previousStep.clone();
                  previous.setLocation(previousStep.getLocation().x,previousStep.getLocation().y);
                  slave.addStep(previous);
                }
                RemoteStep remoteMasterStep=new RemoteStep(masterServer.getHostname(),Integer.toString(port),previous.getName(),target.getName() + ":" + masterServer.toString(),masterServer.getName());
                previous.getRemoteOutputSteps().add(remoteMasterStep);
              }
            }
          }
        }
 else {
          if (previousClusterSchema == null) {
            int nrSlaves=originalClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)originalClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                StepMeta previous=master.findStep(previousStep.getName());
                if (previous == null) {
                  previous=(StepMeta)previousStep.clone();
                  previous.setLocation(previousStep.getLocation().x,previousStep.getLocation().y);
                  master.addStep(previous);
                }
                int port=getPort(originalClusterSchema,slaveServer,referenceStep.getName());
                RemoteStep remoteMasterStep=new RemoteStep(masterServer.getHostname(),Integer.toString(port),previous.getName(),referenceStep.getName(),masterServer.getName());
                previous.getRemoteOutputSteps().add(remoteMasterStep);
                TransMeta slave=getSlaveTransformation(originalClusterSchema,slaveServer);
                StepMeta slaveStep=slave.findStep(referenceStep.getName());
                if (slaveStep == null) {
                  slaveStep=(StepMeta)referenceStep.clone();
                  slaveStep.setLocation(referenceStep.getLocation().x,referenceStep.getLocation().y);
                  slave.addStep(slaveStep);
                }
                RemoteStep remoteSlaveStep=new RemoteStep(slaveServer.getHostname(),Integer.toString(port),referenceStep.getName(),slaveStep.getName(),slaveServer.getName());
                slaveStep.getRemoteInputSteps().add(remoteSlaveStep);
              }
            }
          }
 else {
            int nrSlaves=originalClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)originalClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                TransMeta slave=getSlaveTransformation(originalClusterSchema,slaveServer);
                StepMeta target=slave.findStep(referenceStep.getName());
                if (target == null) {
                  target=(StepMeta)referenceStep.clone();
                  slave.addStep(target);
                }
                StepMeta source=slave.findStep(previousStep.getName());
                if (source == null) {
                  source=(StepMeta)previousStep.clone();
                  slave.addStep(source);
                }
                TransHopMeta slaveHop=new TransHopMeta(source,target);
                slave.addTransHop(slaveHop);
                verifyStepPartitioning(slave,target,originalClusterSchema,slaveServer);
              }
            }
          }
        }
      }
      if (nrPreviousSteps == 0) {
        if (originalClusterSchema == null) {
          if (master.findStep(referenceStep.getName()) == null)           master.addStep(referenceStep);
        }
 else {
          int nrSlaves=originalClusterSchema.getSlaveServers().size();
          for (int s=0; s < nrSlaves; s++) {
            SlaveServer slaveServer=(SlaveServer)originalClusterSchema.getSlaveServers().get(s);
            if (!slaveServer.isMaster()) {
              TransMeta slave=getSlaveTransformation(originalClusterSchema,slaveServer);
              slave.addStep((StepMeta)referenceStep.clone());
            }
          }
        }
      }
    }
    for (int i=0; i < referenceSteps.length; i++) {
      StepMeta originalStep=referenceSteps[i];
      ClusterSchema originalClusterSchema=originalStep.getClusterSchema();
      StepMeta infoSteps[]=originalTransformation.getInfoStep(originalStep);
      for (int p=0; infoSteps != null && p < infoSteps.length; p++) {
        StepMeta infoStep=infoSteps[p];
        ClusterSchema infoClusterSchema=infoStep.getClusterSchema();
        if (originalClusterSchema == null) {
          if (infoClusterSchema == null) {
            StepMeta target=master.findStep(originalStep.getName());
            StepMeta source=master.findStep(infoStep.getName());
            TransHopMeta masterHop=new TransHopMeta(source,target);
            master.addTransHop(masterHop);
          }
 else {
          }
        }
 else {
          if (infoClusterSchema == null) {
            int nrSlaves=originalClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)originalClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                SocketWriterMeta socketWriterMeta=new SocketWriterMeta();
                socketWriterMeta.setPort("" + getPort(originalClusterSchema,slaveServer,originalStep.getName()));
                socketWriterMeta.setBufferSize(originalClusterSchema.getSocketsBufferSize());
                socketWriterMeta.setFlushInterval(originalClusterSchema.getSocketsFlushInterval());
                socketWriterMeta.setCompressed(originalClusterSchema.isSocketsCompressed());
                StepMeta writerStep=new StepMeta(getWriterName(originalStep.getName(),originalClusterSchema,slaveServer),socketWriterMeta);
                writerStep.setLocation(originalStep.getLocation().x,originalStep.getLocation().y + (s * FANOUT * 2) - (nrSlaves * FANOUT / 2));
                writerStep.setDraw(originalStep.isDrawn());
                master.addStep(writerStep);
                StepMeta previous=master.findStep(infoStep.getName());
                if (previous == null) {
                  previous=(StepMeta)infoStep.clone();
                  master.addStep(previous);
                }
                TransHopMeta masterHop=new TransHopMeta(previous,writerStep);
                master.addTransHop(masterHop);
                TransMeta slave=getSlaveTransformation(originalClusterSchema,slaveServer);
                SocketReaderMeta socketReaderMeta=new SocketReaderMeta();
                socketReaderMeta.setHostname(masterServer.getHostname());
                socketReaderMeta.setPort("" + getPort(originalClusterSchema,slaveServer,originalStep.getName()));
                socketReaderMeta.setBufferSize(originalClusterSchema.getSocketsBufferSize());
                socketReaderMeta.setCompressed(originalClusterSchema.isSocketsCompressed());
                StepMeta readerStep=new StepMeta(getReaderName(originalStep.getName(),originalClusterSchema,slaveServer),socketReaderMeta);
                readerStep.setLocation(originalStep.getLocation().x - (SPLIT / 2),originalStep.getLocation().y);
                readerStep.setDraw(originalStep.isDrawn());
                slave.addStep(readerStep);
                StepMeta slaveStep=slave.findStep(originalStep.getName());
                if (slaveStep == null) {
                  slaveStep=(StepMeta)originalStep.clone();
                  slaveStep.setLocation(originalStep.getLocation().x + (SPLIT / 2),originalStep.getLocation().y);
                  slave.addStep(slaveStep);
                }
                TransHopMeta slaveHop=new TransHopMeta(readerStep,slaveStep);
                slave.addTransHop(slaveHop);
                String infoStepNames[]=slaveStep.getStepMetaInterface().getInfoSteps();
                if (infoStepNames != null) {
                  StepMeta is[]=new StepMeta[infoStepNames.length];
                  for (int n=0; n < infoStepNames.length; n++) {
                    is[n]=slave.findStep(infoStepNames[n]);
                    if (infoStepNames[n].equals(infoStep.getName())) {
                      infoSteps[n]=readerStep;
                    }
                  }
                  slaveStep.getStepMetaInterface().setInfoSteps(infoSteps);
                }
              }
            }
          }
 else {
            int nrSlaves=originalClusterSchema.getSlaveServers().size();
            for (int s=0; s < nrSlaves; s++) {
              SlaveServer slaveServer=(SlaveServer)originalClusterSchema.getSlaveServers().get(s);
              if (!slaveServer.isMaster()) {
                TransMeta slave=getSlaveTransformation(originalClusterSchema,slaveServer);
                StepMeta slaveStep=slave.findStep(originalStep.getName());
                String infoStepNames[]=slaveStep.getStepMetaInterface().getInfoSteps();
                if (infoStepNames != null) {
                  StepMeta is[]=new StepMeta[infoStepNames.length];
                  for (int n=0; n < infoStepNames.length; n++) {
                    is[n]=slave.findStep(infoStepNames[n]);
                    if (slave.findTransHop(is[n],slaveStep) == null) {
                      TransHopMeta infoHop=new TransHopMeta(is[n],slaveStep);
                      slave.addTransHop(infoHop);
                    }
                  }
                  slaveStep.getStepMetaInterface().setInfoSteps(infoSteps);
                }
              }
            }
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new KettleException("Unexpected problem while generating master transformation",e);
  }
}
