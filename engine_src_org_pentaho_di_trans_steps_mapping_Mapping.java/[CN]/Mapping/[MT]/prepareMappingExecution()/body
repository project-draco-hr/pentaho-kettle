{
  initTransFromMeta();
  try {
    getData().getMappingTrans().prepareExecution(getTrans().getArguments());
  }
 catch (  KettleException e) {
    throw new KettleException(BaseMessages.getString(PKG,"Mapping.Exception.UnableToPrepareExecutionOfMapping"),e);
  }
switch (getData().mappingTransMeta.getTransformationType()) {
case Normal:
case SerialSingleThreaded:
    break;
case SingleThreaded:
  getData().singleThreadedTransExcecutor=new SingleThreadedTransExecutor(getData().getMappingTrans());
if (!getData().singleThreadedTransExcecutor.init()) {
  throw new KettleException(BaseMessages.getString(PKG,"Mapping.Exception.UnableToInitSingleThreadedTransformation"));
}
break;
default :
break;
}
MappingInput[] mappingInputs=getData().getMappingTrans().findMappingInput();
LogTableField readField=getData().mappingTransMeta.getTransLogTable().findField(TransLogTable.ID.LINES_READ);
if (readField.getSubject() == null && mappingInputs != null && mappingInputs.length >= 1) {
readField.setSubject(mappingInputs[0].getStepMeta());
}
MappingOutput[] mappingOutputs=getData().getMappingTrans().findMappingOutput();
LogTableField writeField=getData().mappingTransMeta.getTransLogTable().findField(TransLogTable.ID.LINES_WRITTEN);
if (writeField.getSubject() == null && mappingOutputs != null && mappingOutputs.length >= 1) {
writeField.setSubject(mappingOutputs[0].getStepMeta());
}
StepInterface[] sourceSteps;
for (MappingIODefinition inputDefinition : meta.getInputMappings()) {
if (!Const.isEmpty(inputDefinition.getInputStepname())) {
StepInterface sourceStep=getTrans().findRunThread(inputDefinition.getInputStepname());
if (sourceStep == null) {
throw new KettleException(BaseMessages.getString(PKG,"MappingDialog.Exception.StepNameNotFound",inputDefinition.getInputStepname()));
}
sourceSteps=new StepInterface[]{sourceStep};
}
 else {
List<StepMeta> prevSteps=getTransMeta().findPreviousSteps(getStepMeta());
sourceSteps=new StepInterface[prevSteps.size()];
for (int s=0; s < sourceSteps.length; s++) {
sourceSteps[s]=getTrans().findRunThread(prevSteps.get(s).getName());
}
}
MappingInput mappingInputTarget=null;
MappingInput[] mappingInputSteps=getData().getMappingTrans().findMappingInput();
if (Const.isEmpty(inputDefinition.getOutputStepname())) {
if (mappingInputSteps.length == 0) {
throw new KettleException(BaseMessages.getString(PKG,"MappingDialog.Exception.OneMappingInputStepRequired"));
}
if (mappingInputSteps.length > 1) {
throw new KettleException(BaseMessages.getString(PKG,"MappingDialog.Exception.OnlyOneMappingInputStepAllowed","" + mappingInputSteps.length));
}
mappingInputTarget=mappingInputSteps[0];
}
 else {
for (int s=0; s < mappingInputSteps.length && mappingInputTarget == null; s++) {
if (mappingInputSteps[s].getStepname().equals(inputDefinition.getOutputStepname())) {
mappingInputTarget=mappingInputSteps[s];
}
}
if (mappingInputTarget == null) {
throw new KettleException(BaseMessages.getString(PKG,"MappingDialog.Exception.StepNameNotFound",inputDefinition.getOutputStepname()));
}
}
if (inputDefinition.isRenamingOnOutput()) {
addInputRenames(getData().inputRenameList,inputDefinition.getValueRenames());
}
mappingInputTarget.setConnectorSteps(sourceSteps,inputDefinition.getValueRenames(),getStepname());
}
for (MappingIODefinition outputDefinition : meta.getOutputMappings()) {
MappingOutput mappingOutputSource=(MappingOutput)getData().getMappingTrans().findRunThread(outputDefinition.getInputStepname());
if (mappingOutputSource == null) {
MappingOutput[] mappingOutputSteps=getData().getMappingTrans().findMappingOutput();
if (mappingOutputSteps.length == 0) {
throw new KettleException(BaseMessages.getString(PKG,"MappingDialog.Exception.OneMappingOutputStepRequired"));
}
if (mappingOutputSteps.length > 1) {
throw new KettleException(BaseMessages.getString(PKG,"MappingDialog.Exception.OnlyOneMappingOutputStepAllowed","" + mappingOutputSteps.length));
}
mappingOutputSource=mappingOutputSteps[0];
}
StepInterface[] targetSteps;
if (!Const.isEmpty(outputDefinition.getOutputStepname())) {
StepInterface target=getTrans().findRunThread(outputDefinition.getOutputStepname());
if (target == null) {
throw new KettleException(BaseMessages.getString(PKG,"MappingDialog.Exception.StepNameNotFound",outputDefinition.getOutputStepname()));
}
targetSteps=new StepInterface[]{target};
}
 else {
List<StepMeta> nextSteps=getTransMeta().findNextSteps(getStepMeta());
targetSteps=new StepInterface[nextSteps.size()];
for (int s=0; s < targetSteps.length; s++) {
targetSteps[s]=getTrans().findRunThread(nextSteps.get(s).getName());
}
}
mappingOutputSource.setConnectorSteps(targetSteps,getData().inputRenameList,outputDefinition.getValueRenames());
mappingOutputSource.setDistributed(isDistributed());
}
getTrans().getActiveSubtransformations().put(getStepname(),getData().getMappingTrans());
}
