{
  meta=(StepsMetricsMeta)smi;
  data=(StepsMetricsData)sdi;
  if (first) {
    first=false;
    String stepnames[]=null;
    int stepnrs=0;
    if (meta.getStepName() != null && meta.getStepName().length > 0) {
      stepnames=meta.getStepName();
      stepnrs=stepnames.length;
    }
 else {
      throw new KettleException(BaseMessages.getString(PKG,"StepsMetrics.Error.NotSteps"));
    }
    data.realstepnamefield=environmentSubstitute(meta.getStepNameFieldName());
    data.realstepidfield=environmentSubstitute(meta.getStepIdFieldName());
    data.realsteplinesinputfield=environmentSubstitute(meta.getStepLinesInputFieldName());
    data.realsteplinesoutputfield=environmentSubstitute(meta.getStepLinesOutputFieldName());
    data.realsteplinesreadfield=environmentSubstitute(meta.getStepLinesReadFieldName());
    data.realsteplineswrittentfield=environmentSubstitute(meta.getStepLinesWrittenFieldName());
    data.realsteplinesupdatedfield=environmentSubstitute(meta.getStepLinesUpdatedFieldName());
    data.realsteplineserrorsfield=environmentSubstitute(meta.getStepLinesErrorsFieldName());
    data.realstepsecondsfield=environmentSubstitute(meta.getStepSecondsFieldName());
    String[] targetSteps=getTransMeta().getNextStepNames(getStepMeta());
    data.stepInterfaces=new ConcurrentHashMap<Integer,StepInterface>();
    for (int i=0; i < stepnrs; i++) {
      if (stepnames[i].equals(getStepname()))       throw new KettleException("You can not get metrics for the current step [" + stepnames[i] + "]!");
      if (targetSteps != null) {
        for (int j=0; j < targetSteps.length; j++) {
          if (stepnames[i].equals(targetSteps[j]))           throw new KettleException("You can not get metrics for the target step [" + targetSteps[i] + "]!");
        }
      }
      int CopyNr=Const.toInt(meta.getStepCopyNr()[i],0);
      StepInterface si=getTrans().getStepInterface(stepnames[i],CopyNr);
      if (si != null)       data.stepInterfaces.put(i,getDispatcher().findBaseSteps(stepnames[i]).get(CopyNr));
 else {
        if (meta.getStepRequired()[i].equals(StepsMetricsMeta.YES))         throw new KettleException("We cannot get step [" + stepnames[i] + "] CopyNr="+ CopyNr+ "!");
      }
    }
    data.outputRowMeta=new RowMeta();
    meta.getFields(data.outputRowMeta,getStepname(),null,null,this,repository,metaStore);
  }
  data.continueLoop=true;
  while (data.continueLoop && !isStopped()) {
    data.continueLoop=false;
    Iterator<Entry<Integer,StepInterface>> it=data.stepInterfaces.entrySet().iterator();
    while (it.hasNext()) {
      Entry<Integer,StepInterface> e=it.next();
      StepInterface step=e.getValue();
      if (step.getStatus() != StepExecutionStatus.STATUS_FINISHED) {
        data.continueLoop=true;
      }
 else {
        data.stepInterfaces.remove(e.getKey());
        if (log.isDetailed())         logDetailed("Finished running step [" + step.getStepname() + "("+ step.getCopy()+ ")].");
        Object[] rowData=buildEmptyRow();
        incrementLinesRead();
        int index=0;
        if (!Const.isEmpty(data.realstepnamefield))         rowData[index++]=step.getStepname();
        if (!Const.isEmpty(data.realstepidfield))         rowData[index++]=step.getStepID();
        if (!Const.isEmpty(data.realsteplinesinputfield))         rowData[index++]=(long)step.getLinesInput();
        if (!Const.isEmpty(data.realsteplinesoutputfield))         rowData[index++]=(long)step.getLinesOutput();
        if (!Const.isEmpty(data.realsteplinesreadfield))         rowData[index++]=(long)step.getLinesRead();
        if (!Const.isEmpty(data.realsteplinesupdatedfield))         rowData[index++]=(long)step.getLinesUpdated();
        if (!Const.isEmpty(data.realsteplineswrittentfield))         rowData[index++]=(long)step.getLinesWritten();
        if (!Const.isEmpty(data.realsteplineserrorsfield))         rowData[index++]=(long)step.getLinesRejected();
        if (!Const.isEmpty(data.realstepsecondsfield))         rowData[index++]=(long)step.getRuntime();
        putRow(data.outputRowMeta,rowData);
      }
    }
    if (data.continueLoop) {
      try {
        Thread.sleep(200);
      }
 catch (      Exception d) {
      }
    }
  }
  setOutputDone();
  return false;
}
