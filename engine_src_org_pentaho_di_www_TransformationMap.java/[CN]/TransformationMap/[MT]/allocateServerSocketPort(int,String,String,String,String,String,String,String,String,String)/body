{
  if (Utils.isEmpty(clusteredRunId)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a cluster run ID but it was empty");
  }
  if (portRangeStart <= 0) {
    throw new RuntimeException("A server socket allocation always has to accompanied by port range start > 0 but it was " + portRangeStart);
  }
  if (Utils.isEmpty(hostname)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a hostname but it was empty");
  }
  if (Utils.isEmpty(transformationName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a transformation name but it was empty");
  }
  if (Utils.isEmpty(sourceSlaveName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a source slave server name but it was empty");
  }
  if (Utils.isEmpty(targetSlaveName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a target slave server name but it was empty");
  }
  if (Utils.isEmpty(sourceStepName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a source step name but it was empty");
  }
  if (Utils.isEmpty(targetStepName)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a target step name but it was empty");
  }
  if (Utils.isEmpty(sourceStepCopy)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a source step copy but it was empty");
  }
  if (Utils.isEmpty(targetStepCopy)) {
    throw new RuntimeException("A server socket allocation always has to accompanied by a target step copy but it was empty");
  }
synchronized (hostServerSocketPortsMap) {
    List<SocketPortAllocation> serverSocketPortsMap=hostServerSocketPortsMap.get(hostname);
    if (serverSocketPortsMap == null) {
      serverSocketPortsMap=new ArrayList<SocketPortAllocation>();
      hostServerSocketPortsMap.put(hostname,serverSocketPortsMap);
    }
synchronized (serverSocketPortsMap) {
      SocketPortAllocation socketPortAllocation=null;
      int maxPort=portRangeStart - 1;
      for (int index=0; index < serverSocketPortsMap.size(); index++) {
        SocketPortAllocation spa=serverSocketPortsMap.get(index);
        if (spa.getPort() > maxPort) {
          maxPort=spa.getPort();
        }
        if (spa.getClusterRunId().equalsIgnoreCase(clusteredRunId) && spa.getSourceSlaveName().equalsIgnoreCase(sourceSlaveName) && spa.getTargetSlaveName().equalsIgnoreCase(targetSlaveName)&& spa.getTransformationName().equalsIgnoreCase(transformationName)&& spa.getSourceStepName().equalsIgnoreCase(sourceStepName)&& spa.getSourceStepCopy().equalsIgnoreCase(sourceStepCopy)&& spa.getTargetStepName().equalsIgnoreCase(targetStepName)&& spa.getTargetStepCopy().equalsIgnoreCase(targetStepCopy)) {
          spa.setAllocated(true);
          socketPortAllocation=spa;
          break;
        }
 else {
          if (!spa.isAllocated()) {
            if (spa.getSourceSlaveName().equalsIgnoreCase(sourceSlaveName) && spa.getTargetSlaveName().equalsIgnoreCase(targetSlaveName)) {
              socketPortAllocation=new SocketPortAllocation(spa.getPort(),new Date(),clusteredRunId,transformationName,sourceSlaveName,sourceStepName,sourceStepCopy,targetSlaveName,targetStepName,targetStepCopy);
              serverSocketPortsMap.set(index,socketPortAllocation);
              break;
            }
          }
        }
      }
      if (socketPortAllocation == null) {
        socketPortAllocation=new SocketPortAllocation(maxPort + 1,new Date(),clusteredRunId,transformationName,sourceSlaveName,sourceStepName,sourceStepCopy,targetSlaveName,targetStepName,targetStepCopy);
        serverSocketPortsMap.add(socketPortAllocation);
      }
      return socketPortAllocation;
    }
  }
}
