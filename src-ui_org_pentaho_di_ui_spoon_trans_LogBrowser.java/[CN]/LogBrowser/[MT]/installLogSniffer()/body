{
  final AtomicInteger lastLogId=new AtomicInteger(-1);
  final AtomicBoolean busy=new AtomicBoolean(false);
  final Log4jKettleLayout logLayout=new Log4jKettleLayout(true);
  final StyleRange normalLogLineStyle=new StyleRange();
  normalLogLineStyle.foreground=GUIResource.getInstance().getColorBlue();
  final StyleRange errorLogLineStyle=new StyleRange();
  errorLogLineStyle.foreground=GUIResource.getInstance().getColorRed();
  final Timer logRefreshTimer=new Timer();
  TimerTask timerTask=new TimerTask(){
    public void run(){
      text.getDisplay().asyncExec(new Runnable(){
        public void run(){
          HasLogChannelInterface provider=logProvider.getLogChannelProvider();
          if (provider != null && !text.isDisposed() && !busy.get() && !paused.get() && text.isVisible()) {
            busy.set(true);
            LogChannelInterface logChannel=provider.getLogChannel();
            String parentLogChannelId=logChannel.getLogChannelId();
            LoggingRegistry registry=LoggingRegistry.getInstance();
            Date registryModDate=registry.getLastModificationTime();
            if (childIds == null || lastLogRegistryChange == null || registryModDate.compareTo(lastLogRegistryChange) > 0) {
              lastLogRegistryChange=registry.getLastModificationTime();
              childIds=LoggingRegistry.getInstance().getLogChannelChildren(parentLogChannelId);
            }
            int lastNr=CentralLogStore.getLastBufferLineNr();
            if (lastNr > lastLogId.get()) {
              List<LoggingEvent> logLines=CentralLogStore.getLogBufferFromTo(childIds,true,lastLogId.get(),lastNr);
              int maxSize=Props.getInstance().getMaxNrLinesInLog() * 150;
synchronized (text) {
                for (int i=0; i < logLines.size(); i++) {
                  LoggingEvent event=logLines.get(i);
                  String line=logLayout.format(event);
                  int start=text.getText().length();
                  int length=line.length();
                  text.append(line);
                  text.append(Const.CR);
                  if (event.getLevel() == Level.ERROR) {
                    StyleRange styleRange=new StyleRange();
                    styleRange.foreground=GUIResource.getInstance().getColorRed();
                    styleRange.start=start;
                    styleRange.length=length;
                    text.setStyleRange(styleRange);
                  }
 else {
                    StyleRange styleRange=new StyleRange();
                    styleRange.foreground=GUIResource.getInstance().getColorBlue();
                    styleRange.start=start;
                    styleRange.length=20;
                    text.setStyleRange(styleRange);
                  }
                }
              }
              int size=text.getText().length();
              if (maxSize > 0 && size > maxSize) {
                int dropIndex=(text.getText().indexOf(Const.CR,size - maxSize)) + Const.CR.length();
                text.replaceTextRange(0,dropIndex,"");
              }
              text.setSelection(text.getText().length());
              lastLogId.set(lastNr);
            }
            busy.set(false);
          }
        }
      }
);
    }
  }
;
  logRefreshTimer.schedule(timerTask,1000,1000);
  text.addDisposeListener(new DisposeListener(){
    public void widgetDisposed(    DisposeEvent event){
      logRefreshTimer.cancel();
    }
  }
);
}
