{
  getData().mappingTransMeta.setTransformationType(TransformationType.SingleThreaded);
  getData().mappingTrans=new Trans(getData().mappingTransMeta,getTrans());
  passParameters();
  getData().mappingTrans.getTransMeta().setUsingThreadPriorityManagment(false);
  getData().mappingTrans.setParentTrans(getTrans());
  getData().mappingTrans.setSafeModeEnabled(getTrans().isSafeModeEnabled());
  getData().mappingTrans.setGatheringMetrics(getTrans().isGatheringMetrics());
  getData().mappingTrans.setMappingStepName(getStepname());
  initServletConfig();
  getData().mappingTrans.prepareExecution(null);
  if (getData().injectStepMeta.isMappingInput()) {
    MappingInputData mappingInputData=(MappingInputData)getData().mappingTrans.findDataInterface(getData().injectStepMeta.getName());
    mappingInputData.sourceSteps=new StepInterface[0];
    mappingInputData.valueRenames=new ArrayList<MappingValueRename>();
  }
  getData().rowProducer=getData().mappingTrans.addRowProducer(meta.getInjectStep(),0);
  StepInterface retrieveStep=getData().mappingTrans.getStepInterface(meta.getRetrieveStep(),0);
  retrieveStep.addRowListener(new RowAdapter(){
    @Override public void rowWrittenEvent(    RowMetaInterface rowMeta,    Object[] row) throws KettleStepException {
      SingleThreader.this.putRow(rowMeta,row);
    }
  }
);
  getData().mappingTrans.startThreads();
  getData().executor=new SingleThreadedTransExecutor(getData().mappingTrans);
  try {
    boolean ok=getData().executor.init();
    if (!ok) {
      throw new KettleException(BaseMessages.getString(PKG,"SingleThreader.Exception.UnableToInitSingleThreadedTransformation"));
    }
  }
 catch (  KettleException e) {
    throw new KettleException(BaseMessages.getString(PKG,"SingleThreader.Exception.UnableToPrepareExecutionOfMapping"),e);
  }
  getTrans().getActiveSubtransformations().put(getStepname(),getData().mappingTrans);
}
