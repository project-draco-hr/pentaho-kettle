{
  if (samples > 0)   monitor.beginTask("Scanning file...",samples + 1);
 else   monitor.beginTask("Scanning file...",2);
  LogWriter log=LogWriter.getInstance();
  String line="";
  NumberFormat nf=NumberFormat.getInstance();
  DecimalFormat df=(DecimalFormat)nf;
  DecimalFormatSymbols dfs=new DecimalFormatSymbols();
  SimpleDateFormat daf=new SimpleDateFormat();
  DateFormatSymbols dafs=new DateFormatSymbols();
  int nrfields=meta.getInputFields().length;
  int nrnull[]=new int[nrfields];
  String minstr[]=new String[nrfields];
  String maxstr[]=new String[nrfields];
  boolean firststr[]=new boolean[nrfields];
  boolean isDate[]=new boolean[nrfields];
  int dateFormatCount[]=new int[nrfields];
  boolean dateFormat[][]=new boolean[nrfields][Const.dateFormats.length];
  Date minDate[][]=new Date[nrfields][Const.dateFormats.length];
  Date maxDate[][]=new Date[nrfields][Const.dateFormats.length];
  boolean isNumber[]=new boolean[nrfields];
  int numberFormatCount[]=new int[nrfields];
  boolean numberFormat[][]=new boolean[nrfields][Const.numberFormats.length];
  double minValue[][]=new double[nrfields][Const.dateFormats.length];
  double maxValue[][]=new double[nrfields][Const.dateFormats.length];
  int numberPrecision[][]=new int[nrfields][Const.numberFormats.length];
  int numberLength[][]=new int[nrfields][Const.numberFormats.length];
  for (int i=0; i < nrfields; i++) {
    TextFileInputField field=meta.getInputFields()[i];
    debug="init field #" + i;
    if (clearFields == SWT.YES) {
      field.setName(meta.getInputFields()[i].getName());
      field.setType(meta.getInputFields()[i].getType());
      field.setFormat("");
      field.setLength(-1);
      field.setPrecision(-1);
      field.setCurrencySymbol(dfs.getCurrencySymbol());
      field.setDecimalSymbol("" + dfs.getDecimalSeparator());
      field.setGroupSymbol("" + dfs.getGroupingSeparator());
      field.setNullString("-");
      field.setTrimType(TextFileInputMeta.TYPE_TRIM_NONE);
    }
    nrnull[i]=0;
    minstr[i]="";
    maxstr[i]="";
    firststr[i]=true;
    isDate[i]=true;
    for (int j=0; j < Const.dateFormats.length; j++) {
      dateFormat[i][j]=true;
      minDate[i][j]=Const.MAX_DATE;
      maxDate[i][j]=Const.MIN_DATE;
    }
    dateFormatCount[i]=Const.dateFormats.length;
    isNumber[i]=true;
    for (int j=0; j < Const.numberFormats.length; j++) {
      numberFormat[i][j]=true;
      minValue[i][j]=Double.MAX_VALUE;
      maxValue[i][j]=-Double.MAX_VALUE;
      numberPrecision[i][j]=-1;
      numberLength[i][j]=-1;
    }
    numberFormatCount[i]=Const.numberFormats.length;
  }
  TextFileInputMeta strinfo=(TextFileInputMeta)meta.clone();
  for (int i=0; i < nrfields; i++)   strinfo.getInputFields()[i].setType(Value.VALUE_TYPE_STRING);
  debug="get first line";
  if (meta.hasHeader())   line=TextFileInput.getLine(log,reader,meta.getFileFormat());
  int linenr=1;
  DecimalFormat df2=(DecimalFormat)NumberFormat.getInstance();
  DecimalFormatSymbols dfs2=new DecimalFormatSymbols();
  SimpleDateFormat daf2=new SimpleDateFormat();
  boolean errorFound=false;
  while (!errorFound && line != null && (linenr <= samples || samples == 0) && !monitor.isCanceled()) {
    monitor.subTask("Scanning line " + linenr);
    if (samples > 0)     monitor.worked(1);
    debug="convert line #" + linenr + " to row";
    Row r=TextFileInput.convertLineToRow(log,line,strinfo,df,dfs,daf,dafs,meta.getFiles()[0],rownumber);
    rownumber++;
    for (int i=0; i < nrfields && i < r.size(); i++) {
      TextFileInputField field=meta.getInputFields()[i];
      debug="Start of for loop, get new value " + i;
      Value v=r.getValue(i);
      debug="Start of for loop over " + r.size() + " elements in Row r, now at #"+ i+ " containing value : ["+ v.toString()+ "]";
      if (!v.isNull() && v.getString() != null) {
        String fieldValue=v.getString();
        int trimthis=TextFileInputMeta.TYPE_TRIM_NONE;
        boolean spacesBefore=Const.nrSpacesBefore(fieldValue) > 0;
        boolean spacesAfter=Const.nrSpacesAfter(fieldValue) > 0;
        fieldValue=Const.trim(fieldValue);
        if (spacesBefore)         trimthis|=TextFileInputMeta.TYPE_TRIM_LEFT;
        if (spacesAfter)         trimthis|=TextFileInputMeta.TYPE_TRIM_RIGHT;
        debug="change trim type[" + i + "]";
        field.setTrimType(field.getTrimType() | trimthis);
        debug="Field #" + i + " has type : "+ Value.getTypeDesc(field.getType());
        if (isNumber[i]) {
          debug="Number checking of [" + fieldValue.toString() + "] on line #"+ linenr;
          boolean containsDot=false;
          boolean containsComma=false;
          for (int x=0; x < fieldValue.length() && field.getType() == Value.VALUE_TYPE_NUMBER; x++) {
            char ch=fieldValue.charAt(x);
            if (!Character.isDigit(ch) && ch != '.' && ch != ',' && (ch != '-' || x > 0) && ch != 'E' && ch != 'e') {
              isNumber[i]=false;
            }
 else {
              if (ch == '.')               containsDot=true;
              if (ch == ',')               containsComma=true;
            }
          }
          if (isNumber[i]) {
            if (containsDot && !containsComma) {
              dfs2.setDecimalSeparator('.');
              field.setDecimalSymbol(".");
              dfs2.setGroupingSeparator(',');
              field.setGroupSymbol(",");
            }
 else             if (!containsDot && containsComma) {
              dfs2.setDecimalSeparator(',');
              field.setDecimalSymbol(",");
              dfs2.setGroupingSeparator('.');
              field.setGroupSymbol(".");
            }
 else             if (containsDot && containsComma) {
              int indexDot=fieldValue.indexOf(".");
              int indexComma=fieldValue.indexOf(",");
              if (indexDot > indexComma) {
                dfs2.setDecimalSeparator('.');
                field.setDecimalSymbol(".");
                dfs2.setGroupingSeparator(',');
                field.setGroupSymbol(",");
              }
 else {
                dfs2.setDecimalSeparator(',');
                field.setDecimalSymbol(",");
                dfs2.setGroupingSeparator('.');
                field.setGroupSymbol(".");
              }
            }
            for (int x=0; x < Const.numberFormats.length; x++) {
              if (numberFormat[i][x]) {
                try {
                  df2.setDecimalFormatSymbols(dfs2);
                  df2.applyPattern(Const.numberFormats[x]);
                  double d=df2.parse(fieldValue.toString()).doubleValue();
                  int prec=TextFileInputDialog.guessPrecision(d);
                  if (prec > numberPrecision[i][x])                   numberPrecision[i][x]=prec;
                  int leng=TextFileInputDialog.guessLength(d) + prec;
                  if (leng > numberLength[i][x])                   numberLength[i][x]=leng;
                  if (d < minValue[i][x])                   minValue[i][x]=d;
                  if (d > maxValue[i][x])                   maxValue[i][x]=d;
                }
 catch (                Exception e) {
                  numberFormat[i][x]=false;
                  numberFormatCount[i]--;
                }
              }
            }
            if (numberFormatCount[i] == 0) {
              isNumber[i]=false;
            }
          }
        }
        debug="Check max length on field #" + i + " called "+ field.getName()+ " : ["+ fieldValue+ "]";
        if (fieldValue.length() > field.getLength())         field.setLength(fieldValue.length());
        if (isDate[i]) {
          for (int x=0; x < Const.dateFormats.length; x++) {
            if (dateFormat[i][x]) {
              try {
                daf2.applyPattern(Const.dateFormats[x]);
                Date date=daf2.parse(fieldValue.toString());
                Calendar cal=Calendar.getInstance();
                cal.setTime(date);
                int year=cal.get(Calendar.YEAR);
                if (year < 1800 || year > 2200) {
                  dateFormat[i][x]=false;
                  dateFormatCount[i]--;
                }
                if (minDate[i][x].compareTo(date) > 0)                 minDate[i][x]=date;
                if (maxDate[i][x].compareTo(date) < 0)                 maxDate[i][x]=date;
              }
 catch (              Exception e) {
                dateFormat[i][x]=false;
                dateFormatCount[i]--;
              }
            }
          }
          if (dateFormatCount[i] == 0) {
            isDate[i]=false;
          }
        }
        if (firststr[i]) {
          firststr[i]=false;
          minstr[i]=fieldValue.toString();
          maxstr[i]=fieldValue.toString();
        }
        if (minstr[i].compareTo(fieldValue.toString()) > 0)         minstr[i]=fieldValue.toString();
        if (maxstr[i].compareTo(fieldValue.toString()) < 0)         maxstr[i]=fieldValue.toString();
        debug="End of for loop";
      }
 else {
        nrnull[i]++;
      }
    }
    if (!r.isIgnored())     linenr++;
 else     rownumber--;
    debug="Grab another line";
    line=TextFileInput.getLine(log,reader,meta.getFileFormat());
    debug="End of while loop";
  }
  monitor.worked(1);
  monitor.setTaskName("Analysing results...");
  for (int i=0; i < nrfields; i++) {
    TextFileInputField field=meta.getInputFields()[i];
    if (field.getType() == Value.VALUE_TYPE_STRING) {
      if (isDate[i]) {
        field.setType(Value.VALUE_TYPE_DATE);
        for (int x=Const.dateFormats.length - 1; x >= 0; x--) {
          if (dateFormat[i][x]) {
            field.setFormat(Const.dateFormats[x]);
            field.setLength(TextFileInputDialog.dateLengths[x]);
            field.setPrecision(-1);
          }
        }
      }
 else       if (isNumber[i]) {
        field.setType(Value.VALUE_TYPE_NUMBER);
        for (int x=Const.numberFormats.length - 1; x >= 0; x--) {
          if (numberFormat[i][x]) {
            field.setFormat(Const.numberFormats[x]);
            field.setLength(numberLength[i][x]);
            field.setPrecision(numberPrecision[i][x]);
            if (field.getPrecision() == 0 && field.getLength() < 18) {
              field.setType(Value.VALUE_TYPE_INTEGER);
              field.setFormat("");
            }
          }
        }
      }
 else {
        field.setDecimalSymbol("");
        field.setGroupSymbol("");
        field.setCurrencySymbol("");
      }
    }
  }
  String message="";
  message+="Result after scanning " + (linenr - 1) + " lines."+ Const.CR;
  message+="----------------------------------------------------" + Const.CR;
  for (int i=0; i < nrfields; i++) {
    TextFileInputField field=meta.getInputFields()[i];
    message+="Field nr. " + (i + 1) + " :"+ Const.CR;
    message+="  Field name           : " + field.getName() + Const.CR;
    message+="  Field type           : " + field.getTypeDesc() + Const.CR;
switch (field.getType()) {
case Value.VALUE_TYPE_NUMBER:
      message+="  Estimated length     : " + (field.getLength() < 0 ? "-" : "" + field.getLength()) + Const.CR;
    message+="  Estimated precision  : " + (field.getPrecision() < 0 ? "-" : "" + field.getPrecision()) + Const.CR;
  message+="  Number format        : " + field.getFormat() + Const.CR;
if (numberFormatCount[i] > 1) {
  message+="    WARNING: More then 1 number format seems to match all sampled records:" + Const.CR;
}
for (int x=0; x < Const.numberFormats.length; x++) {
if (numberFormat[i][x]) {
  message+="    Number format        : " + Const.numberFormats[x] + Const.CR;
  Value minnum=new Value("minnum",minValue[i][x]);
  Value maxnum=new Value("maxnum",maxValue[i][x]);
  minnum.setLength(numberLength[i][x],numberPrecision[i][x]);
  maxnum.setLength(numberLength[i][x],numberPrecision[i][x]);
  message+="      Minimum value      : " + minnum.toString() + Const.CR;
  message+="      Maximum value      : " + maxnum.toString() + Const.CR;
  try {
    df2.applyPattern(Const.numberFormats[x]);
    df2.setDecimalFormatSymbols(dfs2);
    double mn=df2.parse(minstr[i]).doubleValue();
    Value val=new Value("min",mn);
    val.setLength(numberLength[i][x],numberPrecision[i][x]);
    message+="      Example            : " + Const.numberFormats[x] + ", number ["+ minstr[i]+ "] gives "+ val.toString()+ Const.CR;
  }
 catch (  Exception e) {
    log.logBasic(toString(),"This is unexpected: parsing [" + minstr[i] + "] with format ["+ Const.numberFormats[x]+ "] did not work.");
  }
}
}
message+="  Nr of null values    : " + nrnull[i] + Const.CR;
break;
case Value.VALUE_TYPE_STRING:
message+="  Maximum length       : " + (field.getLength() < 0 ? "-" : "" + field.getLength()) + Const.CR;
message+="  Minimum value        : " + minstr[i] + Const.CR;
message+="  Maximum value        : " + maxstr[i] + Const.CR;
message+="  Nr of null values    : " + nrnull[i] + Const.CR;
break;
case Value.VALUE_TYPE_DATE:
message+="  Maximum length       : " + (field.getLength() < 0 ? "-" : "" + field.getLength()) + Const.CR;
message+="  Date format          : " + field.getFormat() + Const.CR;
if (dateFormatCount[i] > 1) {
message+="    WARNING: More then 1 date format seems to match all sampled records:" + Const.CR;
}
for (int x=0; x < Const.dateFormats.length; x++) {
if (dateFormat[i][x]) {
message+="    Date format          : " + Const.dateFormats[x] + Const.CR;
Value mindate=new Value("mindate",minDate[i][x]);
Value maxdate=new Value("maxdate",maxDate[i][x]);
message+="      Minimum value      : " + mindate.toString() + Const.CR;
message+="      Maximum value      : " + maxdate.toString() + Const.CR;
daf2.applyPattern(Const.dateFormats[x]);
try {
Date md=daf2.parse(minstr[i]);
Value val=new Value("min",md);
val.setLength(field.getLength());
message+="      Example            : " + Const.dateFormats[x] + ", date ["+ minstr[i]+ "] gives "+ val.toString()+ Const.CR;
}
 catch (Exception e) {
log.logError(toString(),"This is unexpected: parsing [" + minstr[i] + "] with format ["+ Const.dateFormats[x]+ "] did not work.");
}
}
}
message+="  Nr of null values    : " + nrnull[i] + Const.CR;
break;
default :
break;
}
if (nrnull[i] == linenr - 1) {
message+="  ALL NULL VALUES!" + Const.CR;
}
message+=Const.CR;
}
monitor.worked(1);
monitor.done();
return message;
}
