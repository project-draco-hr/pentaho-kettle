{
  if (samples > 0)   monitor.beginTask("Scanning file...",samples + 1);
 else   monitor.beginTask("Scanning file...",2);
  LogWriter log=LogWriter.getInstance();
  String line="";
  NumberFormat nf=NumberFormat.getInstance();
  DecimalFormat df=(DecimalFormat)nf;
  DecimalFormatSymbols dfs=new DecimalFormatSymbols();
  SimpleDateFormat daf=new SimpleDateFormat();
  DateFormatSymbols dafs=new DateFormatSymbols();
  int nrfields=meta.getInputFields().length;
  int nrnull[]=new int[nrfields];
  String minstr[]=new String[nrfields];
  String maxstr[]=new String[nrfields];
  boolean firststr[]=new boolean[nrfields];
  boolean isdate[]=new boolean[nrfields];
  int datefmt_cnt[]=new int[nrfields];
  boolean datefmt[][]=new boolean[nrfields][Const.date_formats.length];
  Date mindat[][]=new Date[nrfields][Const.date_formats.length];
  Date maxdat[][]=new Date[nrfields][Const.date_formats.length];
  boolean isnumber[]=new boolean[nrfields];
  int numfmt_cnt[]=new int[nrfields];
  boolean numfmt[][]=new boolean[nrfields][Const.number_formats.length];
  double minval[][]=new double[nrfields][Const.date_formats.length];
  double maxval[][]=new double[nrfields][Const.date_formats.length];
  int numprec[][]=new int[nrfields][Const.number_formats.length];
  int numleng[][]=new int[nrfields][Const.number_formats.length];
  for (int i=0; i < nrfields; i++) {
    TextFileInputField field=meta.getInputFields()[i];
    debug="init field #" + i;
    if (clearFields == SWT.YES) {
      field.setName(meta.getInputFields()[i].getName());
      field.setType(meta.getInputFields()[i].getType());
      field.setFormat("");
      field.setLength(-1);
      field.setPrecision(-1);
      field.setCurrencySymbol(dfs.getCurrencySymbol());
      field.setDecimalSymbol("" + dfs.getDecimalSeparator());
      field.setGroupSymbol("" + dfs.getGroupingSeparator());
      field.setNullString("-");
      field.setTrimType(TextFileInputMeta.TYPE_TRIM_NONE);
    }
    nrnull[i]=0;
    minstr[i]="";
    maxstr[i]="";
    firststr[i]=true;
    isdate[i]=true;
    for (int j=0; j < Const.date_formats.length; j++) {
      datefmt[i][j]=true;
      mindat[i][j]=Const.MAX_DATE;
      maxdat[i][j]=Const.MIN_DATE;
    }
    datefmt_cnt[i]=Const.date_formats.length;
    isnumber[i]=true;
    for (int j=0; j < Const.number_formats.length; j++) {
      numfmt[i][j]=true;
      minval[i][j]=Double.MAX_VALUE;
      maxval[i][j]=-Double.MAX_VALUE;
      numprec[i][j]=-1;
      numleng[i][j]=-1;
    }
    numfmt_cnt[i]=Const.number_formats.length;
  }
  TextFileInputMeta strinfo=(TextFileInputMeta)meta.clone();
  for (int i=0; i < nrfields; i++)   strinfo.getInputFields()[i].setType(Value.VALUE_TYPE_STRING);
  debug="get first line";
  if (meta.hasHeader())   line=TextFileInput.getLine(log,inputStream,meta.getFileFormat());
  int linenr=1;
  DecimalFormat df2=(DecimalFormat)NumberFormat.getInstance();
  DecimalFormatSymbols dfs2=new DecimalFormatSymbols();
  SimpleDateFormat daf2=new SimpleDateFormat();
  boolean error_found=false;
  while (!error_found && line != null && (linenr <= samples || samples == 0) && !monitor.isCanceled()) {
    monitor.subTask("Scanning line " + linenr);
    if (samples > 0)     monitor.worked(1);
    debug="convert line #" + linenr + " to row";
    Row r=TextFileInput.convertLineToRow(log,line,strinfo,true,df,dfs,daf,dafs,meta.getFiles()[0],rownumber);
    rownumber++;
    for (int i=0; i < nrfields && i < r.size(); i++) {
      TextFileInputField field=meta.getInputFields()[i];
      debug="Start of for loop, get new value " + i;
      Value v=r.getValue(i);
      debug="Start of for loop over " + r.size() + " elements in Row r, now at #"+ i+ " containing value : ["+ v.toString()+ "]";
      if (!v.isNull() && v.getString() != null) {
        String fieldValue=v.getString();
        int trimthis=TextFileInputMeta.TYPE_TRIM_NONE;
        boolean spaces_before=Const.nrSpacesBefore(fieldValue) > 0;
        boolean spaces_after=Const.nrSpacesAfter(fieldValue) > 0;
        fieldValue=Const.trim(fieldValue);
        if (spaces_before)         trimthis|=TextFileInputMeta.TYPE_TRIM_LEFT;
        if (spaces_after)         trimthis|=TextFileInputMeta.TYPE_TRIM_RIGHT;
        debug="change trim type[" + i + "]";
        field.setTrimType(field.getTrimType() | trimthis);
        debug="Field #" + i + " has type : "+ Value.getTypeDesc(field.getType());
        if (isnumber[i]) {
          debug="Number checking of [" + fieldValue.toString() + "] on line #"+ linenr;
          boolean contains_dot=false;
          boolean contains_comma=false;
          for (int x=0; x < fieldValue.length() && field.getType() == Value.VALUE_TYPE_NUMBER; x++) {
            char ch=fieldValue.charAt(x);
            if (!Character.isDigit(ch) && ch != '.' && ch != ',' && (ch != '-' || x > 0) && ch != 'E' && ch != 'e') {
              isnumber[i]=false;
            }
 else {
              if (ch == '.')               contains_dot=true;
              if (ch == ',')               contains_comma=true;
            }
          }
          if (isnumber[i]) {
            if (contains_dot && !contains_comma) {
              dfs2.setDecimalSeparator('.');
              field.setDecimalSymbol(".");
              dfs2.setGroupingSeparator(',');
              field.setGroupSymbol(",");
            }
 else             if (!contains_dot && contains_comma) {
              dfs2.setDecimalSeparator(',');
              field.setDecimalSymbol(",");
              dfs2.setGroupingSeparator('.');
              field.setGroupSymbol(".");
            }
 else             if (contains_dot && contains_comma) {
              int idx_dot=fieldValue.indexOf(".");
              int idx_com=fieldValue.indexOf(",");
              if (idx_dot > idx_com) {
                dfs2.setDecimalSeparator('.');
                field.setDecimalSymbol(".");
                dfs2.setGroupingSeparator(',');
                field.setGroupSymbol(",");
              }
 else {
                dfs2.setDecimalSeparator(',');
                field.setDecimalSymbol(",");
                dfs2.setGroupingSeparator('.');
                field.setGroupSymbol(".");
              }
            }
            for (int x=0; x < Const.number_formats.length; x++) {
              if (numfmt[i][x]) {
                try {
                  df2.setDecimalFormatSymbols(dfs2);
                  df2.applyPattern(Const.number_formats[x]);
                  double d=df2.parse(fieldValue.toString()).doubleValue();
                  int prec=TextFileInputDialog.guessPrecision(d);
                  if (prec > numprec[i][x])                   numprec[i][x]=prec;
                  int leng=TextFileInputDialog.guessLength(d) + prec;
                  if (leng > numleng[i][x])                   numleng[i][x]=leng;
                  if (d < minval[i][x])                   minval[i][x]=d;
                  if (d > maxval[i][x])                   maxval[i][x]=d;
                }
 catch (                Exception e) {
                  numfmt[i][x]=false;
                  numfmt_cnt[i]--;
                }
              }
            }
            if (numfmt_cnt[i] == 0) {
              isnumber[i]=false;
            }
          }
        }
        debug="Check max length on field #" + i + " called "+ field.getName()+ " : ["+ fieldValue+ "]";
        if (fieldValue.length() > field.getLength())         field.setLength(fieldValue.length());
        if (isdate[i]) {
          for (int x=0; x < Const.date_formats.length; x++) {
            if (datefmt[i][x]) {
              try {
                daf2.applyPattern(Const.date_formats[x]);
                Date date=daf2.parse(fieldValue.toString());
                Calendar cal=Calendar.getInstance();
                cal.setTime(date);
                int year=cal.get(Calendar.YEAR);
                if (year < 1800 || year > 2200) {
                  datefmt[i][x]=false;
                  datefmt_cnt[i]--;
                }
                if (mindat[i][x].compareTo(date) > 0)                 mindat[i][x]=date;
                if (maxdat[i][x].compareTo(date) < 0)                 maxdat[i][x]=date;
              }
 catch (              Exception e) {
                datefmt[i][x]=false;
                datefmt_cnt[i]--;
              }
            }
          }
          if (datefmt_cnt[i] == 0) {
            isdate[i]=false;
          }
        }
        if (firststr[i]) {
          firststr[i]=false;
          minstr[i]=fieldValue.toString();
          maxstr[i]=fieldValue.toString();
        }
        if (minstr[i].compareTo(fieldValue.toString()) > 0)         minstr[i]=fieldValue.toString();
        if (maxstr[i].compareTo(fieldValue.toString()) < 0)         maxstr[i]=fieldValue.toString();
        debug="End of for loop";
      }
 else {
        nrnull[i]++;
      }
    }
    if (!r.isIgnored())     linenr++;
 else     rownumber--;
    debug="Grab another line";
    line=TextFileInput.getLine(log,inputStream,meta.getFileFormat());
    debug="End of while loop";
  }
  monitor.worked(1);
  monitor.setTaskName("Analysing results...");
  for (int i=0; i < nrfields; i++) {
    TextFileInputField field=meta.getInputFields()[i];
    if (field.getType() == Value.VALUE_TYPE_STRING) {
      if (isdate[i]) {
        field.setType(Value.VALUE_TYPE_DATE);
        for (int x=Const.date_formats.length - 1; x >= 0; x--) {
          if (datefmt[i][x]) {
            field.setFormat(Const.date_formats[x]);
            field.setLength(TextFileInputDialog.date_lengths[x]);
            field.setPrecision(-1);
          }
        }
      }
 else       if (isnumber[i]) {
        field.setType(Value.VALUE_TYPE_NUMBER);
        for (int x=Const.number_formats.length - 1; x >= 0; x--) {
          if (numfmt[i][x]) {
            field.setFormat(Const.number_formats[x]);
            field.setLength(numleng[i][x]);
            field.setPrecision(numprec[i][x]);
            if (field.getPrecision() == 0 && field.getLength() < 18) {
              field.setType(Value.VALUE_TYPE_INTEGER);
              field.setFormat("");
            }
          }
        }
      }
 else {
        field.setDecimalSymbol("");
        field.setGroupSymbol("");
        field.setCurrencySymbol("");
      }
    }
  }
  String message="";
  message+="Result after scanning " + (linenr - 1) + " lines."+ Const.CR;
  message+="----------------------------------------------------" + Const.CR;
  for (int i=0; i < nrfields; i++) {
    TextFileInputField field=meta.getInputFields()[i];
    message+="Field nr. " + (i + 1) + " :"+ Const.CR;
    message+="  Field name           : " + field.getName() + Const.CR;
    message+="  Field type           : " + field.getTypeDesc() + Const.CR;
switch (field.getType()) {
case Value.VALUE_TYPE_NUMBER:
      message+="  Estimated length     : " + (field.getLength() < 0 ? "-" : "" + field.getLength()) + Const.CR;
    message+="  Estimated precision  : " + (field.getPrecision() < 0 ? "-" : "" + field.getPrecision()) + Const.CR;
  message+="  Number format        : " + field.getFormat() + Const.CR;
if (numfmt_cnt[i] > 1) {
  message+="    WARNING: More then 1 number format seems to match all sampled records:" + Const.CR;
}
for (int x=0; x < Const.number_formats.length; x++) {
if (numfmt[i][x]) {
  message+="    Number format        : " + Const.number_formats[x] + Const.CR;
  Value minnum=new Value("minnum",minval[i][x]);
  Value maxnum=new Value("maxnum",maxval[i][x]);
  minnum.setLength(numleng[i][x],numprec[i][x]);
  maxnum.setLength(numleng[i][x],numprec[i][x]);
  message+="      Minimum value      : " + minnum.toString() + Const.CR;
  message+="      Maximum value      : " + maxnum.toString() + Const.CR;
  try {
    df2.applyPattern(Const.number_formats[x]);
    df2.setDecimalFormatSymbols(dfs2);
    double mn=df2.parse(minstr[i]).doubleValue();
    Value val=new Value("min",mn);
    val.setLength(numleng[i][x],numprec[i][x]);
    message+="      Example            : " + Const.number_formats[x] + ", number ["+ minstr[i]+ "] gives "+ val.toString()+ Const.CR;
  }
 catch (  Exception e) {
    log.logBasic(toString(),"This is unexpected: parsing [" + minstr[i] + "] with format ["+ Const.number_formats[x]+ "] did not work.");
  }
}
}
message+="  Nr of null values    : " + nrnull[i] + Const.CR;
break;
case Value.VALUE_TYPE_STRING:
message+="  Maximum length       : " + (field.getLength() < 0 ? "-" : "" + field.getLength()) + Const.CR;
message+="  Minimum value        : " + minstr[i] + Const.CR;
message+="  Maximum value        : " + maxstr[i] + Const.CR;
message+="  Nr of null values    : " + nrnull[i] + Const.CR;
break;
case Value.VALUE_TYPE_DATE:
message+="  Maximum length       : " + (field.getLength() < 0 ? "-" : "" + field.getLength()) + Const.CR;
message+="  Date format          : " + field.getFormat() + Const.CR;
if (datefmt_cnt[i] > 1) {
message+="    WARNING: More then 1 date format seems to match all sampled records:" + Const.CR;
}
for (int x=0; x < Const.date_formats.length; x++) {
if (datefmt[i][x]) {
message+="    Date format          : " + Const.date_formats[x] + Const.CR;
Value mindate=new Value("mindate",mindat[i][x]);
Value maxdate=new Value("maxdate",maxdat[i][x]);
message+="      Minimum value      : " + mindate.toString() + Const.CR;
message+="      Maximum value      : " + maxdate.toString() + Const.CR;
daf2.applyPattern(Const.date_formats[x]);
try {
Date md=daf2.parse(minstr[i]);
Value val=new Value("min",md);
val.setLength(field.getLength());
message+="      Example            : " + Const.date_formats[x] + ", date ["+ minstr[i]+ "] gives "+ val.toString()+ Const.CR;
}
 catch (Exception e) {
log.logError(toString(),"This is unexpected: parsing [" + minstr[i] + "] with format ["+ Const.date_formats[x]+ "] did not work.");
}
}
}
message+="  Nr of null values    : " + nrnull[i] + Const.CR;
break;
default :
break;
}
if (nrnull[i] == linenr - 1) {
message+="  ALL NULL VALUES!" + Const.CR;
}
message+=Const.CR;
}
monitor.worked(1);
monitor.done();
return message;
}
