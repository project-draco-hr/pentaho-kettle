{
  try {
    long read=res.getNrLinesRead();
    long written=res.getNrLinesWritten();
    long updated=res.getNrLinesUpdated();
    long errors=res.getNrErrors();
    long input=res.getNrLinesInput();
    long output=res.getNrLinesOutput();
    if (errors == 0 && !res.getResult())     errors=1;
    logDate=new Date();
    String log_string=null;
    if (jobMeta.isLogfieldUsed()) {
      StringBuffer stringBuffer=CentralLogStore.getAppender().getBuffer(log.getLogChannelId(),true);
      log_string=stringBuffer.append(Const.CR + "END" + Const.CR).toString();
    }
    DatabaseMeta logcon=jobMeta.getLogConnection();
    if (logcon != null) {
      Database ldb=new Database(this,logcon);
      ldb.shareVariablesWith(this);
      try {
        ldb.connect();
        ldb.writeLogRecord(jobMeta.getLogTable(),jobMeta.isBatchIdUsed(),getBatchId(),true,jobMeta.getName(),status,read,written,updated,input,output,errors,startDate,endDate,logDate,depDate,currentDate,log_string);
      }
 catch (      KettleDatabaseException dbe) {
        addErrors(1);
        throw new KettleJobException("Unable to end processing by writing log record to table " + jobMeta.getLogTable(),dbe);
      }
 finally {
        ldb.disconnect();
      }
    }
    return true;
  }
 catch (  Exception e) {
    throw new KettleJobException(e);
  }
}
