{
  Result res=null;
  if (stopped) {
    res=new Result(nr);
    res.stopped=true;
    return res;
  }
  if (log.isDetailed())   log.logDetailed(toString(),"exec(" + nr + ", "+ (prev_result != null ? prev_result.getNrErrors() : 0)+ ", "+ (startpoint != null ? startpoint.toString() : "null")+ ")");
  JobEntryInterface jei=startpoint.getEntry();
  JobEntryResult jerBefore=new JobEntryResult(null,Messages.getString("Job.Comment.JobStarted"),reason,startpoint);
  jobTracker.addJobTracker(new JobTracker(jobMeta,jerBefore));
  Result prevResult=null;
  if (prev_result != null) {
    prevResult=(Result)prev_result.clone();
  }
 else {
    prevResult=new Result();
  }
  ClassLoader cl=Thread.currentThread().getContextClassLoader();
  Thread.currentThread().setContextClassLoader(jei.getClass().getClassLoader());
  JobEntryInterface cloneJei=(JobEntryInterface)jei.clone();
  ((VariableSpace)cloneJei).copyVariablesFrom(this);
  final Result result=cloneJei.execute(prevResult,nr,rep,this);
  Thread.currentThread().setContextClassLoader(cl);
  addErrors((int)result.getNrErrors());
  JobEntryResult jerAfter=new JobEntryResult(result,Messages.getString("Job.Comment.JobFinished"),null,startpoint);
  jobTracker.addJobTracker(new JobTracker(jobMeta,jerAfter));
  final List<Thread> threads=new ArrayList<Thread>();
  final List<Result> threadResults=new ArrayList<Result>();
  final List<KettleException> threadExceptions=new ArrayList<KettleException>();
  final List<JobEntryCopy> threadEntries=new ArrayList<JobEntryCopy>();
  int nrNext=jobMeta.findNrNextJobEntries(startpoint);
  for (int i=0; i < nrNext && !isStopped(); i++) {
    final JobEntryCopy nextEntry=jobMeta.findNextJobEntry(startpoint,i);
    final JobHopMeta hi=jobMeta.findJobHop(startpoint,nextEntry);
    final String nextComment;
    if (hi.isUnconditional()) {
      nextComment=Messages.getString("Job.Comment.FollowedUnconditional");
    }
 else {
      if (result.getResult()) {
        nextComment=Messages.getString("Job.Comment.FollowedSuccess");
      }
 else {
        nextComment=Messages.getString("Job.Comment.FollowedFailure");
      }
    }
    if (hi.isUnconditional() || (startpoint.evaluates() && (!(hi.getEvaluation() ^ result.getResult())))) {
      if (log.isBasic())       log.logBasic(jobMeta.toString(),Messages.getString("Job.Log.StartingEntry",nextEntry.getName()));
      if (nextEntry.resetErrorsBeforeExecution()) {
        result.setNrErrors(0);
      }
      if (startpoint.isLaunchingInParallel()) {
        threadEntries.add(nextEntry);
        Runnable runnable=new Runnable(){
          public void run(){
            try {
              Result threadResult=execute(nr + 1,result,nextEntry,startpoint,nextComment);
              threadResults.add(threadResult);
            }
 catch (            Throwable e) {
              log.logError(toString(),Const.getStackTracker(e));
              threadExceptions.add(new KettleException(Messages.getString("Job.Log.UnexpectedError",nextEntry.toString()),e));
              Result threadResult=new Result();
              threadResult.setResult(false);
              threadResult.setNrErrors(1L);
              threadResults.add(threadResult);
            }
          }
        }
;
        Thread thread=new Thread(runnable);
        threads.add(thread);
        thread.start();
        if (log.isBasic())         log.logBasic(jobMeta.toString(),Messages.getString("Job.Log.LaunchedJobEntryInParallel",nextEntry.getName()));
      }
 else {
        try {
          res=execute(nr + 1,result,nextEntry,startpoint,nextComment);
        }
 catch (        Throwable e) {
          log.logError(toString(),Const.getStackTracker(e));
          throw new KettleException(Messages.getString("Job.Log.UnexpectedError",nextEntry.toString()),e);
        }
        if (log.isBasic())         log.logBasic(jobMeta.toString(),Messages.getString("Job.Log.FinishedJobEntry",nextEntry.getName(),res.getResult() + ""));
      }
    }
  }
  if (startpoint.isLaunchingInParallel()) {
    for (int i=0; i < threads.size(); i++) {
      Thread thread=threads.get(i);
      JobEntryCopy nextEntry=threadEntries.get(i);
      try {
        thread.join();
      }
 catch (      InterruptedException e) {
        log.logError(jobMeta.toString(),Messages.getString("Job.Log.UnexpectedErrorWhileWaitingForJobEntry",nextEntry.getName()));
        threadExceptions.add(new KettleException(Messages.getString("Job.Log.UnexpectedErrorWhileWaitingForJobEntry",nextEntry.getName()),e));
      }
    }
    if (log.isBasic())     log.logBasic(jobMeta.toString(),Messages.getString("Job.Log.FinishedJobEntry",startpoint.getName()));
  }
  if (res == null) {
    res=prevResult;
  }
  if (threadExceptions.size() > 0) {
    res.setResult(false);
    res.setNrErrors(threadExceptions.size());
    for (    KettleException e : threadExceptions) {
      log.logError(jobMeta.toString(),e.getMessage(),e);
    }
    throw threadExceptions.get(0);
  }
  for (  Result threadResult : threadResults) {
    res.add(threadResult);
  }
  return res;
}
