{
  final Axis[] axes=result.getAxes();
  if (axes.length != 2) {
    throw new KettleDatabaseException("Tabular output only supported for 2-dimensional results");
  }
  headings=new ArrayList<String>();
  rows=new ArrayList<List<Object>>();
  final Axis rowsAxis=axes[1];
  final Axis columnsAxis=axes[0];
  int rowOrdinal=-1;
  int[] coords={0,0};
  for (  Position rowPos : rowsAxis.getPositions()) {
    ++rowOrdinal;
    coords[1]=rowOrdinal;
    if (rowOrdinal == 0) {
      for (      Member rowMember : rowPos) {
        headings.add(rowMember.getHierarchy().getUniqueName());
      }
      for (      Position columnPos : columnsAxis.getPositions()) {
        String heading="";
        for (        Member columnMember : columnPos) {
          if (!heading.equals("")) {
            heading+=", ";
          }
          heading+=columnMember.getUniqueName();
        }
        headings.add(heading);
      }
    }
    List<Object> rowValues=new ArrayList<Object>();
    for (    Member rowMember : rowPos) {
      rowValues.add(rowMember.getUniqueName());
    }
    for (int columnOrdinal=0; columnOrdinal < columnsAxis.getPositions().size(); ++columnOrdinal) {
      coords[0]=columnOrdinal;
      final Cell cell=result.getCell(coords);
      rowValues.add(cell.getValue());
    }
    rows.add(rowValues);
  }
  outputRowMeta=new RowMeta();
  if (rows.size() > 0) {
    int columnCount=rows.get(0).size();
    HashSet<Integer> controlHash=new HashSet<Integer>();
    List<ValueMetaInterface> metaValues=new ArrayList<ValueMetaInterface>(columnCount);
    for (int i=0; i < rows.size(); i++) {
      List<Object> rowValues=rows.get(i);
      for (int c=0; c < rowValues.size(); c++) {
        if (controlHash.contains(new Integer(c)))         continue;
        ValueMetaInterface valueMeta=new ValueMeta(headings.get(c));
        Object valueData=rowValues.get(c);
        if (valueData == null)         continue;
        if (valueData instanceof String) {
          valueMeta.setType(ValueMetaInterface.TYPE_STRING);
        }
 else         if (valueData instanceof Date) {
          valueMeta.setType(ValueMetaInterface.TYPE_DATE);
        }
 else         if (valueData instanceof Boolean) {
          valueMeta.setType(ValueMetaInterface.TYPE_BOOLEAN);
        }
 else         if (valueData instanceof Long) {
          valueMeta.setType(ValueMetaInterface.TYPE_INTEGER);
        }
 else         if (valueData instanceof Double) {
          valueMeta.setType(ValueMetaInterface.TYPE_NUMBER);
        }
 else         if (valueData instanceof BigDecimal) {
          valueMeta.setType(ValueMetaInterface.TYPE_BIGNUMBER);
        }
 else {
          throw new KettleDatabaseException("Unhandled data type found '" + valueData.getClass().toString() + "'");
        }
        metaValues.add(c,valueMeta);
        controlHash.add(new Integer(c));
      }
      if (controlHash.size() == columnCount)       break;
    }
    if (controlHash.size() != columnCount) {
      for (int c=0; c < columnCount; c++) {
        if (controlHash.contains(new Integer(c)))         continue;
        ValueMetaInterface valueMeta=new ValueMeta(headings.get(c),ValueMetaInterface.TYPE_STRING);
        metaValues.add(c,valueMeta);
      }
    }
    outputRowMeta.setValueMetaList(metaValues);
  }
  DBCacheEntry cacheEntry=new DBCacheEntry(databaseMeta.getName(),queryString);
  DBCache.getInstance().put(cacheEntry,outputRowMeta);
}
