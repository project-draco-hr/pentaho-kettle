{
  KettleEnvironment.init();
  TransMeta transMeta=new TransMeta();
  transMeta.setName("injectortest");
  transMeta.setTransformationType(TransformationType.Monitored);
  PluginRegistry registry=PluginRegistry.getInstance();
  String injectorStepname="injector step";
  InjectorMeta im=new InjectorMeta();
  String injectorPid=registry.getPluginId(StepPluginType.class,im);
  StepMeta injectorStep=new StepMeta(injectorPid,injectorStepname,(StepMetaInterface)im);
  injectorStep.setLocation(50,50);
  injectorStep.setDraw(true);
  transMeta.addStep(injectorStep);
  StepMeta previous=injectorStep;
  String dummyStepname=null;
  int nrDummySteps=1;
  for (int s=0; s < nrDummySteps; s++) {
    dummyStepname="dummy step " + (s + 1);
    DummyTransMeta dm=new DummyTransMeta();
    String dummyPid=registry.getPluginId(StepPluginType.class,dm);
    StepMeta dummyStep=new StepMeta(dummyPid,dummyStepname,(StepMetaInterface)dm);
    dummyStep.setLocation(100 + 50 * s,50);
    dummyStep.setDraw(true);
    transMeta.addStep(dummyStep);
    TransHopMeta hi=new TransHopMeta(previous,dummyStep);
    transMeta.addTransHop(hi);
    previous=dummyStep;
  }
  transMeta.writeXML("/tmp/idleTest.ktr");
  long transStart=System.currentTimeMillis();
  Trans trans=new Trans(transMeta);
  trans.setLogLevel(LogLevel.MINIMAL);
  trans.prepareExecution(null);
  StepInterface si=trans.getStepInterface(dummyStepname,0);
  RowStepCollector rc=new RowStepCollector();
  si.addRowListener(rc);
  RowProducer rp=trans.addRowProducer(injectorStepname,0);
  trans.startThreads();
  int iterations=10000;
  long totalWait=0;
  for (int i=0; i < iterations; i++) {
    List<RowMetaAndData> inputList=createData();
    for (    RowMetaAndData rm : inputList) {
      rp.putRow(rm.getRowMeta(),rm.getData());
    }
    long start=System.currentTimeMillis();
    while (!trans.isIdle()) {
      Thread.sleep(0,1);
    }
    long end=System.currentTimeMillis();
    long delay=end - start;
    totalWait+=delay;
    System.out.println("#" + i + " : detected idle transformation in "+ delay+ "ms, average is: "+ Const.round(((double)totalWait / (i + 1)),1));
    List<RowMetaAndData> resultRows=rc.getRowsWritten();
    assertEquals(inputList.size(),resultRows.size());
    resultRows.clear();
  }
  rp.finished();
  trans.waitUntilFinished();
  long transEnd=System.currentTimeMillis();
  long transTime=transEnd - transStart;
  System.out.println("Average delay before idle : " + Const.round(((double)totalWait / iterations),1));
  double transTimeSeconds=Const.round(((double)transTime / 1000),1);
  System.out.println("Total transformation runtime for " + iterations + " iterations :"+ transTimeSeconds+ " seconds");
  double transTimePerIteration=Const.round(((double)transTime / iterations),2);
  System.out.println("Runtime per iteration: " + transTimePerIteration + " miliseconds");
  double rowsPerSecond=(double)iterations * createData().size() / ((double)transTime / 1000);
  System.out.println("Average speed: " + rowsPerSecond + " rows/second");
}
